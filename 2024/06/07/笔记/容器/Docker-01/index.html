
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Docker_01 | MaYouXiu</title>
    <meta name="author" content="John Doe" />
    <meta name="description" content="别问，问就是我，马优秀！！！" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="MaYouXiu" type="application/atom+xml">
</head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>MAYOUXIU</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;MAYOUXIU</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading">
            <div class="article">
    <div>
        <h1>Docker_01</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/6/7
        </span>
        
        <span class="category">
            <a href="/categories/%E5%AE%B9%E5%99%A8-Docker/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                容器 - Docker
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E5%AE%B9%E5%99%A8/" style="color: #03a9f4">
                    容器
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/Docker/" style="color: #00bcd4">
                    Docker
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h2 id="Docker技术的背景"><a href="#Docker技术的背景" class="headerlink" title="Docker技术的背景"></a>Docker技术的背景</h2><p>一、背景：物理服务器时代 —&gt; 虚拟化的时代</p>
<p>1、<strong>部署非常慢</strong></p>
<p>服务器上每次部署一套LNMP，首先需要创建一个系统</p>
<p>2、<strong>成本非常高</strong></p>
<p>搭建服务，就会涉及软件版本、依赖包、进程、端口，端口是不可以重复，当有些执行同样的软件，所依赖的软件包版本有要求，可能报错概率非常大。</p>
<p>3、<strong>资源浪费</strong></p>
<p>物理服务器(一般8核+64G)，就为了搭建一个LNMP，估计资源利用率小于20%。</p>
<p>4、<strong>难于迁移和扩展</strong></p>
<p>打包系统或软件，里面数据才是最重要，估计数量和大小估计1个月都搞不定，这里所说的数据不只是10G，20G这种小数量</p>
<p>5、<strong>可能会被限定硬件厂商</strong></p>
<p>物理服务器的内核有包括AMD、Intel等等，不同厂商的内核可能不同，每个厂商设备的配置都不太相同。</p>
<p>二、背景：虚拟化时代 —&gt; 容器化时代</p>
<p>1、vmware虚拟化架构，<strong>解决了环境隔离问题，应用迁移和省钱等问题</strong>。</p>
<p>2、但是虚拟化也是有局限性，每一个虚拟机都是一个完整的操作系统，要分配系统资源，操作系统本身资源也要消耗一部分资源，当创建几百台虚拟机时，有一天出现宿主机资源不够，需要加资源，这时候扩容就非常难了，因为虚拟机正在跑业务。</p>
<p>3、<strong>解决应用部署问题</strong>；包括：网络空间(ip，port，接口等)、进程空间(进程pid)、文件系统空间;就比如要搭建多套LNMP，端口、ip、进程号都不能一样，那么端口和IP这些需要改，而且有些程序会导致死命开进程，导致进程不够用，直接导致服务器死机。为什么包括文件系统空间呢？假如两套LNMP，所需要的python版本是不同的，一个是3.9一个是3.6版本，那么她们的命令要求在&#x2F;usr&#x2F;local&#x2F;sbin下，那么执行命令就有问题了，同一个sbin下两个版本的python。</p>
<p><strong>容器技术解决的是：基于namespace的资源隔离</strong></p>
<p>资源隔离：是指对namespace(主要是进程空间、网络空间、文件系统空间)的隔离，每一台机器都有自己的pid、ip、port等，运行更多独立的应用，并且不冲突。</p>
<p>简单地说，就是能够实现每台机器都有自己的独立的端口号(0~65535)、IP、进程号、文件系统等。</p>
<p><strong>容器最大优势之一：</strong></p>
<p>1、<strong>轻量级</strong></p>
<pre><code class="perl">实现如虚拟机一样环境隔离，有独立的namespace，虚拟机创建虚拟机3分钟，容器需要几秒钟

​	容器：环境交付的一致性(对镜像(发行版+数据)打包)

​	提供隔离的运行环境，多个程序之间，不会出现依赖冲突

例如：容器1:yum install nginx,容器2也安装nginx；完全不影响宿主机，只是产生一些数据而已

​	可以理解为在你宿主机跑100个进程(进程之间是隔离的)
</code></pre>
<p>3、<strong>高性能</strong></p>
<pre><code>    容器没有对宿主机资源的损耗，浪费，例如虚拟机是要具体的分配资源，1核2内存这样

​	容器是直接使用宿主机的最高配置，宿主机2核4内存，那容器也是使用2核4内存；但是，一般我们会限制容器的使用资源，不然会把宿主机搞宕机，就比如你开一个程序CPU占100%，你的电脑还能使用嘛
</code></pre>
<p>4、<strong>容器直接使用宿主机内核，容器没有自己的内核</strong></p>
<pre><code>容器共用宿主机的内核，只是为了发行版；发行版就是镜像，例如centos，说白了就是获取yum工具、lib库文件、依赖包等等，因为没有永宿主机的yum工具，怎么安装系统lib库文件。
</code></pre>
<p><strong>Docker和容器的关系：</strong></p>
<p>docker就是一个对容器增删改查的一个工具，就是一个基于golang开发的一个软件。</p>
<p><strong>容器的作用：</strong></p>
<p>1、创建独立的namespace，一个隔离的环境</p>
<p>2、以及对资源进行限制(cgroups)</p>
<p>3、以及容器是直接使用宿主机的硬件配置(没有虚拟化这种资源损耗)</p>
<h2 id="1、Docker原理流程-架构"><a href="#1、Docker原理流程-架构" class="headerlink" title="1、Docker原理流程&#x2F;架构"></a>1、Docker原理流程&#x2F;架构</h2><h3 id="1-1-Docker工作流程"><a href="#1-1-Docker工作流程" class="headerlink" title="1.1 Docker工作流程"></a>1.1 Docker工作流程</h3><hr>
<p><strong>Namespaces（命名空间）</strong>：提供了进程级的隔离，包括进程ID、网络、用户ID、文件系统挂载点等。通过命名空间，容器中的进程与外部系统的进程是隔离的，它们彼此之间看不到对方的资源。</p>
<p><strong>Cgroups（控制组）</strong>：提供了对系统资源（如CPU、内存、磁盘I&#x2F;O等）的管理和限制。通过cgroups，可以限制一个容器使用的资源量，保证系统的稳定性和性能。</p>
<p><strong>大致流程：</strong></p>
<pre><code>1、Linux本身支持LXC技术(对Linux内核的资源隔离，如果namespace,cgroup)。

2、docker能够调用LXC技术，从而管理容器，进行增删改查。

3、运维和开发人员，基于容器，部署应用。

4、利用docker的命令(docker run...)，从而创建容器
</code></pre>
<p><strong>发行版</strong>：发行版是基于Linux内核的完整操作系统，包括了内核、系统工具、应用软件和包管理系统等</p>
<p>内核是发行版的基础，但发行版不仅仅是内核。发行版还包括了：</p>
<ol>
<li><strong>包管理系统</strong>：用于安装、更新和管理软件包。例如，Debian使用APT，Red Hat使用YUM&#x2F;DNF。</li>
<li><strong>用户界面</strong>：如GNOME、KDE等桌面环境。</li>
<li><strong>系统工具</strong>：如系统监控工具、配置工具等。</li>
<li><strong>应用软件</strong>：预装的应用程序，如浏览器、办公软件等</li>
</ol>
<p><img src="/../../../images/image-20240531210835336.png" alt="image-20240531210835336"></p>
<h3 id="1-2-Docker底层架构"><a href="#1-2-Docker底层架构" class="headerlink" title="1.2 Docker底层架构"></a>1.2 Docker底层架构</h3><p><strong>LXC (Linux Containers)</strong> 是一种轻量级的虚拟化技术，允许在单个Linux内核上运行多个隔离的Linux系统（容器）。LXC利用Linux内核的cgroups（control groups）和namespaces（命名空间）来实现这一点。</p>
<p><strong>通俗地说，就是能够让你在Linux上创建和管理多个独立的容器</strong></p>
<hr>
<p><strong>小历史</strong></p>
<p>LXC只能在Linux平台创建容器，centos，ubuntu等</p>
<p>然后用户也想要在window上创建、管理容器，但是LXC实现不来，因为创建容器需要内核支持。</p>
<p>然后再开发一个底层工具，libcontainer，然后这个工具能够跨平台，能够在window创建也能够Linux创建</p>
<p>刚开始这个libcontainer只能支持部分跨平台，假设只支持戴尔机器上跑，CPU类型不支持等。</p>
<p>然后2015年，成立OCI组织，制定一个统一的容器标准，容器标准格式是一种不受上层结构绑定的协议，即不限定某种特定的操作系统，硬件CPU架构、公有云等，运行任何人在遵循标准的情况下开发应用容器技术。</p>
<p>OCI成立后，后面加入了一个CLI工具，<strong>runC</strong>，真正和Linux内核交互，可以直接修改内核。</p>
<p>LXC	—-发展(实现容器跨平台)—-&gt;	libcontainer	—-迭代(可以直接修改内核)—-&gt;	runC</p>
<hr>
<p><img src="/../../../images/image-20240604182106389.png" alt="image-20240604182106389"></p>
<ol>
<li><strong>runc：</strong><br>**作用: **munc是一个用于运行容器的命令行工具，它实际上是一个容器运行时规范的实现。runc允许你创建和运行符合0pen Container Initiative (0cl)标准的容器。</li>
</ol>
<p>  **功能: **runc负责创建容器的隔离环境，包括进程隔离、文件系统隔离、网络隔离等。它可以从容器映像中启动容器，并管理容器的生命周期(启动、停止、销毁等)。runc是容器运行时的核心组件之一，用于执行容器中的应用程序进程。</p>
<pre><code class="perl">#真正和Linux内核进行交互，比如创建一个namespace空间，就是runC实现启动容器
</code></pre>
<p>  <strong>runC是最底层的工具，可以直接修改内核</strong></p>
<ol start="2">
<li><strong>containerd-shim:</strong><br>**作用: **containerd-shim是containerd的一部分，它充当容器进程与containerd之间的代理。它是一个辅助进程，负责与容器进程进行通信以监控其状态和处理容器的I&#x2F;0。</li>
</ol>
<p>  **功能: **containerd-shim帮助containerd管理容器进程的生命周期，包括启动、停止、重启等。它还负责处理容翳的标准输入、输出和错误流，以便与容器的交互。</p>
<pre><code class="perl">#contained-shim作为容器的父进程，这个进程去操作容器，状态收集、维持stdin等工作。
#containerd-shim来调用runc来启动容器
</code></pre>
<ol start="3">
<li><strong>containerd:</strong><br>**作用: **containerd是一个容器运行时管理器，它负责管理容器的生命周期、镜像管理以及容器的基本操作。</li>
</ol>
<p>  <strong>功能:</strong> containerd与runc集成，充当runc的守护进程，提供高级容器管理功能。它可以与容器编排工具(如Kubernetes)通信，以管理大规模的容器集群。containerd可以被看作是低级容器运行时的一种，为容器生命周期管理提供了一致的API。</p>
<pre><code class="perl">#调用container-shim(容器父进程)”
</code></pre>
<ol start="4">
<li><strong>Docker Engine:</strong><br><strong>作用:</strong> Docker Engine是Docker平台的核心组件，它提供了一个综合性的容器解决方案，包括容器引擎、镜像构建工具、容器编排工具、容器注册表等。</li>
</ol>
<p>  **功能: **Docker Engine允许用户创建、构建、打包、运行和部署容器化的应用程序。它使用runc和containerd等底层技术来执行容器中的应用程序，并提供了用户友好的命令行界面和AP1，以便用户轻松管理容器。Docker Engine也提供了一些高级功能，如Docker Compose和Swarm，用于容器编排和集群管理。</p>
<pre><code class="perl">#用户与docker服务端直接命令操作，只是命令行工具
</code></pre>
<h3 id="1-3-Docker进程架构"><a href="#1-3-Docker进程架构" class="headerlink" title="1.3 Docker进程架构"></a>1.3 Docker进程架构</h3><p>Docker服务器进程(Server Docker Daemon)、REST API 接口、Docker服务端命令行(Client Docker CLI)</p>
<p><img src="/../../../images/image-20240531204129180.png" alt="image-20240531204129180"></p>
<p><strong>Docker Daemon</strong></p>
<p>安装使用Docker，得先运行Docker Daemon进程，用于管理docker(images、containers、network、Data Volumes)。</p>
<p><strong>Rest接口</strong></p>
<p>提供Daemon交互的API接口；</p>
<p>写代码，直接核docker主进程交互，对容器管理。</p>
<h2 id="2、实践-理论理解"><a href="#2、实践-理论理解" class="headerlink" title="2、实践+理论理解"></a>2、实践+理论理解</h2><h3 id="2-1-容器到底什么？"><a href="#2-1-容器到底什么？" class="headerlink" title="2.1 容器到底什么？"></a>2.1 容器到底什么？</h3><p>容器，你可以理解为是：宿主机上的一个进程(被docker进程管理的程序)</p>
<p><img src="/../../../images/image-20240601222111408.png" alt="image-20240601222111408"></p>
<h3 id="2-2-为什么docker启动后会有多一张虚拟网卡？"><a href="#2-2-为什么docker启动后会有多一张虚拟网卡？" class="headerlink" title="2.2 为什么docker启动后会有多一张虚拟网卡？"></a>2.2 为什么docker启动后会有多一张虚拟网卡？</h3><p><img src="/../../../images/image-20240601222343883.png" alt="image-20240601222343883"></p>
<p>docker0网卡，相当于宿主机和容器之间的”虚拟交换机”，可以理解为，如果没有”虚拟交换机”，那多个容器怎么和宿主机通信，宿主机和容器之间网络，可以理解为”内网”。</p>
<p>vetha870f61@if10网卡，是和容器的网卡(例如ens3)进行临时绑定，使得能够与外部通信。</p>
<p>**为什么叫做”临时“？ **</p>
<p>因为如果容器关机，该网卡就会消失&#x2F;解绑，再开机则又会出现&#x2F;绑定。</p>
<p>一般流量走向：</p>
<p><img src="/../../../images/image-20240601223904953.png" alt="image-20240601223904953"></p>
<p><img src="/../../../images/image-20240603232455781.png" alt="image-20240603232455781"></p>
<p>查看路由，发现网关就是docker1那个网卡(172.17.0.1)</p>
<h3 id="2-3-镜像分层原理"><a href="#2-3-镜像分层原理" class="headerlink" title="2.3 镜像分层原理"></a>2.3 镜像分层原理</h3><p>docker的镜像下载：</p>
<p>是下载了一层一层的镜像文件(docker history redis能查看分层关系)</p>
<p>为什么需要镜像分层?</p>
<p>主要原因是：为了节省磁盘空间。</p>
<p><img src="/../../../images/image-20240601231157415.png" alt="image-20240601231157415"></p>
<p>如图中，docker pull redis</p>
<p>a2abf6c4d29d、c7a4e4382001…这种就是一层一层的下载镜像</p>
<p>下载redis容器，如一般步骤：</p>
<ol>
<li>下载发行版(基础镜像，如centos、ubuntu等)</li>
<li>安装redis软件</li>
<li>执行redis程序</li>
</ol>
<p>”a2abf6c4d29d: Already exists“这个就是已经存在的，不需要重新下载这个层，称这个层为：<strong>公共层</strong>。因为我之前下载过nginx容器，可能nginx和redis使用的发行版是一样的，所以直接使用nginx的发行版。</p>
<p>如果图中的docker pull nginx，因为下载过一次nginx容器，所以自然无需再下载，就直接使用”缓存”镜像。</p>
<p><strong>镜像体积</strong></p>
<p><img src="/../../../images/image-20240601233424226.png" alt="image-20240601233424226"></p>
<pre><code class="perl">#图中看到她们的体积分别为141MB、113MB，它们总共254MB，但是她们的实际体积是小于254MB，因为她们俩使用的是同一个发行版。docker history可以查看到底层的镜像09675....，是它们俩最起初的一层镜像，占80.4MB，其余的就是下载软件以及部署环境/配置所占用的体积大小。
</code></pre>
<p>例如，运行nginx容器、jump server容器，假设它们使用的发行版、mysql、mysql的版本一致，那么它们的分层如下图所示</p>
<p>公共层+中间各自的层(各自的逻辑部署)</p>
<p><img src="/../../../images/image-20240602000959662.png" alt="image-20240602000959662"></p>
<p>为什么docker run nginx出现以下情况？</p>
<p><img src="/../../../images/image-20240602003711571.png" alt="image-20240602003711571"></p>
<p>docker run nginx：前台运行，日志打印再前台；又因为nginx镜像的最上层是执行cmd命令，也就是在执行nginx命令。</p>
<p><img src="/../../../images/image-20240602003819661.png" alt="image-20240602003819661"></p>
<h3 id="2-3-容器的本地运行模式和对外运行模式"><a href="#2-3-容器的本地运行模式和对外运行模式" class="headerlink" title="2.3 容器的本地运行模式和对外运行模式"></a>2.3 容器的本地运行模式和对外运行模式</h3><ol>
<li><strong>本地运行模式</strong>（同一个docker0下的容器，都可以互相访问），例如：nginx只在容器内的网络空间运行，不对外，（docker run 别加端口映射参数)</li>
<li><strong>对外运行模式</strong>，对外运行一个 1.19.7的nginx  ，直接访问宿主机的 78就看到 1.19.7的 nginx（docker run -d -p 78:80 nginx:1.19.7）</li>
</ol>
<hr>
<h3 id="2-4-容器如果没有执行前台进程，则会立即挂掉"><a href="#2-4-容器如果没有执行前台进程，则会立即挂掉" class="headerlink" title="2.4 容器如果没有执行前台进程，则会立即挂掉"></a>2.4 容器如果没有执行前台进程，则会立即挂掉</h3><p>如果是：docker run -d nginx 这种除外，-d是能够让容器后台运行，容器退出不挂掉</p>
<p>centos没有出现提示词，而nginx却在执行程序</p>
<p><img src="/../../../images/image-20240603001129306.png" alt="image-20240603001129306"></p>
<p>同样都是执行docker run，为什么出现在命令行的效果不一样？</p>
<p><img src="/../../../images/image-20240603001245342.png" alt="image-20240603001245342"></p>
<p>因为nginx有执行前台进程，所以docker run时，它会执行前台进程，而centos却只是执行bash而已，没有进程，自然run完就自动挂掉。</p>
<p>容器本质：就是包裹着一个运行中断进程，是一个容器空间。</p>
<p>容器内的应用，必须是前台运行的，例如mysql、nginx程序等</p>
<p>可以手工执行，例如：nginx -g “daemon off”，能够使得nginx前台运行，然后把窗口关闭，再然后另外开一个窗口即可。</p>
<h3 id="2-5-如何判断你在容器内还是宿主机？"><a href="#2-5-如何判断你在容器内还是宿主机？" class="headerlink" title="2.5 如何判断你在容器内还是宿主机？"></a>2.5 如何判断你在容器内还是宿主机？</h3><pre><code class="perl"># 看ip     看hostname  网络    network namespace     
# 看进程     进程pid namespace     ps -ef| wc -l
#  命令提示符  看boot目录   file system namespace     ， cat /etc/os-release
</code></pre>
<h3 id="2-6-为什么需要自制docker镜像"><a href="#2-6-为什么需要自制docker镜像" class="headerlink" title="2.6 为什么需要自制docker镜像"></a>2.6 为什么需要自制docker镜像</h3><p>官方给的镜像未必适合我们的需求；官方镜像给我们的是最小化系统，里面很多命令、软件都是没有的，都是给我们自己来扩展。</p>
<p>例如：docker run -d nginx，他会自动帮我运行nginx，但是里面的版本不一定适合我们，nginx可能可以固定版本，nginx:xxx等等，但是基础环境呢，官方默认把nginx在Debian基础镜像上运行，但我想要centos7.9上运行，那该怎么办呢，再想想，基础镜像很多命令都没有的，例如ifconfig,route,vim等等，都需要我们自己去安装。</p>
<pre><code class="perl">#当我们自制镜像的时候，尽量减少无用操作，使得镜像精简化，让镜像体积最小化。
例如更新yum源(yum makecache)，因为最后还是得清空缓存(yum clean all),所以直接下载软件，不用生成缓存等操作，降低容器内资源的占用，最终这个容器会被提交为镜像文件，镜像文件是有体积的
</code></pre>

    </div>

 
    
    
    <ul class="mdui-menu fixed-toc" id="toc">
        <li class="mdui-menu-item">
            <a href="/2024/06/07/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/Docker-01/" id="toc-header" class="mdui-ripple">文章目录</a>
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E6%8A%80%E6%9C%AF%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-text">Docker技术的背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Docker%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B-%E6%9E%B6%E6%9E%84"><span class="toc-text">1、Docker原理流程&#x2F;架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Docker%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">1.1 Docker工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Docker%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-text">1.2 Docker底层架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Docker%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84"><span class="toc-text">1.3 Docker进程架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AE%9E%E8%B7%B5-%E7%90%86%E8%AE%BA%E7%90%86%E8%A7%A3"><span class="toc-text">2、实践+理论理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%B9%E5%99%A8%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2.1 容器到底什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%B8%BA%E4%BB%80%E4%B9%88docker%E5%90%AF%E5%8A%A8%E5%90%8E%E4%BC%9A%E6%9C%89%E5%A4%9A%E4%B8%80%E5%BC%A0%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1%EF%BC%9F"><span class="toc-text">2.2 为什么docker启动后会有多一张虚拟网卡？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">2.3 镜像分层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AF%B9%E5%A4%96%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.3 容器的本地运行模式和对外运行模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%AE%B9%E5%99%A8%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E6%89%A7%E8%A1%8C%E5%89%8D%E5%8F%B0%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%88%99%E4%BC%9A%E7%AB%8B%E5%8D%B3%E6%8C%82%E6%8E%89"><span class="toc-text">2.4 容器如果没有执行前台进程，则会立即挂掉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%BD%A0%E5%9C%A8%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%98%E6%98%AF%E5%AE%BF%E4%B8%BB%E6%9C%BA%EF%BC%9F"><span class="toc-text">2.5 如何判断你在容器内还是宿主机？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%87%AA%E5%88%B6docker%E9%95%9C%E5%83%8F"><span class="toc-text">2.6 为什么需要自制docker镜像</span></a></li></ol></li></ol>
        </li>
    </ul>
    

    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 MaYouXiu
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;John Doe
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
