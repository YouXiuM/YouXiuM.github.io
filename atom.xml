<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MaYouXiu</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-07-20T05:54:20.654Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测试</title>
    <link href="http://example.com/2024/06/07/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0_%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2024/06/07/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0_%E6%A8%A1%E6%9D%BF/</id>
    <published>2024-06-07T15:53:05.000Z</published>
    <updated>2024-07-20T05:54:20.654Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/YouXiuM/typora_img/master/imagesstretched-1920-1080-1251975.jpg" alt="stretched-1920-1080-1251975"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/YouXiuM/typora_img/master/imagesstretched-1920-1080-1251975.jpg&quot; alt=&quot;stretched-1920-1080-125</summary>
      
    
    
    
    <category term="容器 - Docker" scheme="http://example.com/categories/%E5%AE%B9%E5%99%A8-Docker/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker_01</title>
    <link href="http://example.com/2024/06/07/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/Docker-01/"/>
    <id>http://example.com/2024/06/07/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/Docker-01/</id>
    <published>2024-06-07T15:53:05.000Z</published>
    <updated>2024-06-07T16:04:01.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker技术的背景"><a href="#Docker技术的背景" class="headerlink" title="Docker技术的背景"></a>Docker技术的背景</h2><p>一、背景：物理服务器时代 —&gt; 虚拟化的时代</p><p>1、<strong>部署非常慢</strong></p><p>服务器上每次部署一套LNMP，首先需要创建一个系统</p><p>2、<strong>成本非常高</strong></p><p>搭建服务，就会涉及软件版本、依赖包、进程、端口，端口是不可以重复，当有些执行同样的软件，所依赖的软件包版本有要求，可能报错概率非常大。</p><p>3、<strong>资源浪费</strong></p><p>物理服务器(一般8核+64G)，就为了搭建一个LNMP，估计资源利用率小于20%。</p><p>4、<strong>难于迁移和扩展</strong></p><p>打包系统或软件，里面数据才是最重要，估计数量和大小估计1个月都搞不定，这里所说的数据不只是10G，20G这种小数量</p><p>5、<strong>可能会被限定硬件厂商</strong></p><p>物理服务器的内核有包括AMD、Intel等等，不同厂商的内核可能不同，每个厂商设备的配置都不太相同。</p><p>二、背景：虚拟化时代 —&gt; 容器化时代</p><p>1、vmware虚拟化架构，<strong>解决了环境隔离问题，应用迁移和省钱等问题</strong>。</p><p>2、但是虚拟化也是有局限性，每一个虚拟机都是一个完整的操作系统，要分配系统资源，操作系统本身资源也要消耗一部分资源，当创建几百台虚拟机时，有一天出现宿主机资源不够，需要加资源，这时候扩容就非常难了，因为虚拟机正在跑业务。</p><p>3、<strong>解决应用部署问题</strong>；包括：网络空间(ip，port，接口等)、进程空间(进程pid)、文件系统空间;就比如要搭建多套LNMP，端口、ip、进程号都不能一样，那么端口和IP这些需要改，而且有些程序会导致死命开进程，导致进程不够用，直接导致服务器死机。为什么包括文件系统空间呢？假如两套LNMP，所需要的python版本是不同的，一个是3.9一个是3.6版本，那么她们的命令要求在&#x2F;usr&#x2F;local&#x2F;sbin下，那么执行命令就有问题了，同一个sbin下两个版本的python。</p><p><strong>容器技术解决的是：基于namespace的资源隔离</strong></p><p>资源隔离：是指对namespace(主要是进程空间、网络空间、文件系统空间)的隔离，每一台机器都有自己的pid、ip、port等，运行更多独立的应用，并且不冲突。</p><p>简单地说，就是能够实现每台机器都有自己的独立的端口号(0~65535)、IP、进程号、文件系统等。</p><p><strong>容器最大优势之一：</strong></p><p>1、<strong>轻量级</strong></p><pre><code class="perl">实现如虚拟机一样环境隔离，有独立的namespace，虚拟机创建虚拟机3分钟，容器需要几秒钟​容器：环境交付的一致性(对镜像(发行版+数据)打包)​提供隔离的运行环境，多个程序之间，不会出现依赖冲突例如：容器1:yum install nginx,容器2也安装nginx；完全不影响宿主机，只是产生一些数据而已​可以理解为在你宿主机跑100个进程(进程之间是隔离的)</code></pre><p>3、<strong>高性能</strong></p><pre><code>    容器没有对宿主机资源的损耗，浪费，例如虚拟机是要具体的分配资源，1核2内存这样​容器是直接使用宿主机的最高配置，宿主机2核4内存，那容器也是使用2核4内存；但是，一般我们会限制容器的使用资源，不然会把宿主机搞宕机，就比如你开一个程序CPU占100%，你的电脑还能使用嘛</code></pre><p>4、<strong>容器直接使用宿主机内核，容器没有自己的内核</strong></p><pre><code>容器共用宿主机的内核，只是为了发行版；发行版就是镜像，例如centos，说白了就是获取yum工具、lib库文件、依赖包等等，因为没有永宿主机的yum工具，怎么安装系统lib库文件。</code></pre><p><strong>Docker和容器的关系：</strong></p><p>docker就是一个对容器增删改查的一个工具，就是一个基于golang开发的一个软件。</p><p><strong>容器的作用：</strong></p><p>1、创建独立的namespace，一个隔离的环境</p><p>2、以及对资源进行限制(cgroups)</p><p>3、以及容器是直接使用宿主机的硬件配置(没有虚拟化这种资源损耗)</p><h2 id="1、Docker原理流程-架构"><a href="#1、Docker原理流程-架构" class="headerlink" title="1、Docker原理流程&#x2F;架构"></a>1、Docker原理流程&#x2F;架构</h2><h3 id="1-1-Docker工作流程"><a href="#1-1-Docker工作流程" class="headerlink" title="1.1 Docker工作流程"></a>1.1 Docker工作流程</h3><hr><p><strong>Namespaces（命名空间）</strong>：提供了进程级的隔离，包括进程ID、网络、用户ID、文件系统挂载点等。通过命名空间，容器中的进程与外部系统的进程是隔离的，它们彼此之间看不到对方的资源。</p><p><strong>Cgroups（控制组）</strong>：提供了对系统资源（如CPU、内存、磁盘I&#x2F;O等）的管理和限制。通过cgroups，可以限制一个容器使用的资源量，保证系统的稳定性和性能。</p><p><strong>大致流程：</strong></p><pre><code>1、Linux本身支持LXC技术(对Linux内核的资源隔离，如果namespace,cgroup)。2、docker能够调用LXC技术，从而管理容器，进行增删改查。3、运维和开发人员，基于容器，部署应用。4、利用docker的命令(docker run...)，从而创建容器</code></pre><p><strong>发行版</strong>：发行版是基于Linux内核的完整操作系统，包括了内核、系统工具、应用软件和包管理系统等</p><p>内核是发行版的基础，但发行版不仅仅是内核。发行版还包括了：</p><ol><li><strong>包管理系统</strong>：用于安装、更新和管理软件包。例如，Debian使用APT，Red Hat使用YUM&#x2F;DNF。</li><li><strong>用户界面</strong>：如GNOME、KDE等桌面环境。</li><li><strong>系统工具</strong>：如系统监控工具、配置工具等。</li><li><strong>应用软件</strong>：预装的应用程序，如浏览器、办公软件等</li></ol><p><img src="/../../../images/image-20240531210835336.png" alt="image-20240531210835336"></p><h3 id="1-2-Docker底层架构"><a href="#1-2-Docker底层架构" class="headerlink" title="1.2 Docker底层架构"></a>1.2 Docker底层架构</h3><p><strong>LXC (Linux Containers)</strong> 是一种轻量级的虚拟化技术，允许在单个Linux内核上运行多个隔离的Linux系统（容器）。LXC利用Linux内核的cgroups（control groups）和namespaces（命名空间）来实现这一点。</p><p><strong>通俗地说，就是能够让你在Linux上创建和管理多个独立的容器</strong></p><hr><p><strong>小历史</strong></p><p>LXC只能在Linux平台创建容器，centos，ubuntu等</p><p>然后用户也想要在window上创建、管理容器，但是LXC实现不来，因为创建容器需要内核支持。</p><p>然后再开发一个底层工具，libcontainer，然后这个工具能够跨平台，能够在window创建也能够Linux创建</p><p>刚开始这个libcontainer只能支持部分跨平台，假设只支持戴尔机器上跑，CPU类型不支持等。</p><p>然后2015年，成立OCI组织，制定一个统一的容器标准，容器标准格式是一种不受上层结构绑定的协议，即不限定某种特定的操作系统，硬件CPU架构、公有云等，运行任何人在遵循标准的情况下开发应用容器技术。</p><p>OCI成立后，后面加入了一个CLI工具，<strong>runC</strong>，真正和Linux内核交互，可以直接修改内核。</p><p>LXC—-发展(实现容器跨平台)—-&gt;libcontainer—-迭代(可以直接修改内核)—-&gt;runC</p><hr><p><img src="/../../../images/image-20240604182106389.png" alt="image-20240604182106389"></p><ol><li><strong>runc：</strong><br>**作用: **munc是一个用于运行容器的命令行工具，它实际上是一个容器运行时规范的实现。runc允许你创建和运行符合0pen Container Initiative (0cl)标准的容器。</li></ol><p>  **功能: **runc负责创建容器的隔离环境，包括进程隔离、文件系统隔离、网络隔离等。它可以从容器映像中启动容器，并管理容器的生命周期(启动、停止、销毁等)。runc是容器运行时的核心组件之一，用于执行容器中的应用程序进程。</p><pre><code class="perl">#真正和Linux内核进行交互，比如创建一个namespace空间，就是runC实现启动容器</code></pre><p>  <strong>runC是最底层的工具，可以直接修改内核</strong></p><ol start="2"><li><strong>containerd-shim:</strong><br>**作用: **containerd-shim是containerd的一部分，它充当容器进程与containerd之间的代理。它是一个辅助进程，负责与容器进程进行通信以监控其状态和处理容器的I&#x2F;0。</li></ol><p>  **功能: **containerd-shim帮助containerd管理容器进程的生命周期，包括启动、停止、重启等。它还负责处理容翳的标准输入、输出和错误流，以便与容器的交互。</p><pre><code class="perl">#contained-shim作为容器的父进程，这个进程去操作容器，状态收集、维持stdin等工作。#containerd-shim来调用runc来启动容器</code></pre><ol start="3"><li><strong>containerd:</strong><br>**作用: **containerd是一个容器运行时管理器，它负责管理容器的生命周期、镜像管理以及容器的基本操作。</li></ol><p>  <strong>功能:</strong> containerd与runc集成，充当runc的守护进程，提供高级容器管理功能。它可以与容器编排工具(如Kubernetes)通信，以管理大规模的容器集群。containerd可以被看作是低级容器运行时的一种，为容器生命周期管理提供了一致的API。</p><pre><code class="perl">#调用container-shim(容器父进程)”</code></pre><ol start="4"><li><strong>Docker Engine:</strong><br><strong>作用:</strong> Docker Engine是Docker平台的核心组件，它提供了一个综合性的容器解决方案，包括容器引擎、镜像构建工具、容器编排工具、容器注册表等。</li></ol><p>  **功能: **Docker Engine允许用户创建、构建、打包、运行和部署容器化的应用程序。它使用runc和containerd等底层技术来执行容器中的应用程序，并提供了用户友好的命令行界面和AP1，以便用户轻松管理容器。Docker Engine也提供了一些高级功能，如Docker Compose和Swarm，用于容器编排和集群管理。</p><pre><code class="perl">#用户与docker服务端直接命令操作，只是命令行工具</code></pre><h3 id="1-3-Docker进程架构"><a href="#1-3-Docker进程架构" class="headerlink" title="1.3 Docker进程架构"></a>1.3 Docker进程架构</h3><p>Docker服务器进程(Server Docker Daemon)、REST API 接口、Docker服务端命令行(Client Docker CLI)</p><p><img src="/../../../images/image-20240531204129180.png" alt="image-20240531204129180"></p><p><strong>Docker Daemon</strong></p><p>安装使用Docker，得先运行Docker Daemon进程，用于管理docker(images、containers、network、Data Volumes)。</p><p><strong>Rest接口</strong></p><p>提供Daemon交互的API接口；</p><p>写代码，直接核docker主进程交互，对容器管理。</p><h2 id="2、实践-理论理解"><a href="#2、实践-理论理解" class="headerlink" title="2、实践+理论理解"></a>2、实践+理论理解</h2><h3 id="2-1-容器到底什么？"><a href="#2-1-容器到底什么？" class="headerlink" title="2.1 容器到底什么？"></a>2.1 容器到底什么？</h3><p>容器，你可以理解为是：宿主机上的一个进程(被docker进程管理的程序)</p><p><img src="/../../../images/image-20240601222111408.png" alt="image-20240601222111408"></p><h3 id="2-2-为什么docker启动后会有多一张虚拟网卡？"><a href="#2-2-为什么docker启动后会有多一张虚拟网卡？" class="headerlink" title="2.2 为什么docker启动后会有多一张虚拟网卡？"></a>2.2 为什么docker启动后会有多一张虚拟网卡？</h3><p><img src="/../../../images/image-20240601222343883.png" alt="image-20240601222343883"></p><p>docker0网卡，相当于宿主机和容器之间的”虚拟交换机”，可以理解为，如果没有”虚拟交换机”，那多个容器怎么和宿主机通信，宿主机和容器之间网络，可以理解为”内网”。</p><p>vetha870f61@if10网卡，是和容器的网卡(例如ens3)进行临时绑定，使得能够与外部通信。</p><p>**为什么叫做”临时“？ **</p><p>因为如果容器关机，该网卡就会消失&#x2F;解绑，再开机则又会出现&#x2F;绑定。</p><p>一般流量走向：</p><p><img src="/../../../images/image-20240601223904953.png" alt="image-20240601223904953"></p><p><img src="/../../../images/image-20240603232455781.png" alt="image-20240603232455781"></p><p>查看路由，发现网关就是docker1那个网卡(172.17.0.1)</p><h3 id="2-3-镜像分层原理"><a href="#2-3-镜像分层原理" class="headerlink" title="2.3 镜像分层原理"></a>2.3 镜像分层原理</h3><p>docker的镜像下载：</p><p>是下载了一层一层的镜像文件(docker history redis能查看分层关系)</p><p>为什么需要镜像分层?</p><p>主要原因是：为了节省磁盘空间。</p><p><img src="/../../../images/image-20240601231157415.png" alt="image-20240601231157415"></p><p>如图中，docker pull redis</p><p>a2abf6c4d29d、c7a4e4382001…这种就是一层一层的下载镜像</p><p>下载redis容器，如一般步骤：</p><ol><li>下载发行版(基础镜像，如centos、ubuntu等)</li><li>安装redis软件</li><li>执行redis程序</li></ol><p>”a2abf6c4d29d: Already exists“这个就是已经存在的，不需要重新下载这个层，称这个层为：<strong>公共层</strong>。因为我之前下载过nginx容器，可能nginx和redis使用的发行版是一样的，所以直接使用nginx的发行版。</p><p>如果图中的docker pull nginx，因为下载过一次nginx容器，所以自然无需再下载，就直接使用”缓存”镜像。</p><p><strong>镜像体积</strong></p><p><img src="/../../../images/image-20240601233424226.png" alt="image-20240601233424226"></p><pre><code class="perl">#图中看到她们的体积分别为141MB、113MB，它们总共254MB，但是她们的实际体积是小于254MB，因为她们俩使用的是同一个发行版。docker history可以查看到底层的镜像09675....，是它们俩最起初的一层镜像，占80.4MB，其余的就是下载软件以及部署环境/配置所占用的体积大小。</code></pre><p>例如，运行nginx容器、jump server容器，假设它们使用的发行版、mysql、mysql的版本一致，那么它们的分层如下图所示</p><p>公共层+中间各自的层(各自的逻辑部署)</p><p><img src="/../../../images/image-20240602000959662.png" alt="image-20240602000959662"></p><p>为什么docker run nginx出现以下情况？</p><p><img src="/../../../images/image-20240602003711571.png" alt="image-20240602003711571"></p><p>docker run nginx：前台运行，日志打印再前台；又因为nginx镜像的最上层是执行cmd命令，也就是在执行nginx命令。</p><p><img src="/../../../images/image-20240602003819661.png" alt="image-20240602003819661"></p><h3 id="2-3-容器的本地运行模式和对外运行模式"><a href="#2-3-容器的本地运行模式和对外运行模式" class="headerlink" title="2.3 容器的本地运行模式和对外运行模式"></a>2.3 容器的本地运行模式和对外运行模式</h3><ol><li><strong>本地运行模式</strong>（同一个docker0下的容器，都可以互相访问），例如：nginx只在容器内的网络空间运行，不对外，（docker run 别加端口映射参数)</li><li><strong>对外运行模式</strong>，对外运行一个 1.19.7的nginx  ，直接访问宿主机的 78就看到 1.19.7的 nginx（docker run -d -p 78:80 nginx:1.19.7）</li></ol><hr><h3 id="2-4-容器如果没有执行前台进程，则会立即挂掉"><a href="#2-4-容器如果没有执行前台进程，则会立即挂掉" class="headerlink" title="2.4 容器如果没有执行前台进程，则会立即挂掉"></a>2.4 容器如果没有执行前台进程，则会立即挂掉</h3><p>如果是：docker run -d nginx 这种除外，-d是能够让容器后台运行，容器退出不挂掉</p><p>centos没有出现提示词，而nginx却在执行程序</p><p><img src="/../../../images/image-20240603001129306.png" alt="image-20240603001129306"></p><p>同样都是执行docker run，为什么出现在命令行的效果不一样？</p><p><img src="/../../../images/image-20240603001245342.png" alt="image-20240603001245342"></p><p>因为nginx有执行前台进程，所以docker run时，它会执行前台进程，而centos却只是执行bash而已，没有进程，自然run完就自动挂掉。</p><p>容器本质：就是包裹着一个运行中断进程，是一个容器空间。</p><p>容器内的应用，必须是前台运行的，例如mysql、nginx程序等</p><p>可以手工执行，例如：nginx -g “daemon off”，能够使得nginx前台运行，然后把窗口关闭，再然后另外开一个窗口即可。</p><h3 id="2-5-如何判断你在容器内还是宿主机？"><a href="#2-5-如何判断你在容器内还是宿主机？" class="headerlink" title="2.5 如何判断你在容器内还是宿主机？"></a>2.5 如何判断你在容器内还是宿主机？</h3><pre><code class="perl"># 看ip     看hostname  网络    network namespace     # 看进程     进程pid namespace     ps -ef| wc -l#  命令提示符  看boot目录   file system namespace     ， cat /etc/os-release</code></pre><h3 id="2-6-为什么需要自制docker镜像"><a href="#2-6-为什么需要自制docker镜像" class="headerlink" title="2.6 为什么需要自制docker镜像"></a>2.6 为什么需要自制docker镜像</h3><p>官方给的镜像未必适合我们的需求；官方镜像给我们的是最小化系统，里面很多命令、软件都是没有的，都是给我们自己来扩展。</p><p>例如：docker run -d nginx，他会自动帮我运行nginx，但是里面的版本不一定适合我们，nginx可能可以固定版本，nginx:xxx等等，但是基础环境呢，官方默认把nginx在Debian基础镜像上运行，但我想要centos7.9上运行，那该怎么办呢，再想想，基础镜像很多命令都没有的，例如ifconfig,route,vim等等，都需要我们自己去安装。</p><pre><code class="perl">#当我们自制镜像的时候，尽量减少无用操作，使得镜像精简化，让镜像体积最小化。例如更新yum源(yum makecache)，因为最后还是得清空缓存(yum clean all),所以直接下载软件，不用生成缓存等操作，降低容器内资源的占用，最终这个容器会被提交为镜像文件，镜像文件是有体积的</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Docker技术的背景&quot;&gt;&lt;a href=&quot;#Docker技术的背景&quot; class=&quot;headerlink&quot; title=&quot;Docker技术的背景&quot;&gt;&lt;/a&gt;Docker技术的背景&lt;/h2&gt;&lt;p&gt;一、背景：物理服务器时代 —&amp;gt; 虚拟化的时代&lt;/p&gt;
&lt;p&gt;1</summary>
      
    
    
    
    <category term="容器 - Docker" scheme="http://example.com/categories/%E5%AE%B9%E5%99%A8-Docker/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-02</title>
    <link href="http://example.com/2024/06/07/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/Docker-02/"/>
    <id>http://example.com/2024/06/07/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/Docker-02/</id>
    <published>2024-06-06T16:00:00.000Z</published>
    <updated>2024-06-07T16:14:24.817Z</updated>
    
    <content type="html"><![CDATA[<ol><li>部署docker</li></ol><h3 id="1-1手动开启宿主机内核数据包转发功能"><a href="#1-1手动开启宿主机内核数据包转发功能" class="headerlink" title="1.1手动开启宿主机内核数据包转发功能"></a>1.1手动开启宿主机内核数据包转发功能</h3><pre><code class="perl">cat &lt;&lt;EOF&gt;/etc/sysctl.d/docker.confnet.ipv4.ip forward=lnet.bridge.bridge-nf-call-ip6tables =1net.bridge.bridge-nf-call-iptables = 1EOFsysctl -p /etc/sysctl.d/docker.conf1.net.bridge.bridge-nf-call-ip6tables =1#这个设置允许IPV6的网络包通过iptables规则进行处理。Docke外部世界的网络通信，因此需要确保IPv6的网络包也能够通过2.net.bridge.bridge-nf-call-iptables = 1#这个设置允许IPv4的网络包通过iptables规则进行处理。与前面包能够通过iptables进行适当的处理，包括端口转发、防火墙规3.net.ipv4.ip forward=l#这个设置允许Linux系统上的IP数据包进行转发，在Docker中，通常会使用网络式为&quot;bridge&quot;的容器，这要求主机上启用IP数据包转发，以便容器之间可以相互通信以及与外部网络通信。启用此选项允许Linux主机上的IP数据包在网络接口之间进行正确的路由和转发。</code></pre><h3 id="1-2安装流程"><a href="#1-2安装流程" class="headerlink" title="1.2安装流程"></a>1.2安装流程</h3><p>我使用的Centos7,官方建议 3.10 以上，3.8以上好像也可以。</p><p><strong>1.查看当前的内核版本</strong></p><p>uname -r</p><p><strong>2.使用 root 权限更新 yum 包（生产环境中此步操作需慎重，看自己情况，学习的话随便搞）</strong></p><p>**注意 **</p><p>yum -y update：升级所有包同时也升级软件和系统内核；  </p><p>yum -y upgrade：只升级所有包，不升级软件和系统内核</p><p><strong>3.卸载旧版本（如果之前安装过的话）</strong></p><p>yum remove docker  docker-common docker-selinux docker-engine</p><p><strong>4.安装需要的软件包， yum-util 提供yum-config-manager功能，另两个是devicemapper驱动依赖</strong></p><p>yum install -y yum-utils device-mapper-persistent-data lvm2</p><p><strong>5.配置yum源</strong></p><p>yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p><p><strong>6.选择docker版本并安装</strong></p><p>yum list docker-ce –showduplicates | sort -r</p><p>这里我选择默认</p><p>yum install docker-ce -y</p><p><strong>7.启动 Docker 并设置开机自启</strong></p><p>systemctl start docker </p><p>systemctl enable docker</p><p>这里就能够正常使用了！！！</p><hr><p>如果出现以下情况：</p><p><img src="/.com//../..%5Cimages%5Cimage-20240601001827044.png" alt="image-20240601001827044"></p><ol><li>首先使用yum 安装docker，yum install docker -y。使用docker -v检查docker是否安装成功</li></ol><p><img src="/.com//../..%5Cimages%5Cimage-20240601001953821.png" alt="image-20240601001953821"></p><ol start="2"><li>因为docker使用了iptables的映射规则，而centos7的防火墙是firewall，需要停用 firewall，安装并设置iptables.</li></ol><pre><code class="perl">systemctl stop firewalld;systemctl disable firewalld;yum -y install iptables-services;systemctl enable iptables ;systemctl start iptables;</code></pre><ol start="3"><li>如果centos7版本的内核比较旧，如我的安装完内核是3.10。需要升级linux内核或者修改配置文件。</li></ol><p><strong>这里我选择”升级linux内核”</strong></p><p>可以使用如下命令  </p><pre><code class="perl">yum update nss \&amp;&amp; rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org \&amp;&amp; rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm \&amp;&amp; yum clean all \&amp;&amp; yum --enablerepo=elrepo-kernel install kernel-ml -y \&amp;&amp; grub2-set-default 0</code></pre><p>升级完重启一下系统。</p><p>最后，systemctl start docker</p><p><strong>8.配置docker镜像下载加速器</strong></p><p><strong>方案1</strong>(建议)，用你自己的 阿里云镜像加速器(需要登录)</p><pre><code class="perl">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;&#123;  &quot;registry-mirrors&quot;: [&quot;https://ms9glx6x.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><p><strong>方案1</strong>，执行如下脚本即可<br>curl -sSL <a href="https://get.daocloud.io/daotools/set_mirror.sh">https://get.daocloud.io/daotools/set_mirror.sh</a> | sh -s <a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></p><p>注意！！！</p><p><a href="https://hub.docker.com/">https://hub.docker.com/</a>  #注册，然后，就会有账号密码，里面管理你自己的私有镜像。</p><p>去获取你自己的阿里云镜像站，别用别人的，因为用别人的出现问题也无法处理。</p><h2 id="2-镜像管理"><a href="#2-镜像管理" class="headerlink" title="2. 镜像管理"></a>2. 镜像管理</h2><h3 id="2-1-搜索镜像"><a href="#2-1-搜索镜像" class="headerlink" title="2.1 搜索镜像"></a>2.1 搜索镜像</h3><pre><code class="perl">docker search 镜像名:镜像版本docker search nginx # 默认最新版本 nginx:latest# 要找官方镜像，防止其他镜像有后门</code></pre><h3 id="2-2-下载镜像"><a href="#2-2-下载镜像" class="headerlink" title="2.2 下载镜像"></a>2.2 下载镜像</h3><pre><code class="perl">docker pull 镜像名**注意！**下载官方认证的镜像是最安全的，防止留后门。查询具体的版本号yum install jq -y#这是查询centos容器，如果想查询mysql容器，把centos改成mysql即可curl -s https://registry.hub.docker.com/v1/repositories/centos/tags  |   jq##jq的作用是：让你查看的结果以json格式输出[root@docker-200 ~]#curl -s https://registry.hub.docker.com/v1/repositories/centos/tags  | jq |grep 7.9    &quot;name&quot;: &quot;7.9.2009&quot;    &quot;name&quot;: &quot;centos7.9.2009&quot;    #查询镜像docker images#可以利用关键字查询docker images centos*</code></pre><h3 id="2-3-查看镜像信息"><a href="#2-3-查看镜像信息" class="headerlink" title="2.3 查看镜像信息"></a>2.3 查看镜像信息</h3><pre><code>docker inspect 镜像名:tag</code></pre><p><img src="/../../../images/image-20240605145604545.png" alt="image-20240605145604545"></p><h3 id="2-4-修改镜像名"><a href="#2-4-修改镜像名" class="headerlink" title="2.4 修改镜像名"></a>2.4 修改镜像名</h3><pre><code>docker tag 旧镜像名:旧tag  新镜像名:新tag</code></pre><p><img src="/../../../images/image-20240605142223818.png" alt="image-20240605142223818"></p><h3 id="2-5-删除镜像"><a href="#2-5-删除镜像" class="headerlink" title="2.5 删除镜像"></a>2.5 删除镜像</h3><pre><code class="Perl">docker rmi 镜像名/id#如果有容器使用该镜像，删除失败，除非&quot;docker rmi -f&quot;强制性删除，但谨慎！！！ </code></pre><h3 id="2-6-导出镜像"><a href="#2-6-导出镜像" class="headerlink" title="2.6 导出镜像"></a>2.6 导出镜像</h3><pre><code class="perl">docker save 镜像名/镜像ID &gt;  文件名#默认导出的镜像类型是tar包</code></pre><p><img src="/../../../images/image-20240605141141460.png" alt="image-20240605141141460"></p><h3 id="2-7-导入镜像"><a href="#2-7-导入镜像" class="headerlink" title="2.7 导入镜像"></a>2.7 导入镜像</h3><pre><code class="perl">docker load &lt; 镜像文件# 例如 docker load &lt; ubuntu.tardocker load -i 完整路径文件</code></pre><p><img src="/../../../images/image-20240605141215134.png" alt="image-20240605141215134"></p><h3 id="2-8-容器打包为镜像"><a href="#2-8-容器打包为镜像" class="headerlink" title="2.8 容器打包为镜像"></a>2.8 容器打包为镜像</h3><pre><code>docker commit 容器名/ID 镜像名</code></pre><h3 id="2-9-上传镜像"><a href="#2-9-上传镜像" class="headerlink" title="2.9 上传镜像"></a>2.9 上传镜像</h3><pre><code class="perl">#上传前需要修改tagdocker push  注册docker用户名/REPOSITORY:TAG </code></pre><h3 id="2-10-自制docker镜像"><a href="#2-10-自制docker镜像" class="headerlink" title="2.10 自制docker镜像"></a>2.10 自制docker镜像</h3><pre><code class="perl">#当我们自制镜像的时候，尽量减少无用操作，使得镜像精简化，让镜像体积最小化。例如更新yum源(yum makecache)，因为最后还是得清空缓存(yum clean all),所以直接下载软件，不用生成缓存等操作，降低容器内资源的占用，最终这个容器会被提交为镜像文件，镜像文件是有体积的</code></pre><p><strong>方式一</strong></p><pre><code>1、运行容器2、进入容器，进行安装、配置你所要求3、容器打包称镜像</code></pre><p><img src="/../../../images/image-20240604003421916.png" alt="image-20240604003421916"></p><p><strong>方式二</strong>(推荐)</p><pre><code>1、创建Dockerfile文件2、在dockerfile文件中填写你的需求3、然后利用Dockerfile构建镜像</code></pre><pre><code class="perl"># 使用的基础镜像FROM ubuntu:20.04# 维护者信息LABEL maintainer=&quot;your_email@example.com&quot;# 设置工作目录WORKDIR /app# 复制当前目录下的文件到工作目录COPY . /app# 安装依赖RUN apt-get update &amp;&amp; apt-get install -y python3 python3-pip# 安装 Python 包依赖RUN pip3 install -r requirements.txt# 暴露应用程序的端口EXPOSE 5000# 指定容器启动时运行的命令CMD [&quot;python3&quot;, &quot;app.py&quot;]</code></pre><p><img src="/../../../images/image-20240604003639139.png" alt="image-20240604003639139"></p><pre><code class="perl">docker build -t centos_2 .#解释：-t 可以自定义镜像名  .(点)，表示Dockerfile在当前目录</code></pre><h2 id="3-容器管理"><a href="#3-容器管理" class="headerlink" title="3. 容器管理"></a>3. 容器管理</h2><h3 id="3-1-开启-停止容器"><a href="#3-1-开启-停止容器" class="headerlink" title="3.1 开启&#x2F;停止容器"></a>3.1 开启&#x2F;停止容器</h3><pre><code class="perl">docker run -it ubuntu bash# docker run 的参数# -t 开启一个终端-t, --tty                            Allocate a pseudo-TTY# 标准输入，给容器输入些东西-i, --interactive                    Keep STDIN open even if not attached命令解释：-i，就相当于能够让你在容器内，用键盘输入-t，给你开一个终端进入容器内，就比如ssh开多一个窗口。-p，指定映射端口-P，宿主机随机端口映射容器的指定端口bash，就是让你能够宿主机和容器的bash进行交互，不然就类似于你讲中文，它讲英语，就交互不了。docker run ubuntu 命令 #在运行容器后自动执行命令；例如：docker run ubuntu yum install -y vimdocker stop 容器名/id  #停止容器</code></pre><h3 id="3-2-批量处理容器"><a href="#3-2-批量处理容器" class="headerlink" title="3.2 批量处理容器"></a>3.2 批量处理容器</h3><pre><code class="perl">#写法一docker stop $(docker ps -q) #关掉运行中的所有容器docker rm $(docker ps -qa) #删除已经停止的容器,因为rm 不能删除运行中的容器，rm -f 才可以强制删除。#写法二docker start `docker ps -qa` #开启所有容器docker rm -f `docker ps -qa` #删除所有容器</code></pre><h3 id="3-3-查看容器进程列表"><a href="#3-3-查看容器进程列表" class="headerlink" title="3.3 查看容器进程列表"></a>3.3 查看容器进程列表</h3><pre><code class="perl">docker ps #查看运行中的容器记录docker ps -a #查看所有的容器记录docker ps -qa #查看所有的容器记录，只显示container ID</code></pre><h3 id="3-4-进入容器"><a href="#3-4-进入容器" class="headerlink" title="3.4 进入容器"></a>3.4 进入容器</h3><pre><code class="perl">#进入容器运行bash解释器docker exec -it 容器名/容器ID bash#不进入容器，不开终端，之间在容器内执行xx命令docker exec -it 容器名/容器ID systemctl start nginx</code></pre><p><img src="/../../../images/image-20240605144412395.png" alt="image-20240605144412395"></p><h3 id="3-5-查看容器信息"><a href="#3-5-查看容器信息" class="headerlink" title="3.5 查看容器信息"></a>3.5 查看容器信息</h3><pre><code>docker inspect 容器名/id</code></pre><p><img src="/../../../images/image-20240605145431494.png" alt="image-20240605145431494"></p><h3 id="3-6-拷贝容器数据"><a href="#3-6-拷贝容器数据" class="headerlink" title="3.6 拷贝容器数据"></a>3.6 拷贝容器数据</h3><pre><code>#容器文件拷贝到宿主机docker cp 容器名/ID:完整路径文件名  存放拷贝文件路径#宿主机文件拷贝到容器内docker cp 文件  容器名/ID:存放位置</code></pre><p><img src="/../../../images/image-20240605145244116.png" alt="image-20240605145244116"></p><h3 id="3-7-限制容器资源使用"><a href="#3-7-限制容器资源使用" class="headerlink" title="3.7 限制容器资源使用"></a>3.7 限制容器资源使用</h3><pre><code>docker run  -d  --memory=500M nginx</code></pre><p><img src="/../../../images/image-20240605143058079.png" alt="image-20240605143058079"></p><p><img src="/../../../images/image-20240605143234626.png" alt="image-20240605143234626"></p><h3 id="3-8-容器数据持久化"><a href="#3-8-容器数据持久化" class="headerlink" title="3.8 容器数据持久化"></a>3.8 容器数据持久化</h3><pre><code class="perl">docker run --name nginx -d -v /opt:/opt nginx #容器内的/opt目录下写数据，相当于在宿主机的/opt目录下写数据</code></pre><p><img src="/../../../images/image-20240605143651270.png" alt="image-20240605143651270"></p><h2 id="4-部署私有registry"><a href="#4-部署私有registry" class="headerlink" title="4. 部署私有registry"></a>4. 部署私有registry</h2><pre><code class="perl"># 创建 Docker Registry认证文件目录mkdir /var/lib/registry_auth# 使用htpasswd 来创建加密文件yum install -y httpd-tools# 创建账密htpasswd -Bbn admin admin &gt; /var/lib/registry_auth/htpasswd# 运行registry容器docker run -p 5000:5000 --restart=always --name my-docker-registry \-v /var/lib/registry:/var/lib/registry \-v /var/lib/registry_auth/:/auth/ \-e &quot;REGISTRY_AUTH=htpasswd&quot; \-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \-e &quot;REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd&quot; \-d registry#修改镜像tag，指定上传镜像到哪里docker tag nginx  172.25.250.131:5000/my_nginx:v1# 上传镜像docker push 172.25.250.131:5000/my_nginx:v1#注意docker不允许http仓库，必须走https如果不修改配置文件，会报错Get &quot;https://172.25.250.131:5000/v2/&quot;: http: server gave HTTP response to HTTPS client#添加证书cat /etc/docker/daemon.json &#123;  &quot;registry-mirrors&quot;: [&quot;https://hub.docker.com&quot;,&quot;https://ms9glx6x.mirror.aliyuncs.com&quot;],  &quot;insecure-registries&quot;: [&quot;172.25.250.131:5000&quot;]&#125;#登录账号docker login 172.25.250.131:5000#如果不登录账号是上传不了，会报错&quot;no basic auth credentials&quot;# 上传镜像docker push 172.25.250.131:5000/my_nginx:v1# 下载镜像docker pull 172.25.250.131:5000/my_nginx:v1#查看registry仓库所有镜像访问：http://172.25.250.131:5000/v2/_catalog#查看registry仓库nginx所有版本访问：http://172.25.250.131:5000/v2/my_nginx/tags/list</code></pre><h2 id="5-上传docker-hub公有仓库"><a href="#5-上传docker-hub公有仓库" class="headerlink" title="5. 上传docker hub公有仓库"></a>5. 上传docker hub公有仓库</h2><p>1、Docker hub注册用户：到官网注册账号：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p><img src="/../../../images/image-20240603131036550.png" alt="image-20240603131036550"></p><p>2、在本地宿主机登录docker</p><p><img src="/../../../images/image-20240603131214943.png" alt="image-20240603131214943"></p><p>3、查看镜像</p><p><img src="/../../../images/image-20240603131902110.png" alt="image-20240603131902110"></p><p>4、tag修改镜像名称，使得推送到仓库</p><pre><code class="perl">推送镜像的规范是：docker push  注册docker用户名/REPOSITORY:TAG #注意repository如果没有，会自动创建</code></pre><p><img src="/../../../images/image-20240603133112999.png" alt="image-20240603133112999"></p><p>5、将镜像push到Docker Hub</p><p><img src="/../../../images/image-20240603132952621.png" alt="image-20240603132952621"></p><p><img src="/../../../images/image-20240603133043259.png" alt="image-20240603133043259"></p><p>6、删除本地hello-world镜像</p><p><img src="/../../../images/image-20240603133349737.png" alt="image-20240603133349737"></p><p>7、复制pull命令，从docker Hub仓库下载hello-world镜像到本地</p><p><img src="/../../../images/image-20240603133453919.png" alt="image-20240603133453919"></p><p><img src="/../../../images/image-20240603133624093.png" alt="image-20240603133624093"></p><h2 id="6-portainer可视化管理容器"><a href="#6-portainer可视化管理容器" class="headerlink" title="6. portainer可视化管理容器"></a>6. portainer可视化管理容器</h2><ol><li>下载portainer镜像</li></ol><pre><code>docker pull portainer/portainer</code></pre><ol start="2"><li>运行该portainer容器</li></ol><pre><code class="Perl"> docker run --name portainer -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock  portainer/portainer #-v映射的原因是：portainer是一个容器，因为我们要要portainer可视化管理容器，就是相当于容器内调用宿主机的docker管理，所以必须映射要映射宿主机的docker.sock</code></pre><ol start="3"><li>访问宿主机IP:9000,并注册用户</li></ol><p><img src="/.com//../..%5Cimages%5Cimage-20240605140910016.png" alt="image-20240605140910016"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;部署docker&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1-1手动开启宿主机内核数据包转发功能&quot;&gt;&lt;a href=&quot;#1-1手动开启宿主机内核数据包转发功能&quot; class=&quot;headerlink&quot; title=&quot;1.1手动开启宿主机内核数据包转发功能&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="容器 - Docker" scheme="http://example.com/categories/%E5%AE%B9%E5%99%A8-Docker/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL_Server/SQLServer/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL_Server/SQLServer/</id>
    <published>2024-06-02T07:21:08.375Z</published>
    <updated>2024-06-02T08:29:50.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h1><p>什么是数据库？</p><p>是存放数据的一个仓库；这个仓库不是传统意义上的”存放干粮这种仓库”；数据库就是多张二维表的集合，二维表就是行(值)和列(属性)组成</p><p>当我们注册QQ号时，叫你输入密码，手机号，名字等等，当你填完这些，然后把这些数据存到一个数据库里面，这样下次输入账号密码，你就能够登录QQ。再比如你注销你的QQ号，在数据库的视角中，只是删除它其中一个表的一行数据。</p><p>数据模型是什么？</p><p><strong>是对现实世界中的数据结构和数据关系的一种抽象和表示，用于指导数据库的设计和实现。</strong>通俗地说，数据模型就像是地图，它告诉你如何组织和存储数据，以及这些数据之间的关系</p><p>组成要素：数据结构、数据操作、数据完整性约束</p><p>常见的数据模型：</p><ol><li><p>层次模型</p><p>这种模型将数据组织成树形结构，其中每个节点表示一个记录，而每个记录包含一个或多个字段。父子关系用于表示数据之间的层次关系。</p><p>例如：</p><p>一个学校的组织结构</p><p>校长-副校长-各个院系的院长-各个院系的主任</p></li><li><p>网状模型</p></li></ol><p>   网状模型类似于层次模型，但节点可以有多个父节点，这使得它可以表示更复杂的多对多关系。</p><p>   例如：课程和学生之间</p><p>   数据库课程：A同学、B同学</p><p>   网络课程：B同学、C同学</p><p>   B同学同时注册了数据库课程和网络课程，表示为多个父节点</p><ol start="3"><li><strong>关系模型</strong></li></ol><p>​关系模型使用表来表示数据，其中每个表包含行和列。表之间通过外键建立联系</p><h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><p>学生关系数据模型</p><p><img src="/../../../../images/image-20240602154144639.png" alt="image-20240602154144639"></p><pre><code>1. 关系数据模型简称关系模型;2. 关系数据模型中的核心元素是关系，实体及其联系都用关系来表示3. 关系也就是二维表，一个关系数据库由若干个表组成4. 关系数据模型 由关系数据结构、关系操作集合和关系完整性约束三部分组成。</code></pre><h3 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h3><ol><li><p>数据模型中的数据结构描述数据的静态特性。关系模型的数据结构非常单一，在关系模型中，现实世界中的所有事物（实体）及其联系均用关系来表示。</p></li><li><p>关系，就是我们常用的<strong>二维表</strong>，<strong>关系数据结构就是二维表结构。</strong></p></li></ol><p>就是定义二维表的属性，例如教室表，属性可以有：教工号，姓名，性别等。</p><p><img src="/../../../../images/image-20240602155035431.png" alt="image-20240602155035431"></p><h3 id="关系操作集合"><a href="#关系操作集合" class="headerlink" title="关系操作集合"></a>关系操作集合</h3><p>关系操作：查询和编辑</p><p>查询操作：<strong>选择、投影、连接、并、交、差</strong>等</p><p>编辑类操作：<strong>插入、删除和修改</strong></p><p><strong>操作的对象和结果都是元组（行）的集合</strong></p><p><strong>选择（Selection）</strong></p><p>选择操作用于从表中提取满足特定条件的行。它相当于SQL中的<code>SELECT</code>语句加上<code>WHERE</code>子句。</p><p>从“员工”表中选择所有年龄大于30岁的员工。</p><pre><code class="perl">SELECT * FROM Employees WHERE Age &gt; 30;</code></pre><p><strong>投影（Projection）</strong></p><p>投影操作用于从表中提取特定的列。它相当于SQL中的<code>SELECT</code>语句指定具体的列。</p><p>从“员工”表中选择所有员工的名字和年龄。</p><pre><code>SELECT Name, Age FROM Employees;</code></pre><p><strong>连接（Join）</strong></p><p>连接操作用于将两个表中的行按照某个相关列组合在一起。它相当于SQL中的<code>JOIN</code>操作。</p><p>从“订单”表和“客户”表中获取所有订单及其对应的客户信息</p><pre><code>SELECT Orders.OrderID, Customers.CustomerNameFROM OrdersJOIN Customers ON Orders.CustomerID = Customers.CustomerID;</code></pre><p><strong>并（Union）</strong></p><p>并操作用于将两个表的结果集合并在一起，包含所有不重复的行。它相当于SQL中的<code>UNION</code>操作。</p><p>从“员工_旧”表和“员工_新”表中获取所有员工的名字。</p><pre><code>SELECT Name FROM Employees_OldUNIONSELECT Name FROM Employees_New;</code></pre><p><strong>交（Intersection）</strong></p><p>交操作用于获取两个表中共有的行。它相当于SQL中的<code>INTERSECT</code>操作（一些数据库管理系统如MySQL不直接支持<code>INTERSECT</code>，可以通过<code>JOIN</code>或子查询实现）。</p><p>从“项目A”表和“项目B”表中获取在两个项目中都参与的员工ID。</p><pre><code>SELECT EmployeeID FROM ProjectAINTERSECTSELECT EmployeeID FROM ProjectB;</code></pre><p><strong>差（Difference）</strong></p><p>差操作用于获取在一个表中有但在另一个表中没有的行。它相当于SQL中的<code>EXCEPT</code>操作（一些数据库管理系统如MySQL不直接支持<code>EXCEPT</code>，可以通过<code>LEFT JOIN</code>和<code>WHERE</code>子句实现）。</p><p>从“项目A”表中获取在“项目B”表中没有参与的员工ID。</p><pre><code>SELECT EmployeeID FROM ProjectAWHERE EmployeeID NOT IN (SELECT EmployeeID FROM ProjectB);</code></pre><h3 id="关系完整性约束"><a href="#关系完整性约束" class="headerlink" title="关系完整性约束"></a>关系完整性约束</h3><p><strong>关系的完整性约束</strong>包括<strong>实体完整性</strong>、<strong>参照完整性</strong>和<strong>用户定义的完整性</strong></p><p>​1. <strong>实体完整性</strong>是保证关系中<strong>每个实体的唯一性</strong>必须要满足的约束，在具体的DBMS实现中表现为<strong>表中主键</strong>的设置</p><p>​2. <strong>参照完整性</strong>是保证关系之间的联系正常有效而同样必须要满足的约束，在具体的DBMS中表现为<strong>外键</strong>的设置</p><p>​3.  <strong>用户定义的完整性</strong>是实际的应用领域需要遵循的约束条件，体现了<strong>具体应用的实际约束</strong>，如给定条件的<strong>检查约束</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL-Server&quot;&gt;&lt;a href=&quot;#SQL-Server&quot; class=&quot;headerlink&quot; title=&quot;SQL Server&quot;&gt;&lt;/a&gt;SQL Server&lt;/h1&gt;&lt;p&gt;什么是数据库？&lt;/p&gt;
&lt;p&gt;是存放数据的一个仓库；这个仓库不是传统意义上的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Podman-搭建与使用</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/Blog/Podman-%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/Blog/Podman-%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:49:10.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Podman安装与配置"><a href="#Podman安装与配置" class="headerlink" title="Podman安装与配置"></a>Podman安装与配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="/../../../../images/clip_image002-17172999161452.jpg" alt="img"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>全局的配置文件：</p><p><img src="/../../../../images/clip_image004-17172999161441.jpg" alt="img"></p><p>配置镜像加速器:</p><p><img src="/../../../../images/clip_image006-17172999161453.jpg" alt="img"></p><p>仓库的先后顺序，决定查找优先级</p><p>配置镜像下载Url顺序：</p><p><img src="/../../../../images/clip_image008-17172999161454.jpg" alt="img"></p><p>普通⽤⼾的配置⽂件：</p><p><img src="/../../../../images/clip_image010-17172999161465.jpg" alt="img"></p><h1 id="Podman镜像管理与镜像结构"><a href="#Podman镜像管理与镜像结构" class="headerlink" title="Podman镜像管理与镜像结构"></a>Podman镜像管理与镜像结构</h1><h2 id="Podman镜像管理"><a href="#Podman镜像管理" class="headerlink" title="Podman镜像管理"></a>Podman镜像管理</h2><p>1、列出镜像列表</p><p><img src="/../../../../images/clip_image012-17172999161466.jpg" alt="img"></p><pre><code class="perl">REPOSITORY：镜像的仓库源 TAG：镜像的标签。例如:latest表示最新版本IMAGE ID：镜像的IDCREATED：镜像创建时间SIZE：镜像大小注意：同一仓库源可以有多个TAG</code></pre><p>2、搜索镜像</p><p><img src="/../../../../images/clip_image014-17172999161468.jpg" alt="img"></p><pre><code class="perl">INDEX：索引NAME：镜像仓库名DESCRIPTION：镜像的描述STATRS：表示点赞量或喜欢的意思OFFICAL：是否官方发布AUTOMATED：自动创建</code></pre><p>3、获取镜像</p><p><img src="/../../../../images/clip_image016-17172999161467.jpg" alt="img"></p><p>4、使用tag命令添加镜像标签</p><p><img src="/../../../../images/clip_image018-17172999161469.jpg" alt="img"></p><p>注意：如果利用ID来删除是把镜像删除，而不是删除标签</p><p>5、删除镜像</p><p><img src="/../../../../images/clip_image020-171729991614610.jpg" alt="img"></p><p>6、清理镜像(执行前一定确认清楚！！！)</p><p><img src="/../../../../images/clip_image022-171729991614612.jpg" alt="img"></p><p>作用：清理系统中所有不再被使用的镜像，包括悬挂的镜像。</p><pre><code class="perl">悬挂的镜像，这些是没有与任何容器关联的镜像。当您构建一个新的容器镜像，或者通过拉取一个镜像时，可能会产生悬挂的镜像。这些镜像没有被任何正在运行的容器使用，并且可以被视为不再需要的。未被容器引用的镜像： 这些是没有被当前正在运行的容器引用的镜像。如果一个容器使用了特定版本的镜像，并且该容器已经停止或删除，那么该版本的镜像就不再被使用，可以被清理。</code></pre><p>7、导出镜像</p><p><img src="/../../../../images/clip_image024-171729991614613.jpg" alt="img"></p><p>8、导入镜像</p><p><img src="/../../../../images/clip_image026-171729991614611.jpg" alt="img"></p><p>9、镜像历史</p><p>作用：查看镜像的构建历史信息。可以查看到镜像构建的整个过程</p><p><img src="/../../../../images/clip_image028-171729991614614.jpg" alt="img"></p><h2 id="Podman镜像结构"><a href="#Podman镜像结构" class="headerlink" title="Podman镜像结构"></a>Podman镜像结构</h2><p>提供文件系统，例如一个centos:7的镜像，大小大致200M，但不包含操作系统Linux内核，容器的内涵是宿主机提供的，一起共用一个内核</p><p><img src="/../../../../images/clip_image030-171729991614615.jpg" alt="img"></p><p>流程：</p><pre><code class="perl">1、先下载centos:7的镜像，然后生成容器(A)，然后在容器A执行 mkdir /dir，然后打包为镜像A(e1d…)，然后把容器A删除2、然后利用镜像A创建容器(B),执行 touch /dir/file，然后打包为镜像B(b34…),然后把容器B删除3、然后利用镜像B创建容器(C),执行，CMD”/bin/bash”和提交，然后打包为镜像C(33b…),最后删除容器C</code></pre><p><img src="/../../../../images/clip_image032-171729991614618.jpg" alt="img"></p><p>Podman 镜像构建过程，如上图所示，通过 podman history 可以看到镜像的构建历史信息，新镜像是从base 镜像一层一层叠加生成的。每执行一个任务，就在现有镜像的基础上增加一层。都是在Base镜像基础上逐步叠加。</p><p>3、镜像缓存</p><p>podman会把构建过程中的每一层临时镜像进行缓存。使用Podmanfile文件构建完镜像以后，新镜像时，，可以直接使用之前缓存的镜像层这样能加速镜像的</p><p>构建。</p><p><img src="/../../../../images/clip_image034-171729991614616.jpg" alt="img"></p><p>修改之前的Podmanfile文件，Podmanfile文件里面共三条指令，前两条指令都是用之前构建镜像的缓存，只有第三个指令才重新构建了缓存层。如果希望在构建镜像时不使用缓存，可以在podman build命令中加上–no-cache参数。</p><p>4、    COPY指令和ADD指令用于复制宿主机上的文件到目标镜像中</p><p>COPY只是用于复制，ADD复制和解压</p><p><src>:  要复制的源文件或目录，支持通配符</src></p><p><dest>: 目标路径，即正创建的镜像的文件系统路径，建议使用绝对路径，否则，COPY指令会以WORKDIR为其起始路径。如果路径中如果包含空白字符，建议使用第二种格式用引号引起来，否则会被当成两个文件。</dest></p><p><img src="/../../../../images/clip_image036-171729991614617.jpg" alt="img"></p><p>5、    WORDDIR指令用于指定工作目录，可以指定多个，每个WORKDIR指影响他下面的指令，直到遇到下一个WORKDIR为止。类似与”cd(切换目录)”</p><p>6、    VOLUME指令用于在镜像中创建一个挂载点目录。两种类型：绑定挂载和podman管理的卷，在Podmanfile中只支持Podman管理的卷，也就是说只能指定容器内的路径，不能指定宿主机的路径。</p><p>7、    EXPOSE指令用于指定容器中待暴露的端口，例如，容器提供httpd服务且要对外提供访问，那就需要指定待暴露80端口，，然后在使用此镜像启动容器时搭配-P的参数才能将待暴露的状态转换为真正暴露的状态，转换的同时443也会转换成一个随机端口，跟-p :443一个意思。EXPOSE指令可以次指定多个端口，例如: EXPOSE 11111&#x2F;udp 11112&#x2F;tcp</p><p>9、ENV指令用于为镜像定义所需的环境变量，并可被ENV指令后面的其它指令所调用。调用格式为$variable_name或者$(variable_name)，使用podman run 启动容器的时候加上-e 的参数为variable name赋值，可以覆盖Podmanfile中ENV指令指定的此variable name的值。但是不会影响到Dockerfile中已经引用过此变量的文件名，格式如下</p><p>ENV <key> <value></value></key></p><p>ENV <key> <value>…</value></key></p><p>注意：podman run -e 指定环境变量，如果变量名相同她会覆盖dockerfile的变量</p><p><img src="/../../../../images/clip_image038-171729991614619.jpg" alt="img"></p><p>10、RUN指令运行于Podman build过程中运行的程序，可以是任何命令。RUN指令后所执行的命令必须在FROM指令后的基础镜像中存在才行</p><p>11、CMD指令用于用户指定启动容器的默认要运行的程序，ENTRYPOINT指令类似CMD指令的功能，用于容器指定默认运行程序。podman run命令会覆盖CMD指令，ENTRYPOINT不会被覆盖。</p><p>三种构建镜像：<br> 1、podman commit命令</p><p>2、基于本地模板导入</p><p>3、Podmanfile构建文件</p><h1 id="Podman容器的管理"><a href="#Podman容器的管理" class="headerlink" title="Podman容器的管理"></a>Podman容器的管理</h1><p>1、    创建容器(podman create)</p><p><img src="/../../../../images/clip_image040-171729991614620.jpg" alt="img"></p><pre><code class="perl">-i：让容器的标准输入保持打开-t：分配一个伪终端并绑定到容器的标准输入-d：让容器后台运行podman create -d 适用于需要在后台运行的容器，通常用于服务或长时间运行的应用。podman create -it 适用于需要与容器进行交互的场景，例如手动调试或运行交互式应用程序。</code></pre><p>2、查看容器(podman ps)</p><p><img src="/../../../../images/clip_image042-171729991614721.jpg" alt="img"></p><p>3、启动和关闭容器</p><p><img src="/../../../../images/clip_image044-171729991614722.jpg" alt="img"></p><p>4、创建并启动容器</p><p><img src="/../../../../images/clip_image046-171729991614723.jpg" alt="img"></p><p>加&#x2F;bin&#x2F;bash原因：指定容器内要启动Bash shell，这样就可以使用各种命令等</p><p>5、容器的pause和unpause</p><p><img src="/../../../../images/clip_image048-171729991614725.jpg" alt="img"></p><p>6、    删除所有停止状态的容器(podman container prune)</p><p><img src="/../../../../images/clip_image050-171729991614724.jpg" alt="img"></p><p>7、进入容器</p><pre><code class="perl">在使用-d参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入:(1)podman attach: 不建议大家使用podman attach，因为退出容器终端，会导致容器的停止。(2) podman exec: 推荐大家使用podman exec命令，因为退出容器终端，不会导致容器的停止。podman attach</code></pre><p><img src="/../../../../images/clip_image052.jpg" alt="img"></p><p>podman exec</p><p><img src="/../../../../images/clip_image054.jpg" alt="img"></p><p>8、删除容器</p><p>podman rm 只能删除停止的容器</p><p>podman rm -f 删除停止或运行中的容器(强制删除)</p><p><img src="/../../../../images/clip_image056-171729991614726.jpg" alt="img"></p><p>9、查看容器的日志信息</p><pre><code class="perl">podman logs container_id 或 name-f 动态跟踪容器的日志输出(类似于tail -f)--since 和 –until 限制输出日志的时间范围。指定开始时间和结束时间podman logs -f --since=10m &lt;container_id_or_name&gt;动态跟踪模式输出容器最近10分钟内的日志</code></pre><p>10、导入和导出容器</p><p><img src="/../../../../images/clip_image058-171729991614727.jpg" alt="img"></p><p>11、列出最近创建的容器</p><p>podman ps -n 3 或 podman ps -n -3</p><p>显示最近最近创建的3个容器的简要信息</p><p>12、显示正在运行容器中的进程信息</p><p><img src="/../../../../images/clip_image060.jpg" alt="img"></p><h1 id="Podman端口映射和持久性存储"><a href="#Podman端口映射和持久性存储" class="headerlink" title="Podman端口映射和持久性存储"></a>Podman端口映射和持久性存储</h1><p>1、容器端口映射</p><p>-P：随机端口</p><p>-p：指定端口</p><p><img src="/../../../../images/clip_image062.jpg" alt="img"><img src="/../../../../images/clip_image064.jpg" alt="img"></p><p><img src="/../../../../images/clip_image066-171729991614728.jpg" alt="img"><img src="/../../../../images/clip_image068.jpg" alt="img"></p><p>2、    查看容器日志</p><p><img src="/../../../../images/clip_image070-171729991614729.jpg" alt="img"></p><p>3、查看容器详细信息</p><p>podman inspect container_id or name</p><p>4、宿主机与容器之间的拷贝</p><p><img src="/../../../../images/clip_image072-171729991614730.jpg" alt="img"></p><p>5、持久化存储</p><p>作用：对宿主机与容器的目录或文件的映射，达到持久化存储，防止容器宕机而其重要内容也消失。</p><p>-v: ~&#x2F;nginx&#x2F;www:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html将我们自己创建的 www目录 挂载到容器d的v:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html.</p><p>-v: ~&#x2F;nginx&#x2F;conf&#x2F;nginxconf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf 将我们自己创建的nginx.conf挂载到容器的&#x2F;etc&#x2F;nginx&#x2F;nginx.conf.</p><p>-v: ~&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx 将我们自己创建的logs挂载到容器的&#x2F;var&#x2F;log&#x2F;nginx。</p><p><img src="/../../../../images/clip_image074.jpg" alt="img"></p><p><img src="/../../../../images/clip_image076.jpg" alt="img"><img src="/../../../../images/clip_image078.jpg" alt="img"><img src="/../../../../images/clip_image080-171729991614831.jpg" alt="img"></p><h1 id="Podman容器的开机自启"><a href="#Podman容器的开机自启" class="headerlink" title="Podman容器的开机自启"></a>Podman容器的开机自启</h1><h2 id="root用户下podman容器服务开机自启"><a href="#root用户下podman容器服务开机自启" class="headerlink" title="root用户下podman容器服务开机自启"></a>root用户下podman容器服务开机自启</h2><p>1、切换&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system目录</p><p>2、    将httpd镜像成为web容器，并运行该容器</p><p><img src="/../../../../images/clip_image082-171729991614832.jpg" alt="img"></p><p>3、生成httpd容器的systemd单元文件</p><p><img src="/../../../../images/clip_image084-171729991614933.jpg" alt="img"></p><p>注意：–name要求要和容器的名称或ID相同，不然找不到。</p><p>4、查看单元文件是否正确</p><p><img src="/../../../../images/clip_image086-171729991614934.jpg" alt="img"></p><p>5、重启服务，并设置自启，然后查看状态</p><p><img src="/../../../../images/clip_image088-171729991614937.jpg" alt="img"></p><h2 id="普通用户下podman容器服务开机自启"><a href="#普通用户下podman容器服务开机自启" class="headerlink" title="普通用户下podman容器服务开机自启"></a>普通用户下podman容器服务开机自启</h2><p>1、    切换普通用户不能su -命令，要用ssh</p><p><img src="/../../../../images/clip_image090-171729991614935.jpg" alt="img"></p><p>2、    启动容器my_nginx</p><p><img src="/../../../../images/clip_image092-171729991614936.jpg" alt="img"></p><p>3、在用户家目录下创建递归目录~&#x2F;.config&#x2F;systemd&#x2F;user目录，只能是该目录名，因为普通用户启动服务的时候一定只能是此目录</p><p><img src="/../../../../images/clip_image094-171729991614938.jpg" alt="img"></p><p>4、切换到该目录下，生成systemd管理的服务单元文件 </p><p><img src="/../../../../images/clip_image096.jpg" alt="img"></p><p>5、编辑单元文件container-my_nginx.service</p><p><img src="/../../../../images/clip_image098.jpg" alt="img"></p><p>6、    将my_nginx容器的服务进程container-my_nginx设置下次启动生效</p><p><img src="/../../../../images/clip_image100.jpg" alt="img"></p><p>7、启动逗留(作用：实现普通用户创建的服务可以被systemd管理)</p><p>给 container_user用户启用逗留功能(systemd 可以管理 user service，普通用户可以为自己的服务创建 unit 文件，并使用 systemctl 命令管理这些服务。</p><p>当用户服务类型为非根用户时，通过文本或者图形控制台或使用 ssh 打开第一个会话时，该服务将自动启动。当关闭最后一次会话时，服务将停止。这种行为与系统服务不同，系统服务在系统启动时启动，在系统关闭时停止。)</p><p><img src="/../../../../images/clip_image102.jpg" alt="img"></p><p>loginctl enable-linger username</p><p>这将启用用户 username 的 linger 特性，使得该用户的服务在用户注销后继续运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Podman安装与配置&quot;&gt;&lt;a href=&quot;#Podman安装与配置&quot; class=&quot;headerlink&quot; title=&quot;Podman安装与配置&quot;&gt;&lt;/a&gt;Podman安装与配置&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Ansible-搭建与使用</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/Blog/Ansible-%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/Blog/Ansible-%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T06:46:33.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="部署ansible"><a href="#部署ansible" class="headerlink" title="部署ansible"></a>部署ansible</h1><h2 id="2-1构建ansible清单"><a href="#2-1构建ansible清单" class="headerlink" title="2.1构建ansible清单"></a>2.1构建ansible清单</h2><p>主机清单：&#x2F;etc&#x2F;ansible&#x2F;hosts 系统的默认静态清单文件，通常不使用该文件</p><p><img src="/../../../../images/clip_image002-17173099547301.jpg" alt="img"></p><p>注意：</p><p>ungrouped主机组含有清单中明确列出，但不属于任何 其他组的每一个主机</p><p>all主机组含有清单中明确列出的每一个主机</p><p>localhost不在清单文件中，但仍然生效，是自带的</p><p>验证清单：</p><p>ansible 172.16.16.250 –list-hosts 验证172.16.16.250是否在主机清单中</p><h2 id="2-2管理ansible配置文件"><a href="#2-2管理ansible配置文件" class="headerlink" title="2.2管理ansible配置文件"></a>2.2管理ansible配置文件</h2><p>配置文件位置（优先级:从上到下优先级越高）：</p><p>1、&#x2F;etc&#x2F;ansible&#x2F;ansible.cfg</p><p>2、~&#x2F;.ansible.cfg</p><p>3、.&#x2F;ansible.cfg</p><p>~&#x2F;.ansible.cfg和.&#x2F;ansible.cfg，如果该两个文件不存在，默认使用&#x2F;etc&#x2F;ansible&#x2F;ansible.cfg</p><p><img src="/../../../../images/clip_image004-17173099547315.jpg" alt="img"></p><p>典型ansible.cfg文件：</p><p>[defaults]</p><p>inventory &#x3D; .&#x2F;inventory #指定清单</p><p>remote_user &#x3D; user­_01</p><p>ask_pass &#x3D; false</p><p>[privilege_escalation]</p><p>become &#x3D; true</p><p>become_method &#x3D; sudo</p><p>become_user &#x3D; root</p><p>become_askpass &#x3D; false</p><p><img src="/../../../../images/clip_image006-17173099547312.jpg" alt="img"></p><p>remote_user &#x3D; user­_01,通过ansible登录其他主机时，是用user_01登录，受管主机必须要有user_01这个用户</p><p>受管主机条件：</p><p>1、    受管主机必须要有user_01这个用户</p><p>2、    确保该用户sudo免密</p><p>3、    确保ssh免密(生成ssh-keygen,再上传ssh-copy-id等等)</p><h2 id="2-3使用临时命令-完整流程"><a href="#2-3使用临时命令-完整流程" class="headerlink" title="2.3使用临时命令(完整流程)"></a>2.3使用临时命令(完整流程)</h2><p>普通用户(student)</p><p>1、 创建ansible的工作目录</p><p>mkdir -p &#x2F;home&#x2F;student&#x2F;ansible</p><p>2、 生成配置文件</p><p><img src="/../../../../images/clip_image008-17173099547313.jpg" alt="img"></p><p>cd &#x2F;home&#x2F;student&#x2F;ansible</p><p>ansible-config init –disabled &gt; ansible.cfg #可以手动创建</p><p><img src="/../../../../images/clip_image010-17173099547314.jpg" alt="img"></p><p>3、 创建主机清单</p><p><img src="/../../../../images/clip_image012-17173099547316.jpg" alt="img"></p><p>4、 执行临时命令</p><p><img src="/../../../../images/clip_image014-17173099547318.jpg" alt="img"></p><p>5、 排错</p><p>尝试 ssh登录远程主机</p><p><img src="/../../../../images/clip_image016-17173099547317.jpg" alt="img"></p><p>发现要输入密码，则需要做免密操作</p><p>\1.  生成密钥</p><p><img src="/../../../../images/clip_image018-17173099547319.jpg" alt="img"></p><p>\2.  上传公钥</p><p><img src="/../../../../images/clip_image020-171730995473110.jpg" alt="img"></p><p>6、 再次执行临时命令</p><p><img src="/../../../../images/clip_image022-171730995473111.jpg" alt="img"></p><p>发现远程主机的用户，没有提权操作没有做好。</p><p><img src="/../../../../images/clip_image024-171730995473112.jpg" alt="img"></p><p>7、 再次执行临时操作</p><p><img src="/../../../../images/clip_image026-171730995473113.jpg" alt="img"></p><p>注意：如果一直报错，尝试ssh登录，发现一直要密码，上传公钥也没有时，有可能是当时生成密钥带有密码保护。</p><p><img src="/../../../../images/clip_image028-171730995473114.jpg" alt="img"></p><p>1、    首先把密钥文件都删除</p><p>rm -f ~&#x2F;.ssh&#x2F;*</p><p>2、    生成密钥</p><p>ssh-keygen -t rsa</p><p>3、    先把远程的~&#x2F;.ssh&#x2F;authorized_keys删除,再上传公钥</p><p>rm -f ~&#x2F;.ssh&#x2F;authorized_keys #受管主机</p><p>ssh-copy-id student@IP&#x2F;域名 #控制节点</p><p>-————————————————————–</p><p>提权操作</p><p><img src="/../../../../images/clip_image030-171730995473115.jpg" alt="img"></p><p>因为提权（become_user）</p><p><img src="/../../../../images/clip_image032-171730995473116.jpg" alt="img"></p><p>为什么同样的操作，而颜色为什么不同？</p><p><img src="/../../../../images/clip_image034-171730995473117.jpg" alt="img"></p><p>因为幂等性，先会检查文件，servera没有做任何改动(她的该目录已经有123.txt的文件且里面的内容是ansible123456)，其他主机则改动了(CHANGED)</p><p>Playbook的格式转译为临时命令</p><p>查看file模板的详细信息(ansible-doc file)</p><p><img src="/../../../../images/clip_image036-171730995473118.jpg" alt="img"></p><p>- name: Recursively remove directory</p><p> ansible.builtin.file:</p><p> path: &#x2F;etc&#x2F;foo</p><p> state: absent #消失</p><p>转译为临时命令</p><p>ansible servera -m file -a “path&#x3D;&#x2F;home&#x2F;student&#x2F;test.txt state &#x3D; absent”</p><p><img src="/../../../../images/clip_image038-171730995473119.jpg" alt="img"></p><p>append(附加选项):yes表示确保用户添加到指定的用户组中，不会影响原有的组的成员身份</p><p>转译为临时命令</p><p>ansible severa -m user -a “name&#x3D;user_01 shell&#x3D;&#x2F;bin&#x2F;bash groups&#x3D;root append&#x3D;yes</p><p>假设user_01存在，且GID为1001,现在groups&#x3D;root，则会添加附加组</p><p>command模块和shell模块的区别：</p><p>shell模块能够访问受控主机的环境变量,支持管道,通配符,重定向等</p><p>command模块不能够访问受控主机的环境变量</p><p>命令行参数</p><p><img src="/../../../../images/clip_image040-171730995473120.jpg" alt="img"></p><p>这些参数作用：不使用ansible.cfg里的配置，只是临时测试用，本次任务生效</p><p>例如：</p><p><img src="/../../../../images/clip_image042-171730995473121.jpg" alt="img"></p><h1 id="实施playbook"><a href="#实施playbook" class="headerlink" title="实施playbook"></a>实施playbook</h1><h2 id="3-1编写和运行playbook"><a href="#3-1编写和运行playbook" class="headerlink" title="3.1编写和运行playbook"></a>3.1编写和运行playbook</h2><p>playbook格式：</p><p>—开头</p><p>- name: 这个第1个play的名字</p><p>hosts: all 这个play执行的对象是谁</p><p> tasks: 定义任务</p><p>​    - name: 任务1的名字</p><p>​     user: 任务1的模块</p><p>​       name:模块里的参数</p><p>​       uid: 模块里的参数</p><p>​       state:模块里的参数</p><p>​    -name: 任务2的名字</p><p>​     file: 任务1的模块</p><p>​       name: 模块里的参数</p><p>​       uid: 模块里的参数</p><p>​       state: 模块里的参数</p><p>­­­­­­playbook缩进量建议要求</p><p>play是要顶格</p><p>一个play里，可以定义多个任务</p><p>每个级别之间使用相同的空格数。</p><p>比如一级目录，顶格，比如play的名字</p><p>二级目录，2个空格，比如hosts，tasks</p><p>三级目录，人物的名字，再加2个空格</p><p>四级目录，比如 模块的名字，file，2个空格</p><p>五级目录，模块里的参数，比如 state，2个空格</p><p>设置vi文本编辑器, 在$HOME&#x2F;.vimrc文件中添加下面这行后，如果vim&#x2F;vi检测到编辑YAML文件，它将在Tab键按下时执行一个双空格缩进，并自动缩进后续行</p><p>autocmd FileType yaml setlocal ai ts&#x3D;2 sw&#x3D;2 et</p><p>语法检验：–syntax-checl，只会检测语法、关键字是否正确，缩进量是否正确，但对其值对与否并不会检测出来。</p><p>执行空运行：对playbook执行空运行时对远程主机没有做任何改变。</p><p><img src="/../../../../images/clip_image044-171730995473123.jpg" alt="img"></p><p>注意：有些-c选项也检测不出，需要真正执行一次才知道，例如：磁盘空间问题</p><h2 id="3-2实施多个play"><a href="#3-2实施多个play" class="headerlink" title="3.2实施多个play"></a>3.2实施多个play</h2><p><img src="/../../../../images/clip_image046-171730995473124.jpg" alt="img"></p><p>可以指定在某个play单独指定用户执行</p><p>在play中，添加：remote_user: user_01</p><p>提权也是一样操作, become_user: root，提权到root</p><p>前提条件：</p><p>1、受管主机必须要有user_01这个用户</p><p>2、确保该用户sudo免密</p><p>3、确保ssh免密(生成ssh-keygen,再上传ssh-copy-id等等)</p><p>安装多个软件(启动服务也类似)</p><p><img src="/../../../../images/clip_image048-171730995473122.jpg" alt="img"></p><p>关于ansible-doc的描述</p><p>ansible-doc win-environment</p><p><img src="/../../../../images/clip_image050-171730995473125.jpg" alt="img"></p><p>status字段记录模块的开发状态：</p><p><img src="/../../../../images/clip_image052-171730995473126.jpg" alt="img"></p><p>supported_by字段记录上游Ansible社区中维护模块的人.可能的值包括：</p><p><img src="/../../../../images/clip_image054-171730995473127.jpg" alt="img"></p><p>幂等性和非幂等性</p><p><img src="/../../../../images/clip_image056-171730995473128.jpg" alt="img"> <img src="/../../../../images/clip_image058-171730995473129.jpg" alt="img"></p><p>yml文件字符串：</p><p>竖线(|)：保留字符串为多行</p><p><img src="/../../../../images/clip_image060-171730995473130.jpg" alt="img"></p><p>大于号(&gt;)：换行字符转换成空格合成一行，在一行输出</p><p><img src="/../../../../images/clip_image062-171730995473131.jpg" alt="img"></p><p>YAML字典</p><p><img src="/../../../../images/clip_image064-171730995473132.jpg" alt="img"></p><p>YAML列表</p><p><img src="/../../../../images/clip_image066-171730995473133.jpg" alt="img"></p><h1 id="编写playbook使用变量"><a href="#编写playbook使用变量" class="headerlink" title="编写playbook使用变量"></a>编写playbook使用变量</h1><h2 id="管理变量"><a href="#管理变量" class="headerlink" title="管理变量"></a>管理变量</h2><p>变量的命名规则</p><p>变量的名字只能包含_、字⺟、数字，且变量名的⾸位不能是数字。</p><p><img src="/../../../../images/clip_image068-171730995473134.jpg" alt="img"></p><p>定义变量(建议选择全局唯⼀的变量名称)</p><p>Ansible 中，可在多个位置定义变量，但不同位置具有不同的优先级 下表显⽰了定义变量的⽅法，按优先级从低到⾼排列:</p><p>在清单中定义的组变量 </p><p>在清单或 playbook 所在⽬录的 group_vars ⼦⽬录中定义的组变量</p><p>在清单中定义的主机变量 </p><p>在清单或 playbook 所在⽬录的 host_vars ⼦⽬录中定义的主机变量</p><p>在运⾏时中发现的主机事实</p><p>playbook 中的 play 变量（vars 和 vars_files） </p><p>任务变量 </p><p>在命令⾏中定义的额外变量，使⽤ –extra-vars 或 -e 选项定义</p><h3 id="在主机清单中定义变量"><a href="#在主机清单中定义变量" class="headerlink" title="在主机清单中定义变量"></a>在主机清单中定义变量</h3><p>主机变量（它的⽣效范围只是指定的主机），组变量（只会对该组的主机⽣效）。</p><p><img src="/../../../../images/clip_image070-171730995473135.jpg" alt="img"></p><p>#在主机清单里面定义主机变量</p><p><img src="/../../../../images/clip_image072-171730995473238.jpg" alt="img"></p><p>#在主机清单里面定义主机组变量</p><p><img src="/../../../../images/clip_image074-171730995473237.jpg" alt="img"></p><h3 id="在playbook⾥⾯定义变量"><a href="#在playbook⾥⾯定义变量" class="headerlink" title="在playbook⾥⾯定义变量"></a>在playbook⾥⾯定义变量</h3><p>#在playbook里面通过关键字vars定义play的变量</p><p><img src="/../../../../images/clip_image076-171730995473136.jpg" alt="img"></p><p>#在playbook里面引入外部的变量文件内定义的变量(必须是YAML文件)</p><p><img src="/../../../../images/clip_image078-171730995473239.jpg" alt="img"></p><h3 id="创建host-vars-主机变量-和group-vars（主机组变量）"><a href="#创建host-vars-主机变量-和group-vars（主机组变量）" class="headerlink" title="创建host_vars(主机变量)和group_vars（主机组变量）"></a>创建host_vars(主机变量)和group_vars（主机组变量）</h3><p>在 host_vars 目录中为每个主机创建一个 YAML 文件，文件名与主机名匹配。</p><p><img src="/../../../../images/clip_image080-171730995473240.jpg" alt="img"></p><p>在 group_vars 目录中为每个主机组创建一个 YAML 文件，文件名与主机组名匹配。</p><p><img src="/../../../../images/clip_image082-171730995473241.jpg" alt="img"></p><h3 id="在命令⾏传⼊变量"><a href="#在命令⾏传⼊变量" class="headerlink" title="在命令⾏传⼊变量"></a>在命令⾏传⼊变量</h3><p><img src="/../../../../images/clip_image084-171730995473242.jpg" alt="img"></p><h3 id="注册变量"><a href="#注册变量" class="headerlink" title="注册变量"></a>注册变量</h3><p>它的作⽤是将上⼀个模块执⾏的结果，收集到⼀个⾃定变量⾥，可以使⽤这个变量做下⼀个任务的条件判断</p><p>测试剧本</p><p><img src="/../../../../images/clip_image086-171730995473243.jpg" alt="img"></p><p>通过register关键字，定义了一个注册变量users收 集user模块执行的结果，这个关键字要与模块名的缩进相同。</p><p>输出结果</p><p><img src="/../../../../images/clip_image088-171730995473244.jpg" alt="img"></p><h3 id="字典用作变量"><a href="#字典用作变量" class="headerlink" title="字典用作变量"></a>字典用作变量</h3><p>#变量的文件</p><p><img src="/../../../../images/clip_image090-171730995473246.jpg" alt="img"></p><p>#测试剧本，写法一</p><p><img src="/../../../../images/clip_image092-171730995473245.jpg" alt="img"></p><p>#写法二</p><p><img src="/../../../../images/clip_image094-171730995473247.jpg" alt="img"></p><p>debug模块的msg参数和var参数的区别</p><p>msg参数: </p><p>msg 参数用于输出一条静态的文本消息。</p><p>通常用于输出一些简单的信息或者调试消息，不涉及变量的使用</p><p><img src="/../../../../images/clip_image096-171730995473248.jpg" alt="img"></p><p>var参数:</p><p>vars 参数用于输出变量的值。</p><p>通常用于输出某个变量的值，以便在调试时检查变量的内容。</p><p><img src="/../../../../images/clip_image098-171730995473249.jpg" alt="img"></p><p>msg也可以输出变量的值，但是需要和var结合使用</p><p><img src="/../../../../images/clip_image100-171730995473250.jpg" alt="img"></p><h3 id="读取变量的值"><a href="#读取变量的值" class="headerlink" title="读取变量的值"></a>读取变量的值</h3><p>#使用”“格式读取变量的值</p><p><img src="/../../../../images/clip_image102-171730995473251.jpg" alt="img"></p><h2 id="管理事实（facts）"><a href="#管理事实（facts）" class="headerlink" title="管理事实（facts）"></a>管理事实（facts）</h2><h3 id="ansible-的-facts"><a href="#ansible-的-facts" class="headerlink" title="ansible 的 facts"></a>ansible 的 facts</h3><p>Ansible 事实是 Ansible 从受管主机⾃动探查到的变量 </p><p>事实由 ansible.builtin.setup 模块调取，其中包含的信息存储到可重复使⽤的变量中</p><p>甚⾄可以创建⾃定义事实，这些事实存储在受管主机上并且对于该系统来说是唯⼀的</p><p>Ansible 事实可以成为 playbook 的⼀部分。例如： </p><p>可以根据当前内核版本来重新启动服务器 </p><p>可以根据可⽤的内存来⾃定义 MySQL 配置⽂件 </p><p>可以根据主机名称来创建⽤⼾ </p><p>对Ansible 事实的利⽤⼏乎不存在任何限制借助 </p><p>Ansible 事实,可以⽅便地检索受管节点的状态,并根据其状态决定要执⾏的操作 </p><p>事实提供如下相关的信息：主机名称、内核版本、⽹络接⼝、IP 地址、操作系统版本、 各种环境变量、CPU 数量、提供的或可⽤的内存、可⽤磁盘空间</p><p>输出以 JSON 格式返回，每个值存储在⼀个 Python 字典中。管理员⽽后可以浏览字典来检索特定的值 </p><p>通常每个 play 的第⼀个 task 运⾏前都会⾃动运⾏ setup 模块，以收集事实（在 play 中 不需要特地写 setup task）</p><p>下表显⽰了从受管节点收集的、可以在 playbook 中使⽤的⼀些事实：</p><p><img src="/../../../../images/clip_image104.jpg" alt="img"></p><p>收集受管主机相关事实(只需要记住关键字，就能模糊搜索事实)</p><p><img src="/../../../../images/clip_image106.png" alt="img"></p><p>方法一</p><p><img src="/../../../../images/clip_image108.jpg" alt="img"></p><p>方法二</p><p><img src="/../../../../images/clip_image110-171730995473252.jpg" alt="img"></p><p>#fqdn相关的事实</p><p><img src="/../../../../images/clip_image112.png" alt="img"></p><p>#磁盘相关的事实</p><p>[student@workstation ansible]$ ansible group1 -m setup -a ‘filter&#x3D;<em>device</em>‘ servera | SUCCESS &#x3D;&gt; { </p><p>“ansible_facts”: { </p><p>[student@workstation ansible]$ cat fact.yml </p><p>-– </p><p>- name: test fact variables </p><p>hosts: group1 </p><p>tasks: </p><p>- name: test fact variables </p><p>ansible.builtin.debug: </p><p>msg: ““</p><p><img src="/../../../../images/clip_image114.png" alt="img"></p><p>#bios版本相关的事实变量名</p><p><img src="/../../../../images/clip_image116-171730995473253.jpg" alt="img"></p><h3 id="关闭事实收集"><a href="#关闭事实收集" class="headerlink" title="关闭事实收集"></a>关闭事实收集</h3><p>为了加快 playbook 的运⾏速度，或受控节点不⽀持 setup 模块，可将事实收集功能关闭</p><p><img src="/../../../../images/clip_image118-171730995473254.jpg" alt="img"></p><h3 id="创建自定义事实"><a href="#创建自定义事实" class="headerlink" title="创建自定义事实"></a>创建自定义事实</h3><p>管理员可以⾃⾏创建事实，将它们推送到受管节点</p><p>创建后，⾃定义事实将由 ansible.builtin.setup 模块集成和读取 </p><p>⾃定义事实可⽤于 </p><p>基于⾃定义脚本定义系统的特定值 </p><p>基于程序执⾏定义值 </p><p>如果⾃定义事实⽂件保存在 &#x2F;etc&#x2F;ansible&#x2F;facts.d ⽬录中，Ansible 可以找到该事实 </p><p>⽂件的扩展名必须为 .fact，采⽤ INI 或 JSON 格式的纯⽂本⽂件 </p><p>在 INI 事实⽂件中，⾸先是定义事实的顶级分类例如：[packages]，后跟欲定义事实的键 值对：</p><p><img src="/../../../../images/clip_image120-171730995473255.jpg" alt="img"></p><p>如果以 JSON 格式提供，则需要使⽤下列语法:</p><p><img src="/../../../../images/clip_image122-171730995473256.jpg" alt="img"></p><p>#自定义事实变量</p><p><img src="/../../../../images/clip_image124.jpg" alt="img"></p><p>#读取本机自定义事实变量（变量：ansible_local）</p><p><img src="/../../../../images/clip_image126.jpg" alt="img"></p><p>#读取远程主机自定义事实变量</p><p>ansible_local是特殊的ansible变量，用于存储主机上的自定义事实信息</p><p>hostvars变量允许你访问远程主机的变量信息，包括 自定义信息</p><h3 id="Magic-Variables-魔法变量"><a href="#Magic-Variables-魔法变量" class="headerlink" title="Magic Variables 魔法变量"></a>Magic Variables 魔法变量</h3><p>⼀些变量并⾮是 ansible.buildin.setup 模块采集的事实或配置信息，但是很有⽤，仍可 以被ansible 使⽤，成为 magic variables</p><p>有 4 种常⽤类型</p><p>hostvars：列出受管主机的⾮事实变量</p><p>group_names：列出受管主机所属的所有组</p><p>groups：列出所有 inventory 中的 groups 和 hosts</p><p>inventory_hostname：列出当前受管主机在 inventory 中定义的主机名，可能和 事实变量不同</p><p>hostvars</p><p><img src="/../../../../images/clip_image128.jpg" alt="img"></p><p>group_names</p><p><img src="/../../../../images/clip_image130.jpg" alt="img"></p><p>groups</p><p><img src="/../../../../images/clip_image132.jpg" alt="img"></p><p>inventory_hostname</p><p><img src="/../../../../images/clip_image134-171730995473257.jpg" alt="img"></p><h2 id="管理秘密"><a href="#管理秘密" class="headerlink" title="管理秘密"></a>管理秘密</h2><h3 id="管理秘密-1"><a href="#管理秘密-1" class="headerlink" title="管理秘密"></a>管理秘密</h3><p>Ansible Vault</p><p><img src="/../../../../images/clip_image136.jpg" alt="img"></p><h3 id="创建加密的文件"><a href="#创建加密的文件" class="headerlink" title="创建加密的文件"></a>创建加密的文件</h3><p><img src="/../../../../images/clip_image138.jpg" alt="img"></p><p>#交互式的创建加密文件</p><p><img src="/../../../../images/clip_image140.jpg" alt="img"></p><p>#非交互式的方式：</p><p><img src="/../../../../images/clip_image142.jpg" alt="img"></p><p>查看加密的⽂件</p><p>Ansible Vault 使⽤ ansible-vault view filename 命令查看加密的⽂件，⽽不必打开它进⾏编辑</p><p><img src="/../../../../images/clip_image144.jpg" alt="img"></p><p>编辑现有的加密⽂件</p><p>要编辑现有的加密⽂件，Ansible Vault 提供了 ansible-vault edit filename 命令</p><p>此命令将⽂件解密为⼀个临时⽂件，并允许⽤⼾编辑该⽂件。保存时，它将复制其内容并 删除临时⽂件</p><p>注意：edit ⼦命令会改写⽂件，因此仅可在进⾏更改时使⽤它。若要查看⽂件的内容⽽不进⾏更改，始终应使⽤ view ⼦命令</p><p><img src="/../../../../images/clip_image146.jpg" alt="img"></p><h3 id="加密现有的⽂件"><a href="#加密现有的⽂件" class="headerlink" title="加密现有的⽂件"></a>加密现有的⽂件</h3><p>要加密已存在的⽂件，使⽤ ansible-vault encrypt filename 命令。此命令可取多个欲加 密⽂件的名称作为参数</p><p>使⽤ –output&#x3D;OUTPUT_FILE 选项，可将加密⽂件保存为新的名称。最多只能将⼀个输⼊⽂件⽤于 –output 选项</p><p><img src="/../../../../images/clip_image148.jpg" alt="img"></p><h3 id="解密现有的⽂件"><a href="#解密现有的⽂件" class="headerlink" title="解密现有的⽂件"></a>解密现有的⽂件</h3><p>已存在的加密⽂件可以通过 ansible-vault decrypt filename 命令永久解密</p><p>在解密单个⽂件时，可使⽤ –output 选项以其他名称保存解密的⽂件</p><p><img src="/../../../../images/clip_image150.jpg" alt="img"></p><p><img src="/../../../../images/clip_image152.jpg" alt="img"></p><h3 id="更改加密⽂件的密码"><a href="#更改加密⽂件的密码" class="headerlink" title="更改加密⽂件的密码"></a>更改加密⽂件的密码</h3><p>可以使⽤命令 ansible-vault rekey filename 更改 vault 密码</p><p>此命令可⼀次性更新多个数据⽂件的密钥。它将要求提供原始密码和新密码</p><p>在使⽤ vault 密码⽂件时，使⽤ –new-vault-password-file 选项</p><p><img src="/../../../../images/clip_image154.jpg" alt="img"></p><h3 id="Playbook-和-Ansible-Vault"><a href="#Playbook-和-Ansible-Vault" class="headerlink" title="Playbook 和 Ansible Vault"></a>Playbook 和 Ansible Vault</h3><p>为了运⾏可访问通过 Ansible Vault 加密的⽂件的 playbook，需要向 ansible-playbook 命令提供其加密密码。如果运⾏命令时没有这么做，它将返回错误</p><p><img src="/../../../../images/clip_image156.jpg" alt="img"></p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="使⽤-loop-构建循环"><a href="#使⽤-loop-构建循环" class="headerlink" title="使⽤ loop 构建循环"></a>使⽤ loop 构建循环</h2><p>循环使管理员不必编写相同的多个任务</p><p>Ansible ⽀持使⽤ loop 关键字在⼀组项上迭代任务</p><p>#打印数字1 2 3 4</p><p><img src="/../../../../images/clip_image158.jpg" alt="img"></p><h3 id="循环字典列表"><a href="#循环字典列表" class="headerlink" title="循环字典列表"></a>循环字典列表</h3><p>循环列表不⼀定是简单值列表</p><p>loop 遍历数字列表，而 item 则代表每次迭代中的当前值</p><p><img src="/../../../../images/clip_image160.jpg" alt="img"> </p><p>结果</p><p><img src="/../../../../images/clip_image162.jpg" alt="img"></p><h3 id="在循环中使⽤-register-变量"><a href="#在循环中使⽤-register-变量" class="headerlink" title="在循环中使⽤ register 变量"></a>在循环中使⽤ register 变量</h3><p>可将 register 关键字⽤于输出循环的结果</p><p><img src="/../../../../images/clip_image164.jpg" alt="img"></p><h2 id="有条件地运⾏任务"><a href="#有条件地运⾏任务" class="headerlink" title="有条件地运⾏任务"></a>有条件地运⾏任务</h2><p><img src="/../../../../images/clip_image166.jpg" alt="img"></p><p>条件任务语法</p><p><img src="/../../../../images/clip_image168.jpg" alt="img"></p><p>下表显⽰⼀些条件判断运算符</p><p><img src="/../../../../images/clip_image170.jpg" alt="img"></p><p>注意：⽤于测试条件中相等的 &#x3D;&#x3D; 运算符不可与变量赋值的 &#x3D; 运算符混淆</p><p>注意：when 表达式不属于模块，必须放在模块外部</p><p><img src="/../../../../images/clip_image172.jpg" alt="img"></p><p><img src="/../../../../images/clip_image174.jpg" alt="img"></p><p><img src="/../../../../images/clip_image176.jpg" alt="img"></p><h2 id="实施-Handler-任务"><a href="#实施-Handler-任务" class="headerlink" title="实施 Handler 任务"></a>实施 Handler 任务</h2><p>Ansible 的 handlers 程序</p><p><img src="/../../../../images/clip_image178.jpg" alt="img"></p><p>使⽤ handler 程序的注意事项</p><p><img src="/../../../../images/clip_image180.jpg" alt="img"></p><p>注意：handler 程序设计为仅在任务执⾏时处理操作，它们不应当⽤于取代任务</p><p>#两次notify只会执行一次handler</p><p><img src="/../../../../images/clip_image182.jpg" alt="img"></p><p>一个任务在其notify部分中调用多个处理程序</p><p><img src="/../../../../images/clip_image184.png" alt="img"></p><h2 id="处理任务错误"><a href="#处理任务错误" class="headerlink" title="处理任务错误"></a>处理任务错误</h2><p>管理 play 中的任务错误</p><p><img src="/../../../../images/clip_image186.jpg" alt="img"></p><p>忽略失败的任务 Ignore the failed task</p><p><img src="/../../../../images/clip_image188.jpg" alt="img"></p><p>Playbook</p><p><img src="/../../../../images/clip_image190.jpg" alt="img"></p><p>执行结果</p><p><img src="/../../../../images/clip_image192.jpg" alt="img"></p><h2 id="强制执⾏处理程序-Force-execution-of-handlers"><a href="#强制执⾏处理程序-Force-execution-of-handlers" class="headerlink" title="强制执⾏处理程序 Force execution of handlers"></a>强制执⾏处理程序 Force execution of handlers</h2><p><img src="/../../../../images/clip_image194.jpg" alt="img"></p><p><img src="/../../../../images/clip_image196.jpg" alt="img"></p><p><img src="/../../../../images/clip_image198.jpg" alt="img"></p><h2 id="覆盖-failed-状态"><a href="#覆盖-failed-状态" class="headerlink" title="覆盖 failed 状态"></a>覆盖 failed 状态</h2><p><img src="/../../../../images/clip_image200.jpg" alt="img"></p><p>标准输出 (stdout): 这是命令正常执行时产生的输出。比如，你运行 ls 命令列出文件，输出的文件列表就是标准输出。</p><p>标准错误 (stderr): 如果命令执行出现了问题，错误消息通常会被发送到标准错误。例如，如果你运行 ls xxx，其中的 “xxx” 文件夹不存在，错误消息会被发送到标准错误流中</p><p>faild_when，能够指定错误，强制任务失败</p><p>原始</p><p><img src="/../../../../images/clip_image202.jpg" alt="img"></p><p>加上faild_when语句</p><p><img src="/../../../../images/clip_image204.jpg" alt="img"></p><p>fail语句</p><p><img src="/../../../../images/clip_image206.jpg" alt="img"></p><h2 id="覆盖-changed-状态"><a href="#覆盖-changed-状态" class="headerlink" title="覆盖 changed 状态"></a>覆盖 changed 状态</h2><p><img src="/../../../../images/clip_image208.jpg" alt="img"></p><p>原始结果</p><p><img src="/../../../../images/clip_image210.jpg" alt="img"></p><p>添加changed_when关键字</p><p><img src="/../../../../images/clip_image212.jpg" alt="img"></p><h2 id="Ansible-blocks-和错误处理"><a href="#Ansible-blocks-和错误处理" class="headerlink" title="Ansible blocks 和错误处理"></a>Ansible blocks 和错误处理</h2><p><img src="/../../../../images/clip_image214.jpg" alt="img"></p><p><img src="/../../../../images/clip_image216.jpg" alt="img"></p><h1 id="管理主机上的⽂件"><a href="#管理主机上的⽂件" class="headerlink" title="管理主机上的⽂件"></a>管理主机上的⽂件</h1><h2 id="描述-files-模块"><a href="#描述-files-模块" class="headerlink" title="描述 files 模块"></a>描述 files 模块</h2><p><img src="/../../../../images/clip_image218.jpg" alt="img"></p><h3 id="file模块："><a href="#file模块：" class="headerlink" title="file模块："></a>file模块：</h3><p>创建⽂件，⽬录，链接，它还可以设置⽂件的selinux,权限属性</p><p>#创建一个文件</p><p><img src="/../../../../images/clip_image220.jpg" alt="img"></p><p>#创建一个目录</p><p><img src="/../../../../images/clip_image222.jpg" alt="img"></p><h3 id="copy模块："><a href="#copy模块：" class="headerlink" title="copy模块："></a>copy模块：</h3><p>⽤来将本地的⽂件拷⻉到远程主机上，和往⽬标⽂件⾥⾯写⼊指定内容，他会在写⼊内容的时候，⽬标⽂件不存在，会创建⽂件覆盖写⼊内容</p><p>#拷贝本地文件到远程主机</p><p><img src="/../../../../images/clip_image224.jpg" alt="img"></p><p>#拷贝内容到文件内部</p><p><img src="/../../../../images/clip_image226.jpg" alt="img"></p><h3 id="fetch模块："><a href="#fetch模块：" class="headerlink" title="fetch模块："></a>fetch模块：</h3><p>拷⻉远程主机上的⽂件到控制节点</p><p><img src="/../../../../images/clip_image228.jpg" alt="img"></p><h3 id="lineinfile模块："><a href="#lineinfile模块：" class="headerlink" title="lineinfile模块："></a>lineinfile模块：</h3><p>向⽂件⾥⾯追加写⼊指定的内容，⽬标⽂件必须存在，如果不存在，它不会⾃动创建，会报错</p><p><img src="/../../../../images/clip_image230.jpg" alt="img"></p><h3 id="blockinfile模块："><a href="#blockinfile模块：" class="headerlink" title="blockinfile模块："></a>blockinfile模块：</h3><p>将⽂本内容以⽂本块的⽅式写⼊到⽬标⽂件⾥⾯，与lineinfile⼀样，⽬标⽂件不存在，会报错</p><p><img src="/../../../../images/clip_image232.jpg" alt="img"></p><h3 id="jinja2模板"><a href="#jinja2模板" class="headerlink" title="jinja2模板"></a>jinja2模板</h3><p>使⽤ Jinja2 模板部署⾃定义⽂件</p><p><img src="/../../../../images/clip_image234.jpg" alt="img"></p><p>jinja2的分隔符：</p><p><img src="/../../../../images/clip_image236.jpg" alt="img"></p><p>部署模板使⽤ansible.builtin.template模块调⽤模板。</p><p>#创建模板文件</p><p><img src="/../../../../images/clip_image238.jpg" alt="img"></p><p>#在playbook里面调用模板</p><p><img src="/../../../../images/clip_image240.jpg" alt="img"></p><p>#执行剧本，验证执行结果</p><p><img src="/../../../../images/clip_image242.jpg" alt="img"></p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>可以在模板⽂件中使⽤ Jinja2 控制结构，以减少重复键⼊，为play 中的每个主机动态输⼊条⽬， 或者有条件地将⽂本插⼊到⽂件中</p><h2 id="使⽤循环"><a href="#使⽤循环" class="headerlink" title="使⽤循环"></a>使⽤循环</h2><p>Jinja2 使⽤ for 语句来提供循环功能。下例中，users 变量具有值列表。user 变量替换为 users 变量中的所有值，⼀⾏⼀个值</p><p><img src="/../../../../images/clip_image244.jpg" alt="img"></p><p><img src="/../../../../images/clip_image246.jpg" alt="img"></p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>它可以对模板的内容做⼀个格式化输出的操作</p><p><img src="/../../../../images/clip_image248.jpg" alt="img"></p><p>#默认变量过滤器default：默认情况下，当模板⾥⾯使⽤的变量不存在，会导致任务执⾏ 失败，后续的任务也会被影响，可以使⽤默认的变量过滤器指定⼀个默认值，当模板内的 变量不存在的时候，他会输出默认的内容替代变量的值，避免他会导致的语法错误。</p><p><img src="/../../../../images/clip_image250.jpg" alt="img"></p><h1 id="编写⼤型项⽬的playbook"><a href="#编写⼤型项⽬的playbook" class="headerlink" title="编写⼤型项⽬的playbook"></a>编写⼤型项⽬的playbook</h1><h2 id="主机清单"><a href="#主机清单" class="headerlink" title="主机清单"></a>主机清单</h2><p>静态的主机清单</p><p>动态的主机清单（清单⽂件本⾝具有可执⾏性，可以结合其他的资产管理或者监控系统⾃动的获取受管主机）</p><h2 id="配置主机清单"><a href="#配置主机清单" class="headerlink" title="配置主机清单"></a>配置主机清单</h2><p>注定准确的⽂件（在这个⽂件内的主机才会被管理）</p><p><img src="/../../../../images/clip_image252.jpg" alt="img"></p><p>#指定⼀个⽬录（只要在这个⽬录下存在的⽂件都会被认为是主机清单⽂件）</p><p>主机清单还可以在执⾏剧本或者临时命令的时候通过命令⾏指定主机清单</p><h2 id="主机清单内容的组成"><a href="#主机清单内容的组成" class="headerlink" title="主机清单内容的组成"></a>主机清单内容的组成</h2><p><img src="/../../../../images/clip_image254.jpg" alt="img"></p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>* &#x2F;&#x2F;表示所有的清单内的主机</p><p><img src="/../../../../images/clip_image256.jpg" alt="img"></p><p>#列表使用，（逗号）分割组名</p><p><img src="/../../../../images/clip_image258.jpg" alt="img"></p><p>#&amp;逻辑与的关系</p><p><img src="/../../../../images/clip_image260.jpg" alt="img"></p><p>#！逻辑非，排除的意思</p><p><img src="/../../../../images/clip_image262.jpg" alt="img"></p><h2 id="配置并⾏"><a href="#配置并⾏" class="headerlink" title="配置并⾏"></a>配置并⾏</h2><p>使⽤分叉（fork）在 Ansible 中配置并⾏(fork:同时执行任务的数量)</p><p><img src="/../../../../images/clip_image264.jpg" alt="img"><img src="/../../../../images/clip_image266.jpg" alt="img"></p><p><img src="/../../../../images/clip_image268.jpg" alt="img"></p><p><img src="/../../../../images/clip_image270.jpg" alt="img"></p><h2 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h2><p><img src="/../../../../images/clip_image272.jpg" alt="img"></p><p>#百分比的书写方式，他会按照主机清单的主机数量*serial指定的百分比，往小取整</p><p><img src="/../../../../images/clip_image274.jpg" alt="img"></p><p>#可以直接指定整数</p><p><img src="/../../../../images/clip_image276.jpg" alt="img"></p><h2 id="包含或导⼊⽂件"><a href="#包含或导⼊⽂件" class="headerlink" title="包含或导⼊⽂件"></a>包含或导⼊⽂件</h2><p>导⼊playbook,使⽤关键字import_palybook:</p><p><img src="/../../../../images/clip_image278.jpg" alt="img"></p><p>导⼊任务，使⽤关键字import_tasks或者include_tasks</p><p>#创建任务列表</p><p><img src="/../../../../images/clip_image280.jpg" alt="img"></p><p># include_tasks</p><p><img src="/../../../../images/clip_image282.jpg" alt="img"></p><p>#import_tasks</p><p><img src="/../../../../images/clip_image284.jpg" alt="img"></p><h1 id="对playbook和受管主机进⾏故障排除"><a href="#对playbook和受管主机进⾏故障排除" class="headerlink" title="对playbook和受管主机进⾏故障排除"></a>对playbook和受管主机进⾏故障排除</h1><h2 id="对-playbook-进⾏故障排除"><a href="#对-playbook-进⾏故障排除" class="headerlink" title="对 playbook 进⾏故障排除"></a>对 playbook 进⾏故障排除</h2><p>显⽰任务执⾏的详细反馈</p><pre><code class="perl">ansible all -m ping -v ansible all -m ping -vv ansible all -m ping -vvv ansible all -m ping -vvvv</code></pre><p>使⽤debug模块对变量进⾏检测</p><p><img src="/../../../../images/clip_image286.jpg" alt="img"></p><p>检查playbook中的⼀些错误</p><p><img src="/../../../../images/clip_image288.jpg" alt="img"></p><h2 id="对Ansible受管主机进⾏故障排除"><a href="#对Ansible受管主机进⾏故障排除" class="headerlink" title="对Ansible受管主机进⾏故障排除"></a>对Ansible受管主机进⾏故障排除</h2><h3 id="受管主机⾝份验证问题"><a href="#受管主机⾝份验证问题" class="headerlink" title="受管主机⾝份验证问题"></a>受管主机⾝份验证问题</h3><p><img src="/../../../../images/clip_image290.jpg" alt="img"></p><h3 id="名称或地址解析问题"><a href="#名称或地址解析问题" class="headerlink" title="名称或地址解析问题"></a>名称或地址解析问题</h3><p>在主机清单⾥⾯写的是IP地址，那么调⽤的时候就⽤IP地址，如果是主机名，就⽤主机名 （需要可以DNS解析）</p><p><img src="/../../../../images/clip_image292.jpg" alt="img"></p><h3 id="特权升级问题"><a href="#特权升级问题" class="headerlink" title="特权升级问题"></a>特权升级问题</h3><p><img src="/../../../../images/clip_image294.jpg" alt="img"></p><p><img src="/../../../../images/clip_image296.jpg" alt="img"></p><p><img src="/../../../../images/clip_image298.jpg" alt="img"></p><h3 id="将检查模式⽤作测试⼯具"><a href="#将检查模式⽤作测试⼯具" class="headerlink" title="将检查模式⽤作测试⼯具"></a>将检查模式⽤作测试⼯具</h3><p><img src="/../../../../images/clip_image300.jpg" alt="img"> <img src="/../../../../images/clip_image302.jpg" alt="img"></p><h2 id="shell-、command临时命令"><a href="#shell-、command临时命令" class="headerlink" title="shell 、command临时命令"></a>shell 、command临时命令</h2><h3 id="使⽤模块进⾏测试"><a href="#使⽤模块进⾏测试" class="headerlink" title="使⽤模块进⾏测试"></a>使⽤模块进⾏测试</h3><p><img src="/../../../../images/clip_image304.jpg" alt="img"></p><p><img src="/../../../../images/clip_image306.jpg" alt="img"></p><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><h2 id="利⽤⻆⾊构建-Ansible-playbook"><a href="#利⽤⻆⾊构建-Ansible-playbook" class="headerlink" title="利⽤⻆⾊构建 Ansible playbook"></a>利⽤⻆⾊构建 Ansible playbook</h2><p>角色就是模板</p><p>数据中⼼具有许多不同类型的主机。⼀些充当 Web 服务器，另⼀些充当数据库服务器 </p><p>⼀个 Ansible playbook 中如果包含所有任务，随着时间推移将变得硕⼤⽽复杂 Ansible ⻆⾊让管理员可以将 playbook 组织为独⽴、较⼩的 playbook 和⽂件</p><p><img src="/../../../../images/clip_image308.jpg" alt="img"> <img src="/../../../../images/clip_image310.jpg" alt="img"> <img src="/../../../../images/clip_image312.jpg" alt="img"></p><p>#配置角色的路径</p><p>1、    找到原始的ansible.cfg搜索collections_path和roles_path</p><p><img src="/../../../../images/clip_image314.jpg" alt="img"></p><p>2、    添加自定义collections_path和roles_path到自己的ansible.cfg</p><p><img src="/../../../../images/clip_image316.jpg" alt="img"></p><p>3、    在该目录下创建roles和mycollections目录</p><p>#查看角色的目录结构</p><p><img src="/../../../../images/clip_image318.jpg" alt="img"></p><h2 id="在playbook⾥⾯调⽤⻆⾊完成任务"><a href="#在playbook⾥⾯调⽤⻆⾊完成任务" class="headerlink" title="在playbook⾥⾯调⽤⻆⾊完成任务"></a>在playbook⾥⾯调⽤⻆⾊完成任务</h2><p>调用已有的角色完成任务</p><p><img src="/../../../../images/clip_image320.jpg" alt="img"></p><p>#验证角色执行的结果</p><p>ansible all -m shell -a ‘chronyc sources’</p><h2 id="特殊任务部分"><a href="#特殊任务部分" class="headerlink" title="特殊任务部分"></a>特殊任务部分</h2><p><img src="/../../../../images/clip_image322.jpg" alt="img"></p><p>剧本任务</p><p><img src="/../../../../images/clip_image324.jpg" alt="img"></p><p>执行结果</p><p><img src="/../../../../images/clip_image326.jpg" alt="img"></p><h2 id="创建⻆⾊"><a href="#创建⻆⾊" class="headerlink" title="创建⻆⾊"></a>创建⻆⾊</h2><p>创建和使⽤⻆⾊三个步骤</p><pre><code class="perl">1. 创建⻆⾊⽬录结构 2. 定义⻆⾊内容 3. 在 playbook 中使⽤⻆⾊</code></pre><p>#创建角色的目录</p><p><img src="/../../../../images/clip_image328.jpg" alt="img"></p><p>#定义角色的内容</p><p><img src="/../../../../images/clip_image330.jpg" alt="img"></p><p>#调用自定义的角色</p><p><img src="/../../../../images/clip_image332.jpg" alt="img"></p><h1 id="ansible-navigator安装"><a href="#ansible-navigator安装" class="headerlink" title="ansible-navigator安装"></a>ansible-navigator安装</h1><pre><code class="perl">1、    sudo dnf install python3-pip2、    python3 -m pip install ansible-navigator –user3、    echo &#39;export PATH=$HOME/.local/bin:$PATH&#39; &gt;&gt; ~/.profile4、    source ~/.profile5、    ansible-navigator</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;部署ansible&quot;&gt;&lt;a href=&quot;#部署ansible&quot; class=&quot;headerlink&quot; title=&quot;部署ansible&quot;&gt;&lt;/a&gt;部署ansible&lt;/h1&gt;&lt;h2 id=&quot;2-1构建ansible清单&quot;&gt;&lt;a href=&quot;#2-1构建ansibl</summary>
      
    
    
    
    <category term="Linux - Blog" scheme="http://example.com/categories/Linux-Blog/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Blog" scheme="http://example.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>systemd守护进程</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/systemd%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/systemd%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:26:28.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="systemd-守护进程"><a href="#systemd-守护进程" class="headerlink" title="systemd 守护进程"></a>systemd 守护进程</h1><p>1、    systemd daemon（守护进程） 管理 Linux 的启动，包括服务的启动和管理</p><p>2、    systemd 可在系统引导时以及运⾏中的系统上激活系统资源、服务器守护进程和其他进程</p><p>3、    守护进程 daemon 是在后台运⾏或等待的进程，以执⾏不同的任务。通常 daemon 在系统启 动时运⾏，知道关机 时才结束运⾏。deamon 程序名称⼀般会有 d 字符</p><p>RHEL中，PID是systemd，提供以下功能：</p><p>a、    并⾏化功能（同时启动多个服务），可提⾼系统的启动速度</p><p>b、    按需启动守护进程，⽽不需要单独的服务</p><p>c、    ⾃动服务依赖关系管理，可以防⽌ timeouts。例如，只有在⽹络可⽤时，依赖⽹络 的服务才会尝试启动</p><p>d、    利⽤ Linux cgoups 追踪相关进程资源占⽤</p><h1 id="Unit的文件实现服务喝守护进程的管理"><a href="#Unit的文件实现服务喝守护进程的管理" class="headerlink" title="Unit的文件实现服务喝守护进程的管理"></a>Unit的文件实现服务喝守护进程的管理</h1><p>简而言之：服务都是通过文件产生的，而systemd通过unit文件管理服务，unit其实就是配置文件，unit有很多类型，其就是很多类型的配置文件，可以理解为通称</p><p>unit文件存储位置：</p><p>1、&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;     </p><p>2、&#x2F;etc&#x2F;systemd&#x2F;system&#x2F; 注意:这里unit是软连接，但优先级比较高</p><h1 id="service-units"><a href="#service-units" class="headerlink" title="service units"></a>service units</h1><p>systemd 使⽤ units 管理不同类型对象，常⻅的 units 类型包括：</p><p>1、.service：代表系统服务。这种单元⽤于启动经常访问的守护进程，如 httpd.service</p><p>2、.socket：代表 systemd 监控的进程间通信（IPC）socket。如果客戶端连接到 socket， systemd 将启动⼀个 守护进程并将连接传递给它。可使⽤ socket unit 来延迟系统启动时 的服务启动，或者按需启动不常使⽤的服务</p><p>3、.path：特定⽂件系统更改发⽣之后，服务才激活。如打印系统</p><p>所有可用units(systemctl -t help)</p><p><img src="/../../../../images/clip_image002.jpg" alt="img"></p><p>列出service units</p><p>1、     systemctl list-units –type&#x3D;service 列出所有 active 状态的service unit</p><p><img src="/../../../../images/clip_image004.jpg" alt="img"></p><p>2、    systemctl list-units –type&#x3D;service –all 列出所有 serviceunit</p><p><img src="/../../../../images/clip_image006-17172987701741.jpg" alt="img"></p><p>其中：UNIT 是 service unit 名称；LOAD 是 unit 的配置加载到了内存中；ACTIVE 表⽰ unit ⾼级激活状态，表⽰ 已经启动；SUB 表⽰ unit 低级别激活状态，有更多关于 unit 的状态信息；DESCRIPTION 是 unit 的简短描述</p><p># systemctl 列出所有已经 load 和 active 的 unit</p><p><img src="/../../../../images/clip_image008.jpg" alt="img"></p><p># systemctl list-unit-files 显⽰所有已经安装的 units 状态</p><p><img src="/../../../../images/clip_image010.jpg" alt="img"></p><p>查看service状态</p><p><img src="/../../../../images/clip_image012.jpg" alt="img"></p><p><img src="/../../../../images/clip_image014.jpg" alt="img"></p><p>systemctl status 输出中的服务状态</p><p><img src="/../../../../images/clip_image016.jpg" alt="img"><img src="/../../../../images/clip_image018.jpg" alt="img"> </p><p>验证服务的状态</p><p><img src="/../../../../images/clip_image020.jpg" alt="img"></p><p>控制系统服务</p><p><img src="/../../../../images/clip_image022.jpg" alt="img"></p><p>列出 unit 依赖关系</p><p><img src="/../../../../images/clip_image024.jpg" alt="img"></p><p><img src="/../../../../images/clip_image026.jpg" alt="img"></p><p>屏蔽和取消屏蔽服务</p><p>1、系统中的不同服务可能会彼此冲突，例如http和nginx都是80端口</p><p>2、systemctl mask 命令屏蔽服务，可防⽌管理员意外启动与其他服务冲突的服务。屏蔽操 作会创建指向 &#x2F;dev&#x2F;null ⽂ 件的链接，该⽂件可阻⽌服务启动</p><p>3、systemctl unmask 命令可取消屏蔽</p><p><img src="/../../../../images/clip_image028.jpg" alt="img"></p><p>服务在系统引导时启动或停止</p><p>开机自启动：systemctl enable httpd</p><p>取消服务开机自启动：systemctl disable httpd</p><p>启动服务且开机自启服务：systemctl enable httpd –now</p><h1 id="SSH服务"><a href="#SSH服务" class="headerlink" title="SSH服务"></a>SSH服务</h1><p>识别远程用户：w命令</p><p><img src="/../../../../images/clip_image030.jpg" alt="img"></p><p>SSH远程：ssh 用户名@IP或主机名 </p><p>SSH远程操作：ssh 用户名@IP或主机名 命令</p><p>SSH主机密钥</p><p>SSH 通过公钥加密的⽅式保持通信安全。在该客戶端登录之前，服务器会向其发送公钥副本。 ⽤于设置通信渠道 的安全加密，并验证客戶端服务器</p><p>⽤⼾连接服务器时，会检查客⼾机本地 &#x2F;etc&#x2F;ssh&#x2F;ssh_known_hosts 或 ~&#x2F;.ssh&#x2F;known_hosts 中是否含有服务器公钥，并与从服务器获得公钥进⾏匹配，以验证服务器的⾝份（防⽌服务器 被假冒，或者需要编辑此⽂件替换新的 服务器秘钥）</p><p>特定⽤戶的 ~&#x2F;.ssh&#x2F;config 或系统范围的&#x2F;etc&#x2F;ssh&#x2F;ssh_config 中，将 StrictHostKeyChecking 参数设为yes，使 得 ssh 命令在公钥不匹配时始终中断 SSH 链接</p><p>服务器的公钥存放在：&#x2F;etc&#x2F;ssh&#x2F;*key.pub 中</p><p>第⼀次连接服务器时，会尝试保存从服务器获得的公钥，并要求⽤⼾确认，确认后，公钥副本 保存到： ~&#x2F;.ssh&#x2F;known_hosts</p><p><img src="/../../../../images/clip_image032.jpg" alt="img"></p><p>其中第⼀个字段是共享该公钥的主机名和 IP 地址的列表。第⼆个字段是公钥的加密算法。</p><p>最后一个字段是公钥本身</p><p>如果由于硬盘驱动器故障⽽导致公钥丢失或由于某些正当理由⽽导致公钥被更换，并由此更改了服务器的公钥， 必须编辑已知主机⽂件以将旧公钥条⽬替换为新公钥条目</p><p>生成SSH密钥</p><p>ssh-keygen 命令创建⽤⼾的公钥和私钥，默认保存在 ~&#x2F;.ssh&#x2F;id_rsa 和 ~&#x2F;.ssh&#x2F;id_rsa.pub文件中</p><p><img src="/../../../../images/clip_image034.jpg" alt="img"></p><p>私钥还可以以密码加以保护，登录时，需要输⼊私钥保护密码</p><p>私钥只能由所有者读取，为 600 权限。公钥则可被任何⼈读取，通常设置为 644 权限</p><p>共享公钥</p><p>ssh-copy-id 命令可以将⽤⼾的 SSH 公钥（默认为&#x2F;home&#x2F;user&#x2F;.ssh&#x2F;id_rsa.pub）复制到⽬标 系统中</p><p><img src="/../../../../images/clip_image036.jpg" alt="img"></p><p><img src="/../../../../images/clip_image038.jpg" alt="img"></p><p>免密是针对与⽤⼾的，不是主机</p><p>SSH连接基本故障排除</p><p>ssh 命令通过 - v、-vv 和 -vvv 选项提供三个详细程度级别，提供越来越多的调试信息</p><p><img src="/../../../../images/clip_image040.jpg" alt="img"></p><p>⾃定义 OpenSSH 配置</p><p>OpenSSH 的守护进程名为 sshd，主配置⽂件为&#x2F;etc&#x2F;ssh&#x2F;sshd_config</p><p>推荐禁⽤ root ⽤⼾远程登录和基于密码的⾝份验证（⽽使⽤公私钥验证⽅式替代）</p><p><img src="/../../../../images/clip_image042.jpg" alt="img"> <img src="/../../../../images/clip_image044.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;systemd-守护进程&quot;&gt;&lt;a href=&quot;#systemd-守护进程&quot; class=&quot;headerlink&quot; title=&quot;systemd 守护进程&quot;&gt;&lt;/a&gt;systemd 守护进程&lt;/h1&gt;&lt;p&gt;1、    systemd daemon（守护进程） 管理 </summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>yum-dnf-文件系统-查找</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/yum-dnf-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E6%89%BE/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/yum-dnf-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E6%89%BE/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:31:15.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h1><h2 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h2><p>linux：他的可执⾏程序的elf格式的⽂件，程序运⾏时的依赖动态链接库⽂件的动态链接库文件.dll格式的文件</p><p>linux：他的可执⾏程序的elf格式的⽂件，程序运⾏时的依赖动态链接库⽂件的格式 时.so⽂件。</p><h2 id="红帽提供了⼀种安装⽅式rpm"><a href="#红帽提供了⼀种安装⽅式rpm" class="headerlink" title="红帽提供了⼀种安装⽅式rpm"></a>红帽提供了⼀种安装⽅式rpm</h2><p>提供了⼀个⼯具rpm，他可以⽀持安装，升级，卸载，查询已经编译封装好的⼆进制软件 包.rpm，他的功能更多的⽤于查询，其他的功能具备但是不推荐使⽤，因为rpm这个⼯具不能 解决软件安装时的依赖关系</p><p>#使用rpm安装软件</p><p><img src="/../../../../images/clip_image002-17172990452351.jpg" alt="img"></p><p>htop： 软件的名称。</p><p>2.2.0： 软件的版本号。</p><p>3.el8： 软件的发布号，以及支持的 Red Hat 发行版的版本号（在这个例子中是 EL8，代表 Red Hat Enterprise Linux 8）。</p><p>x86_64： 软件支持的体系结构。</p><p>#更新软件</p><p><img src="/../../../../images/clip_image004-17172990452352.jpg" alt="img"></p><p>#卸载软件</p><p><img src="/../../../../images/clip_image005.png" alt="img"></p><p>#查询功能，查看软件包是否安装</p><p><img src="/../../../../images/clip_image006.png" alt="img"></p><p>#查询软件安装后在系统里面生成哪些文件</p><p><img src="/../../../../images/clip_image008-17172990452353.jpg" alt="img"></p><p>#查看软件的配置文件</p><p><img src="/../../../../images/clip_image009.png" alt="img"></p><p>#查看软件的帮助文档保存在哪里</p><p><img src="/../../../../images/clip_image010.png" alt="img"></p><p>#查看软件安装时运行了哪些检测脚本</p><p><img src="/../../../../images/clip_image012-17172990452364.jpg" alt="img"></p><p>#查看软件相关信息</p><p><img src="/../../../../images/clip_image014-17172990452365.jpg" alt="img"></p><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p>因为rpm不能够⾃动解决依赖关系，所以为了解决这个问题，使得安装程序更加的智能，自动化，使得yum工具作为rpm全段，他会记录软件仓库内软件的依赖关系。</p><p>安装的软件的时 候，他会先查询依赖关系，然后再软件仓库内下载对应版本的依赖软件，然后安装软件。</p><p>yum是dnf的链接⽂件，但是yum使⽤的命令和dnf除了命令 的名字不⼀样以外，其他的选项参数都是⼀样的。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><img src="/../../../../images/clip_image016-17172990452367.jpg" alt="img"></p><h3 id="配置⽂件的选项"><a href="#配置⽂件的选项" class="headerlink" title="配置⽂件的选项"></a>配置⽂件的选项</h3><p><img src="/../../../../images/clip_image018-17172990452366.jpg" alt="img"></p><p>注意：建议不要源不要超过3个，name不可以重复，名字可以随便取</p><p>baseurl可以是本地的仓库，http，ftp，但是必须可以正常访问</p><h2 id="dnf工具的使用"><a href="#dnf工具的使用" class="headerlink" title="dnf工具的使用"></a>dnf工具的使用</h2><p>#验证仓库的配置文件是否正确</p><p><img src="/../../../../images/clip_image020-17172990452368.jpg" alt="img"></p><p><img src="/../../../../images/clip_image022-17172990452369.jpg" alt="img"></p><p>#清除本地的依赖关系缓存</p><p><img src="/../../../../images/clip_image024-171729904523610.jpg" alt="img"></p><p>#安装软件、更新软件、卸载软件、搜索软件是否存在与软件仓库内、查看软件的详细信息、通过命令字查询软件包的名字</p><p>dnf install &#x2F; dnf update &#x2F; dnf remove &#x2F; dnf search &#x2F; dnf info &#x2F; dnf provides </p><p>查看一个文件属于哪个软件包</p><p><img src="/../../../../images/clip_image026-171729904523611.jpg" alt="img"></p><h3 id="组安装"><a href="#组安装" class="headerlink" title="组安装"></a>组安装</h3><p>将实现某个功能(虚拟主机、图形化服务器)所需要的所有的软件包困在⼀起安装</p><p>#组安装：dnf groupinstall -y “Virtualization Host”</p><p>注意：如果有特殊符号或空格就要+双引号</p><p>#卸载包组：dnf groupremove -y “Virtualization Host”</p><h3 id="Baseos-和-Appstream"><a href="#Baseos-和-Appstream" class="headerlink" title="Baseos 和 Appstream"></a>Baseos 和 Appstream</h3><p>他们都是软件仓库组件，主要用于分离操作系统和应用程序流</p><p>Baserul：是一个包含操作系统的基本组件的软件仓库。这个仓库包括核心的系统库、命令行工具、核心服务等。</p><p>Appstream：是包含应用程序和附加软件的软件仓库。这个仓库中包含了各种应用程序、库和附加工具，为用户提供更广泛的软件选择。</p><p>AppStream 使用了模块化(module)的方法，允许用户选择不同版本的软件（例如，不同版本的数据库、编程语言等）。</p><p>区别：</p><p>Baseurl不能下载指定的软件，而Appstream可以下载指定版本的软件。</p><p>baseos 关注于提供操作系统的核心部分，而 appstream 则关注于提供用户和应用程序所需的各种软件。</p><p>#在module中查看自己的软件</p><p><img src="/../../../../images/clip_image028-171729904523613.jpg" alt="img"></p><p>nginx module 有4个stream(对应4个版本），默认安装的是1.14，1.14这个stream只有一个profile “common”, 它也是默认安装的profile </p><p>[d]efault, [e]nabled, [x]disabled, [i]nstalled</p><p>#安装module：dnf module install -y module_name:version</p><p>#卸载module：dnf module remove -y module_name:version</p><p>#重置module：dnf module reset module_name</p><p>#启动module：dnf module enable module</p><h1 id="查询文件"><a href="#查询文件" class="headerlink" title="查询文件"></a>查询文件</h1><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p>Ext4 (Fourth Extended Filesystem)：</p><p>特点： 是 Ext 文件系统家族的最新版本。支持大容量、大文件和快速恢复。</p><p>适用场景： 适合大多数普通用途的文件系统，广泛用于桌面和服务器系统。</p><p>XFS (XFS File System)：</p><p>特点： 针对大容量文件系统的性能进行了优化，支持高性能的读写操作，特别适用于大型文件和高性能要求的工作负载。</p><p>适用场景： 适合大型数据集和高性能存储需求的系统，如数据库服务器</p><p>在企业服务器集 群中，共享磁盘使⽤ GFS2⽂件系统来管理并发多节点访问</p><h2 id="文件系统和挂载点"><a href="#文件系统和挂载点" class="headerlink" title="文件系统和挂载点"></a>文件系统和挂载点</h2><p>挂载点</p><p><img src="/../../../../images/clip_image030-171729904523612.jpg" alt="img"></p><p>挂载⽀持⼿动挂载(使⽤mount命令挂载)和⾃动挂载（编辑&#x2F;etc&#x2F;fstab⽂件）</p><p><img src="/../../../../images/clip_image032-171729904523614.jpg" alt="img"></p><p><device>：要挂载的设备或分区的设备文件路径（如 &#x2F;dev&#x2F;sda1）或 UUID。</device></p><p><mount_point>：挂载点，文件系统将被挂载到这个目录。</mount_point></p><p><fs_type>：文件系统类型，例如 ext4、ntfs、xfs 等。</fs_type></p><p><options>：挂载选项，包括读写权限、挂载时的行为等。</options></p><p><dump>：用于备份工具的标志，通常设置为 0 表示不备份。</dump></p><p><pass>：用于 fsck 工具的标志，通常设置为 1 表示在系统引导时检查。</pass></p><h2 id="⽂件系统、存储和块设备"><a href="#⽂件系统、存储和块设备" class="headerlink" title="⽂件系统、存储和块设备"></a>⽂件系统、存储和块设备</h2><p>Linux 中，对存储设备的低级别访问是访问 block device ⽂件</p><p>在挂载这些 block device 前，必须先使⽤⽂件系统对其进⾏格式化 block device 存储在 &#x2F;dev ⽬录中</p><p>块设备是不能格式化，只有分区才能格式化</p><p>在 RHEL 中，第⼀个 SATA&#x2F;PATA、SAS、SCSI 或 USB 设备称为 &#x2F;dev&#x2F;sda， 第⼆个 被称为 &#x2F;dev&#x2F;sdb，以此类推(lsblk命令查看)</p><p>块设备命名：</p><p><img src="/../../../../images/clip_image034-171729904523615.jpg" alt="img"></p><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>存储设备通常划分为更⼩的区块，称为分区</p><p>不同分区可以通过不同的⽂件系统进⾏格式化或⽤于不同的⽤途</p><p>分区本⾝就是块设备。例如，第⼀磁盘上的第⼀个分区是&#x2F;dev&#x2F;sda1。第⼆磁盘上的 第三个分区是 &#x2F;dev&#x2F;sdb3，vda 分区类似</p><p>NVMe SSD 命名略有不同。第⼀磁盘上的第⼀个分区是&#x2F;dev&#x2F;nvme0p1。 第⼆磁盘上 的第三个分区是 &#x2F;dev&#x2F;nvme1p3，SD 或 MMC 存储卡分区类似</p><p><img src="/../../../../images/clip_image036-171729904523616.jpg" alt="img"></p><h2 id="逻辑卷"><a href="#逻辑卷" class="headerlink" title="逻辑卷"></a>逻辑卷</h2><p>逻辑卷管理（LVM）可⽤于整理磁盘和分区。</p><p>⼀个或多个块设备可以汇集为⼀个存储 池，称为卷组。卷组中的磁盘空间被分配到⼀个或多个逻辑卷，它们的功能等同于物理磁 盘上的分区</p><p>LVM 的⽬录结构类似：&#x2F;dev&#x2F;myvg&#x2F;mylv，其中 myvg 为volume group，mylv 为 logicalvolume（注：&#x2F;dev&#x2F;mapper&#x2F;myvg_mylv 是另⼀种命名⽅式）</p><h2 id="检查文件系统"><a href="#检查文件系统" class="headerlink" title="检查文件系统"></a>检查文件系统</h2><p>df 命令可以查看⽂件系统的空间状况</p><p><img src="/../../../../images/clip_image038-171729904523617.jpg" alt="img"></p><p>du 命令可以查看特定⽬录使⽤空间状况，同样可以使⽤ -h 和 -H选项</p><p>-h：显示的文件大小以更易读的方式呈现</p><p>-H：仅在计算目录大小时，将符号链接视为目录而非文件</p><p><img src="/../../../../images/clip_image039.png" alt="img"></p><p>卸载⽂件系统：umount 命令可以⼿动协助⽂件系统</p><p>查看分区的UUID：blkid &#x2F;dev&#x2F;sda1</p><h2 id="完整的创建分区，格式化，挂载的操作"><a href="#完整的创建分区，格式化，挂载的操作" class="headerlink" title="完整的创建分区，格式化，挂载的操作"></a>完整的创建分区，格式化，挂载的操作</h2><p>#创建分区</p><p>1、    选择你要分区的磁盘(查看 lsblk)</p><p>2、    创建分区(fdisk) 例如：fdisk &#x2F;dev&#x2F;vdb</p><p>3、    选择创建主分区(n)</p><p>4、    选择分区ID(1-4)</p><p>5、    选择分区开始大小(建议选择默认)，选择分区结束大小(+nG)</p><p>6、    可查看自己的划分情况(p)</p><p>7、    保存退出(w)</p><p><img src="/../../../../images/clip_image041-171729904523619.jpg" alt="img"></p><p>#格式化分区</p><p><img src="/../../../../images/clip_image043-171729904523618.jpg" alt="img"></p><p>#编辑自动挂载</p><p><img src="/../../../../images/clip_image045-171729904523621.jpg" alt="img"></p><p>mount -a：尝试挂载&#x2F;etc&#x2F;fstab文件中列出的所有文件系统，如果配置错误会报错，也可以用于检测配置文件。</p><p>#查看分区的UUID</p><p><img src="/../../../../images/clip_image047-171729904523620.jpg" alt="img"></p><h1 id="在系统中搜索文件"><a href="#在系统中搜索文件" class="headerlink" title="在系统中搜索文件"></a>在系统中搜索文件</h1><p>locate 命令搜索预⽣成索引中的⽂件名或⽂件路径，并即时返回结果(维护了⼀个数据库，可能因为数据库更新的不及时⽽导致查询结果不准确，可以使⽤updatedb手动更新数据库，-i 选项执⾏不区分⼤⼩写的搜索，-n 选项限制 locate 命令返回的搜 索结果数量) </p><p>find 命令通过遍历整个⽂件系统来实时搜索⽂件（可能会⽐较慢）</p><p>#文件名称搜索</p><p><img src="/../../../../images/clip_image048.png" alt="img"></p><p>#通过用户名搜索文件</p><p><img src="/../../../../images/clip_image050.jpg" alt="img"></p><p>#通过用户组的名称搜索文件</p><p><img src="/../../../../images/clip_image051.png" alt="img"></p><p>#通过UID搜素文件</p><p><img src="/../../../../images/clip_image053-171729904523622.jpg" alt="img"></p><p>#通过权限搜索文件</p><p><img src="/../../../../images/clip_image055-171729904523623.jpg" alt="img"></p><p><img src="/../../../../images/clip_image057-171729904523624.jpg" alt="img"></p><p>#指定匹配的文件类型 f文件 d目录 l链接</p><p><img src="/../../../../images/clip_image059-171729904523625.jpg" alt="img"></p><p>#指定文件大小进行查找</p><p><img src="/../../../../images/clip_image061-171729904523626.jpg" alt="img"></p><p><img src="/../../../../images/clip_image063-171729904523627.jpg" alt="img"></p><p>#表示排除的方法</p><p><img src="/../../../../images/clip_image065-171729904523628.jpg" alt="img"></p><h1 id="web版的系统管理平台"><a href="#web版的系统管理平台" class="headerlink" title="web版的系统管理平台"></a>web版的系统管理平台</h1><p><img src="/../../../../images/clip_image067-171729904523629.jpg" alt="img"></p><p><img src="/../../../../images/clip_image069.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;配置yum源&quot;&gt;&lt;a href=&quot;#配置yum源&quot; class=&quot;headerlink&quot; title=&quot;配置yum源&quot;&gt;&lt;/a&gt;配置yum源&lt;/h1&gt;&lt;h2 id=&quot;软件包&quot;&gt;&lt;a href=&quot;#软件包&quot; class=&quot;headerlink&quot; title=&quot;软件包</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:35:07.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统的启动过程"><a href="#系统的启动过程" class="headerlink" title="系统的启动过程"></a>系统的启动过程</h1><h2 id="target的切换⽅式"><a href="#target的切换⽅式" class="headerlink" title="target的切换⽅式"></a>target的切换⽅式</h2><p><img src="/../../../../images/clip_image002-17172993022871.jpg" alt="img"><img src="/../../../../images/clip_image004-17172993022874.jpg" alt="img"><img src="/../../../../images/clip_image006-17172993022872.jpg" alt="img"></p><h2 id="重置root密码"><a href="#重置root密码" class="headerlink" title="重置root密码"></a>重置root密码</h2><p><img src="/../../../../images/clip_image008-17172993022873.jpg" alt="img"></p><p><img src="/../../../../images/clip_image010-17172993022875.jpg" alt="img"></p><p><img src="/../../../../images/clip_image012-17172993022887.jpg" alt="img"></p><p>上图的第四⾏从后⾯开始删除，⼀直到ro,改成rw 加上rd.break， 按下ctrl + x 强制系统进⼊ 单⽤⼾模式。</p><p><img src="/../../../../images/clip_image014-17172993022876.jpg" alt="img"></p><p>1、切换⽂件系统 2、修改root⽤⼾密码（不需要原始密码） </p><p>3、重新打selinux标签 4、退出单⽤⼾模式 5、退出</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;系统的启动过程&quot;&gt;&lt;a href=&quot;#系统的启动过程&quot; class=&quot;headerlink&quot; title=&quot;系统的启动过程&quot;&gt;&lt;/a&gt;系统的启动过程&lt;/h1&gt;&lt;h2 id=&quot;target的切换⽅式&quot;&gt;&lt;a href=&quot;#target的切换⽅式&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>文件-目录-变量-引号</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95-%E5%8F%98%E9%87%8F-%E5%BC%95%E5%8F%B7/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95-%E5%8F%98%E9%87%8F-%E5%BC%95%E5%8F%B7/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:15:27.836Z</updated>
    
    <content type="html"><![CDATA[<p>创建目录</p><p>mkdir 创建一个或多个目录或子目录</p><p>例： mkdir dir1 dir2</p><p>mkdir -p 创建目录树，即创建多级目录</p><p><img src="/../../../../images/clip_image002-17172980934841.gif" alt="img"></p><p>创建(touch)</p><p>①文件不存在，他会创建文件，记录文件的创建时间 </p><p>②文件存在，他会修改文件的时间戳</p><p><img src="/../../../../images/clip_image004-17172980934842.gif" alt="img"></p><p>复制文件和目录</p><p>cp 将一个或多个文件复制到某一目录中，如果目标已存在，cp可覆盖该文件</p><p><img src="/../../../../images/clip_image006-17172980934846.gif" alt="img"></p><p>cp -r 递归，可复制目录以及其子目录</p><p>移动文件和目录</p><p>mv 可将文件从一个位置移动到另一个位置，如果位置相同，则重命名</p><p>-f 强制覆盖 -i 交互移动(会询问用户) -n 如果目标文件已存在，不移动</p><p>应用：可边移动边重命名</p><p><img src="/../../../../images/clip_image008-17172980934843.gif" alt="img"></p><p>删除目录</p><p>rmdir  只能删除空目录</p><p>rm -rf 能够删除文件、目录</p><p><img src="/../../../../images/clip_image010-17172980934844.gif" alt="img">删除(rm)</p><p><img src="/../../../../images/clip_image012-17172980934845.gif" alt="img"></p><p>rm file1 文件时需要询问对方，原因是rm的别名是“rm -i”</p><p>文件的链接类型</p><p>现象描述</p><p>当把原文件删除之后，通过软链接是无法访问，通过硬链接是可以访问的</p><p>软链接(类似windows的快捷方式)</p><p>作用：专门指向某一个文件,删除了这个软链接文件，等于断开这个链接，原文件不会受到影响，但如果原始文件被删除，软链接文件就不能打开</p><p>软链接会建立inode</p><p>硬链接</p><p>新的硬链接和原始文件的一切属性和内容完全相同，同步更新</p><p>硬链接不会建立inode，删除硬链接时，系统会检查这个文件的inode，如果大于等于1，inode不会被回收，自然文件的内容不会被删除</p><p>软链接可以跨文件系统，硬链接不可以；</p><p>软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,硬链接不可以（其文件必须存在，inode必须存在）；</p><p>软链接可以对目录进行连接，硬链接不可以。</p><p>两种链接都可以通过命令 ln 来创建。ln 默认创建的是硬链接。</p><p>使用 -s 开关可以创建软链接</p><p>硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块</p><p>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径</p><p>ln 默认选项是硬链接， -s 软链接</p><p>硬链接</p><p><img src="/../../../../images/clip_image014-17172980934857.gif" alt="img"></p><p>这两个文件如同一个文件，inode值相同，都指向同一个区块。</p><p>只有存在至少一个硬链接时，尽管原文件被删除，该文件的内容依然可以用。</p><p>软链接</p><p>软链接的inode和原文件的inode不一样，且有了一个1的flag</p><p><img src="/../../../../images/clip_image016-17172980934858.gif" alt="img"></p><p>大括号{}扩展：</p><p><img src="/../../../../images/clip_image018-171729809348510.gif" alt="img"></p><p>变量扩展</p><p>变量：把字符或命令的执行结果等赋值给变量</p><p>$：读取变量的值</p><p>$()或者·反引号·</p><p><img src="/../../../../images/clip_image020-17172980934859.gif" alt="img"></p><p>以下是临时变量，加{}是为了避免其他shell扩展而引起的错误</p><p><img src="/../../../../images/clip_image022-171729809348511.gif" alt="img"></p><p>反斜杠()是转义字符，可防止紧随其后的字符被扩展</p><p>单引号、双引号、反引号在变量的区别</p><p>单引号：只会解析字面量的形式显示引号内的内容</p><p>双引号：会解析变量，但是不会解释命令</p><p>反引号：它会同时解析命令和变量</p><p><img src="/../../../../images/clip_image024-171729809348512.gif" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;创建目录&lt;/p&gt;
&lt;p&gt;mkdir 创建一个或多个目录或子目录&lt;/p&gt;
&lt;p&gt;例： mkdir dir1 dir2&lt;/p&gt;
&lt;p&gt;mkdir -p 创建目录树，即创建多级目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../../../images/clip_image00</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>日志-时间-网络</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E6%97%A5%E5%BF%97-%E6%97%B6%E9%97%B4-%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E6%97%A5%E5%BF%97-%E6%97%B6%E9%97%B4-%E7%BD%91%E7%BB%9C/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:27:40.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>日志用途：就是当系统出现故障的时候，有⼀个能够提供故障排除的参考依据的功能，⽇志 会记录系统内发⽣的时间，以及故障的产⽣原因等，还有如果发⽣了⼀些安全时间，⽇志能够 提供事件朔源的依据。</p><p>rhel9系统中有两个日志相关的服务：rsyslog和systemd-journal</p><p>systemd-journe：会记录系统内核启动过程的⽇志，记录的⽇志更加详细，不过他默认不会持久保存，当 系统重启后，重启前的⽇志会被删除，所以如果需要持久保存，需要做相应的配置实现</p><p>rsyslog服务：可以⾃定义⽇志的⽬的地，并且形成可以使⽤vim 、cat等⼯具查看的⽂本类型的 ⽇志。系统⼿机⽇志基于syslog协议。</p><p>1.1     rsyslog服务</p><p><img src="/../../../../images/clip_image002-17172988468811.jpg" alt="img"></p><p>服务的配置文件：</p><p><img src="/../../../../images/clip_image004-17172988468822.jpg" alt="img"></p><p>解析rsyslog服务的配置文件(&#x2F;etc&#x2F;rsyslog.conf)</p><p><img src="/../../../../images/clip_image006-17172988468824.jpg" alt="img"></p><p><img src="/../../../../images/clip_image008-17172988468823.jpg" alt="img"><img src="/../../../../images/clip_image010-17172988468825.jpg" alt="img"><img src="/../../../../images/clip_image012-17172988468826.jpg" alt="img"><img src="/../../../../images/clip_image014-17172988468827.jpg" alt="img"><img src="/../../../../images/clip_image016-17172988468828.jpg" alt="img"><img src="/../../../../images/clip_image018-17172988468829.jpg" alt="img"><img src="/../../../../images/clip_image020-171729884688210.jpg" alt="img"></p><p>日志的设备类型：</p><p><img src="/../../../../images/clip_image022-171729884688211.jpg" alt="img"><img src="/../../../../images/clip_image024-171729884688212.jpg" alt="img"></p><p>日志的级别：</p><p><img src="/../../../../images/clip_image026-171729884688214.jpg" alt="img"></p><p>注意：none，表示除外</p><p>常用的日志文件：</p><p><img src="/../../../../images/clip_image028-171729884688213.jpg" alt="img"></p><p>rsyslog日志服务的日志格式：</p><p><img src="/../../../../images/clip_image030-171729884688215.jpg" alt="img"></p><p>第一列：⽇志发⽣时间戳</p><p>第二列：发送信息的主机</p><p>第三列：发送信息的程序名和PID编号</p><p>第四列：具体的⽇志事件</p><p>日志的监控：</p><p>tail -f 可以动态的监控⽂件内容的变化，他同样可以⽤来调试系统的时候监控⽇志⽂件</p><p>⼿动发送 Syslog 消息（调试⽇志服务的配置）</p><p>logger 命令可将消息发送到 rsyslog 服务。默认情况下，它将优先级为 notice 的消息发 送给 user 类型的设备 (user.notice)，除⾮通过 -p 选项另有指定</p><p>若要向 rsyslog 服务发送消息并记录在 &#x2F;var&#x2F;log&#x2F;boot.log ⽇志⽂件中</p><p><img src="/../../../../images/clip_image031.png" alt="img"><img src="/../../../../images/clip_image033.jpg" alt="img"></p><p>rsyslog服务配置⽂件修改后要重启服务，⽇志的⽂件不要⼿⼯修改，否则可能会导致rsyslog 服务不会往⽇志⽂件⾥⾯再保存消息。</p><p>日志文件轮转</p><p>为什么需要日志轮转？</p><p>因为rsyslog服务会将系统⽇志记录在指定的⽂件⾥⾯，使⽤的时间⽐较久的话，会导致⽇志的 体积越来越⼤，会占⽤系统的磁盘空间，所以有⼀套机制，通过指定⽇志⽂件的⼤⼩，或者写 ⼊⽇志的时间，将⽇志的保存⽂件尽⼼分割，将分割保存的⽇志，按照默认的时间会删除时间 ⽐较久远的旧⽇志，这样就能够控制⽇志的磁盘占⽤。</p><p>logrotate ⼯具轮转⽇志⽂件，防⽌ &#x2F;var&#x2F;log 空间被占满</p><p>轮转时，重命名⽇志⽂件（添加时间戳），并创建新的⽇志⽂件</p><p>轮转若⼲次（默认4次（周）），丢弃最旧的⽇志⽂件，释放磁盘空间</p><p>每天都会计划运⾏ logrotate 程序，轮转频率依据配置⽂件定义</p><p><img src="/../../../../images/clip_image035.jpg" alt="img"></p><p>systemd-journal</p><p>配置文件</p><p><img src="/../../../../images/clip_image037.jpg" alt="img"></p><p><img src="/../../../../images/clip_image039.jpg" alt="img"></p><p>存储模式有三种：</p><p>\1.  persistent：永久保存在&#x2F;var&#x2F;log&#x2F;journal ⽬录中</p><p>\2.  voltile：临时保存在 &#x2F;run&#x2F;log&#x2F;journal ⽬录中</p><p>\3.  auto（默认）：如果有 &#x2F;var&#x2F;log&#x2F;journal ⽬录存在，则永久保存，如果没有则临时保存</p><p>在rhel9系统⾥⾯，systemd-jounal服务创建持久保存⽬录&#x2F;var&#x2F;log&#x2F;journal，需要重启系统使其配置⽣效</p><p>systemd-journal服务的⽇志，他是二进制的文件</p><p>systemd-journal提供了⼀个专⽤⼯具，⽤来查看systemd-journal的⽇志，journalctl</p><p>在系统⽇志中查找事件</p><p>systemd-journald 将⽇志存放在带索引的结构化⼆进制 journal⽂件中，默认存放在 &#x2F;run&#x2F;log ⽬录中</p><p>journalctl 命令可⽤于检索⽇志信息，建议以 root ⽤⼾执⾏</p><p>journalctl -p debug、info、notice、warning、err、crit、alert 和 emerg显⽰该级别及其之上的⽇志</p><p><img src="/../../../../images/clip_image041.jpg" alt="img"></p><p>journalctl -n 指定显⽰最后10条⽇志，也可以指定条⽬数量</p><p><img src="/../../../../images/clip_image043.jpg" alt="img"></p><p>journalctl -f 刷新⽇志(动态)，Ctrl+C 退出 </p><p><img src="/../../../../images/clip_image045.jpg" alt="img"></p><p>journalctl -u 显⽰ systemd unit 的信息</p><p><img src="/../../../../images/clip_image047.jpg" alt="img"></p><p>journalctl –since –until “YYYY-MM-DDhhmm:ss” yesterday、today和tomorrow可以指定⽇志时间段</p><p><img src="/../../../../images/clip_image049.jpg" alt="img"><img src="/../../../../images/clip_image051.jpg" alt="img"></p><p>journalctl -o verbose 显⽰更加详细的⽇志信息</p><p><img src="/../../../../images/clip_image053.jpg" alt="img"></p><p>journalctl 配合以下字段，可以搜索特定内容的⽇志 </p><p>可参考: man 7 systemd.journal-filelds</p><p>_COMM 是命令的名称</p><p>_EXE 是进程的可执⾏⽂件的路径</p><p>_PID 是进程的 PID </p><p>_UID 是运⾏该进程的⽤戶的 UID</p><p>_SYSTEMD_UNIT 是启动该进程的 systemd 单元</p><p><img src="/../../../../images/clip_image055.jpg" alt="img"><img src="/../../../../images/clip_image057.jpg" alt="img"></p><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><p>时间对服务的运行起着至关重要，服务的时间与系统时间误差较大，可能会导致服务起不来。</p><p>rhel9系统提供了⼀个专⽤的⼯具timedatectl命令⽤来管理系统的时间、始终服务等操作</p><p>timedatectl</p><p><img src="/../../../../images/clip_image059.jpg" alt="img"></p><p>查看系统当前的时间设置</p><p><img src="/../../../../images/clip_image061.jpg" alt="img"></p><p>列出时区：timedatectl list-timezones</p><p><img src="/../../../../images/clip_image063.jpg" alt="img"></p><p>tzselect：⽤来辅助查看系统的时区</p><p><img src="/../../../../images/clip_image065.jpg" alt="img"></p><p>通过选择你所在需要的时区，然后会给出一个具体市区位置</p><p><img src="/../../../../images/clip_image067.jpg" alt="img"></p><p>修改时区</p><p><img src="/../../../../images/clip_image068.png" alt="img"></p><p>修改时间</p><p><img src="/../../../../images/clip_image070.jpg" alt="img"></p><p>重置&#x2F;同步时间</p><p>1、chronyd -q</p><p><img src="/../../../../images/clip_image072.jpg" alt="img"></p><p>2、ntpdate time.nist.gov</p><p>注意：以上需要连接网络</p><p>chronyd</p><p>rhel9的系统⾥⾯，使⽤chrony服务作为ntp服务</p><p><img src="/../../../../images/clip_image073.png" alt="img"></p><p>配置文件目录:</p><p><img src="/../../../../images/clip_image075.jpg" alt="img"><img src="/../../../../images/clip_image077.jpg" alt="img"></p><p>重启chronyd服务，使得时间⽣效</p><p><img src="/../../../../images/clip_image078.png" alt="img"></p><p>验证ntp服务是否⽣效</p><p><img src="/../../../../images/clip_image080.jpg" alt="img"></p><p>如果配置的时间服务器是不存在的，则不会显示 * IP&#x2F;域名</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>旧版红帽企业 Linux 将 eth0、eth1 和 eth2 等名称⽤于各个⽹络接⼝</p><p>当设备添加和移除，命名的机制可能会导致命名变化。⽽且 PCIe标准⽆法保证在启动 时检测 PCIe 设备的顺序</p><p>RHEL 7 起开始采⽤新的命名体系，基于固件信息、PCI 总线拓扑和⽹络设备类型，⽽且不会更改</p><p>开头为接⼝类型：以太⽹接⼝ en，WLAN 接⼝ wl</p><p>紧接为固件信息或 PCI 设备位置信息</p><p>oN 为板载设备，例如 eno1为板载以太⽹设备 1</p><p>sN 为 PCI 热插拔设备，例如 ens3 表⽰ PCI 热插拔插槽 3 中的以太⽹卡</p><p>注意：板载设备是指板载网卡、板载声卡等直接嵌入主板上，不需要用户单独购买或插入</p><p>pMsN 为位于插槽 N 中总线 M 上的 PCI 设备，例如 enp0s1f0接⼝是插槽 1 中总 线 0 上的以太⽹卡的功能 0。可能还有⼀个名为enp0s1f1 的接⼝，它代表了同⼀设备的 功能 1，wlp4s0 表⽰插槽 0中 PCI 总线 4 上的 WLAN 卡</p><p>主机名和IP地址</p><p>Linux 有多种机制可以将主机名映射到 IP 地址，统称为名称解析 </p><p>静态设置：&#x2F;etc&#x2F;hosts 中⼿动更新 </p><p>DNS 动态获取：由 dhcp 或 &#x2F;etc&#x2F;resolve.conf 中配置的 dns 服务器来获取</p><p>查看主机名信息：</p><p><img src="/../../../../images/clip_image082.jpg" alt="img"></p><p><img src="/../../../../images/clip_image083.png" alt="img"></p><p>查看网络接口信息</p><p>ifconfig、ip、ip link</p><p>ifconfig少用，因为越来越少人维护了</p><p><img src="/../../../../images/clip_image085.jpg" alt="img"><img src="/../../../../images/clip_image087.jpg" alt="img"></p><p>ip link 命令列出系统上所有可⽤⽹络接⼝的名称和 MAC 地址</p><p><img src="/../../../../images/clip_image089.jpg" alt="img"></p><p>p -s link show 命令可以查看⽹络性能统计信息，包括收到 (RX)和传出 (TX) 的数据包 数、数据包错误数，以及丢 弃的数据包数</p><p><img src="/../../../../images/clip_image091.jpg" alt="img"></p><p>ip route 命令显⽰路由信息</p><p><img src="/../../../../images/clip_image093.jpg" alt="img"></p><p>traceroute 或 tracepath 追踪⽹络流量通过多个路由器到达远程主机⽽采⽤的路径</p><p><img src="/../../../../images/clip_image095.jpg" alt="img"></p><p>使⽤ ss 或 netstat 显⽰⽹络连接信息，ss ⽤以替换 netstat（不⼀定安装 net-tools 软件包）</p><p><img src="/../../../../images/clip_image097.jpg" alt="img"></p><p>使⽤命令⾏配置⽹络</p><p>网络管理的服务:  NetworkManager.service</p><p><img src="/../../../../images/clip_image099.jpg" alt="img"></p><p>RHEL9 中使⽤ NetworkManager 监控和管理⽹络，nmcli 命令配置⽹络，配置默认 以 INI 格式保存 在&#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F; ⽬录中</p><p>8版本的网络配置文件&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</p><p><img src="/../../../../images/clip_image101.png" alt="img"></p><p>9版本的网络配置文件&#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F;</p><p><img src="/../../../../images/clip_image103.jpg" alt="img"></p><p>9版本还存在8版本的网络配置文件用于兼容早期版本，&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F; ⽬录和 ifcfg 格式配置⽂件已被弃⽤，但为 了与较早版本兼 容，&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F; ⽬录中的 ifcfg 格式连接仍可识别 和加载</p><p>root ⽤⼾才能修改⽹络配置</p><p>device 指⽹络接⼝；connection 是针对 device 的配置集合</p><p>针对任⼀device，同⼀时间只有⼀个 connection 处于活动状态</p><p>每个 connection 具有⼀个名称或 ID</p><p><img src="/../../../../images/clip_image105.jpg" alt="img"><img src="/../../../../images/clip_image107.jpg" alt="img"></p><p>NetworkManage服务提供2个操作⽹络的命令：nmcli(命令⾏⼯具) nmtui（图形化的⼯具）</p><p>nmcli</p><p>查看联网信息</p><p><img src="/../../../../images/clip_image109.jpg" alt="img"></p><p><img src="/../../../../images/clip_image111.jpg" alt="img"></p><p>添加网络连接</p><p>查看nmcli帮助文档</p><p><img src="/../../../../images/clip_image113.jpg" alt="img"></p><p>为⽹络接⼝设置⼀个DHCP⽅式获取地址的⽹络链接</p><p><img src="/../../../../images/clip_image115.jpg" alt="img"></p><p><img src="/../../../../images/clip_image117.jpg" alt="img"></p><p>使⽤静态的⽅式配置⼀个⽹络链接</p><p><img src="/../../../../images/clip_image119.jpg" alt="img"><img src="/../../../../images/clip_image121.jpg" alt="img"></p><p>删除网络连接</p><p>nmcli con del name 命令删除连接，同时删除 connection 配置⽂件</p><p><img src="/../../../../images/clip_image123.jpg" alt="img"></p><p>编辑⽹络配置⽂件</p><p>默认情况下，通过 nmcli con mod name 进⾏的更改会⾃动保存到 &#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F; 中</p><p>⽀持⼿动编辑此⽂件（但不推荐，怕写错配置内容），然后运⾏ nmcli con reload 以便NetworkManager 读取配置更改</p><p>以前存储在 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F; 的 ifcfg 格式配置将继续有效</p><p>下图为 NetworkManager 设置和 INI ⽂件格式⽂件的⽐较</p><p><img src="/../../../../images/clip_image125.jpg" alt="img"><img src="/../../../../images/clip_image127.jpg" alt="img"></p><p>修改网络配置</p><p>&#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F;持久</p><p>&#x2F;run&#x2F;NetworkManager&#x2F;system-connections临时</p><p>&#x2F;usr&#x2F;lib&#x2F;NetworkManager&#x2F;system-connections&#x2F;待定  </p><p>&#x2F;usr&#x2F;lib&#x2F;NetworkManager&#x2F;system-connections&#x2F; 系统安装时就生效，用于确保系统在初始启动时能够自动连接到网络，无需用户干涉</p><p>修改完配置后，使⽤ nmcli con reload 读取配置更改，同时还需要将接⼝重启启动</p><p><img src="/../../../../images/clip_image129.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h1&gt;&lt;p&gt;日志用途：就是当系统出现故障的时候，有⼀个能够提供故障排除的参考依据的功能，⽇志 会记录系统内发⽣的时间，以及故障的产⽣原因等，还有如果发⽣</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>管道符</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E7%AE%A1%E9%81%93%E7%AC%A6/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E7%AE%A1%E9%81%93%E7%AC%A6/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:19:41.605Z</updated>
    
    <content type="html"><![CDATA[<p>管道符 |</p><p>“|”作用：将前一个命令的输出作为后一个命令的输入</p><p><img src="/../../../../images/clip_image001.png" alt="img"></p><p>tee</p><p>作用：⾸先将命令的执⾏结果让他正常显⽰在控制台，同时我们需要让他能够备份到其他的⽂件⾥⾯去</p><p>缺点：1、是覆盖，而不能叠加到同一文件。2、只接受正确的输出，错误的输出不接受</p><p><img src="/../../../../images/clip_image002.png" alt="img"></p><p>vim常用操作</p><pre><code class="perl">命令模式gg  跳转到文件的首行G   跳转到文件的尾部yy  复制    p   粘贴nyy 复制光标以下n行u   撤销上一步操作dd  删除光标所在的行ndd    删除光标所在行以下的n行x       删除光标所在位置的单个字符:n      输入：n可以将光标跳转到 第n行:set nu  给文件内的行添加编号，nu=number   :1s/test1/test2/g      将文件内第一行到最后一行的test1内容替换成test2:1,3s/test1/test2/g     将文件内第一行到第三行的test1内容替换成test2/test    向下搜索test关键字?test    向上搜索test关键字v   进入视图模式，上下键选择文本块，能够快速操作(dd , yy等)</code></pre><p>vim的配置文件：&#x2F;etc&#x2F;vimrc 全局的</p><p>环境变量</p><p>1、只能包含数字字母_三种字符做变量名，且不能以数字开头</p><p>2、变量赋值的&#x3D;两边不能有空格，否则shell会认为变量的值是参数</p><p>设置自定义变量：name&#x3D;tom</p><p>输出自定义变量：echo $name</p><p>取消变量的值：  unset name</p><p>把普通变量变为环境变量：export name&#x3D;tom</p><p>env | grep name  能查看环境变量，看不了普通变量</p><p>注意：设置了环境变量或普通变量，重启后就失效。</p><p>如果不想失效，则在以下文件添加变量：</p><p>&#x2F;etc&#x2F;profile、&#x2F;etc&#x2F;bashrc 、~&#x2F;.bash_profile 和 ~&#x2F;.bashrc</p><p>配置变量自动生效</p><p><img src="/../../../../images/clip_image004.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;管道符 |&lt;/p&gt;
&lt;p&gt;“|”作用：将前一个命令的输出作为后一个命令的输入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../../../images/clip_image001.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;tee&lt;/p&gt;
&lt;p&gt;作用：⾸先将命令的执⾏结果</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>用户-sudo-传输</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E7%94%A8%E6%88%B7-sudo-%E4%BC%A0%E8%BE%93/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E7%94%A8%E6%88%B7-sudo-%E4%BC%A0%E8%BE%93/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:30:10.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h1><p> 切换用户</p><p>1.1切换用户：su 和 su –</p><p><img src="/../../../../images/clip_image002-17172988853081.jpg" alt="img"></p><p>建议使用登录的方式：su -</p><p><img src="/../../../../images/clip_image004-17172988853092.jpg" alt="img"></p><p>区别：</p><p>su  不改变环境，保持当前用户环境</p><p>su - 启动新的shell，切换到目标用户的环境 </p><p>1.2 sudo赋权</p><p>sudo是linux系统管理指令，是允许系统管理员让普通⽤⼾执⾏⼀些或者全部的root命令 的⼀个⼯具，如halt，reboot，su等等。这样不仅减少了root⽤⼾的登录 和管理时间， 同样也提⾼了安全性。sudo不是对shell的⼀个代替，它是⾯向每个命令的。</p><p>配置文件</p><p>&#x2F;etc&#x2F;sudoers，主配置文件，是配置文件的模板，尽量不要写在这个文件</p><p>&#x2F;etc&#x2F;sudoers.d&#x2F;，其目录下创建sudo文件效果一样，可以实现sudo赋权</p><p>注：sudo配置只能在root⽤⼾下做操作，普通⽤⼾看不到这个配置⽂件⾥⾯的相应内容</p><p><img src="/../../../../images/clip_image006-17172988853093.jpg" alt="img"></p><p><img src="/../../../../images/clip_image008-17172988853094.jpg" alt="img"></p><p>规则的通用语法：</p><pre><code class="perl">user   host=(runas)  commanduser：      指定的用户host：     指定的主机/IP。可以使用ALL表示任何主机runas：     指定要切换到的用户身份。通常使用ALL表示任何用户command： 指定允许执行的命令。可以使用ALL表示任何命令注意：”NOPASSWD”是选项，它允许用户在执行sudo命令时不需要输入密码。</code></pre><p>例如: </p><p>developer 192.168.1.10&#x3D;(ALL) &#x2F;bin&#x2F;ls  </p><p>这表示developer用户只能在IP地址为192.168.1.10 的主机上执行&#x2F;bin&#x2F;ls命令</p><p>developer ALL&#x3D;(root) &#x2F;bin&#x2F;ls </p><p>这表示 developer 用户只能以 root 用户的身份执行 &#x2F;bin&#x2F;ls 命令。</p><p>developer ALL&#x3D;(admin:wheel) &#x2F;bin&#x2F;ls</p><p>这表示 developer 用户只能以admin或wheel用户组的成员身份执行&#x2F;bin&#x2F;ls命令。</p><p>配置sudo文件建议使用visudo工具，具有语法检测功能</p><p><img src="/../../../../images/clip_image010-17172988853095.jpg" alt="img"> <img src="/../../../../images/clip_image012-17172988853098.jpg" alt="img"> </p><p>sudo赋权的⽤⼾别名和命令的别名</p><p><img src="/../../../../images/clip_image014-17172988853097.jpg" alt="img"></p><p><img src="/../../../../images/clip_image016-17172988853096.jpg" alt="img"></p><p><img src="/../../../../images/clip_image018-17172988853099.jpg" alt="img"></p><p>如果出现用户别名和用户名相同，不会报错，是执行变量</p><p>例如：</p><p>User_Alias USER&#x3D;USER,TEST</p><p>USER   ALL&#x3D;(ALL)   ALL</p><p>用户USER,TEST都拥有sudo赋权</p><h1 id="文件归档"><a href="#文件归档" class="headerlink" title="文件归档"></a>文件归档</h1><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p>创建备份和通过⽹络传输数据时，归档和压缩⽂件⾮常有⽤，最常⽤命令时 tar tar ⽀持⽂件归档和 gzip、bzip2 或 xz 的加解压缩</p><p><img src="/../../../../images/clip_image020-171729888530910.jpg" alt="img"></p><pre><code class="perl">tar命令的选项使⽤ -c 或 --create 选项来创建存档 使⽤ -t 或 --list 选项来列出存档的内容 使⽤ -x 或 --extract 选项来提取存档 使⽤ -f 或 --file= 选项加上⽂件名，作为要运⾏的存档的参数 使⽤ -v 或 --verbose 选项⽤于查看添加到存档中或从中提取的⽂件有哪些</code></pre><h3 id="归档文件和目录"><a href="#归档文件和目录" class="headerlink" title="归档文件和目录"></a>归档文件和目录</h3><p>在linux系统里面文件的后缀名没有意义，不能通过文件的后缀名来判断文件的属性，需 要借助file命令去根据文件头部的魔法数字判断文件的实际类型</p><p><img src="/../../../../images/clip_image022-171729888530911.jpg" alt="img"></p><p>归档&#x2F;tmp目录下的文件，起名为tmp.bak和tmp.zip</p><p><img src="/../../../../images/clip_image024-171729888530912.jpg" alt="img"></p><p><img src="/../../../../images/clip_image026-171729888530913.jpg" alt="img"></p><h3 id="列出存档的内容"><a href="#列出存档的内容" class="headerlink" title="列出存档的内容"></a>列出存档的内容</h3><p><img src="/../../../../images/clip_image028-171729888530914.jpg" alt="img"></p><h3 id="从存档中提取文件"><a href="#从存档中提取文件" class="headerlink" title="从存档中提取文件"></a>从存档中提取文件</h3><p>默认情况是解压到执行解包命令的目录下</p><p><img src="/../../../../images/clip_image030-171729888530915.jpg" alt="img"></p><p>指定解包的路径</p><p><img src="/../../../../images/clip_image032-171729888530916.jpg" alt="img"></p><h3 id="创建压缩存档"><a href="#创建压缩存档" class="headerlink" title="创建压缩存档"></a>创建压缩存档</h3><pre><code class="perl">gzip优点：压缩速度相对较快。压缩比较高效，适合压缩文本文件。常用于网络传输和日志文件的压缩。区别：压缩比相对较低，不如 xz 和 bzip2。适合对大量小文件进行压缩。xz提供了更高的压缩比，通常比 gzip 和 bzip2 更好。压缩比例最高，适合压缩大文件。区别：压缩和解压缩速度相对较慢，特别是对于大型文件占用更多的系统资源。bzip2优点：提供了相对较高的压缩比。压缩和解压缩速度较快，通常优于 xz。压缩效果较好，适合压缩文本文件。区别：压缩比相对较低于 xz。对于大型文件，可能不如 xz 那么高效。</code></pre><p>使⽤下列选项之⼀来创建压缩的 tar 存档:</p><p>-z 或 –gzip 进⾏ gzip 压缩(filename.tar.gz 或 filename.tgz)</p><p>-j 或 –bzip2 进⾏ bzip2 压缩 (filename.tar.bz2)</p><p>-J 或 -xz 进⾏ xz 压缩 (filename.tar.xz)</p><p><img src="/../../../../images/clip_image034-171729888530917.jpg" alt="img"></p><p>属于不同文件属性</p><p><img src="/../../../../images/clip_image036-171729888530918.jpg" alt="img"></p><h3 id="提取压缩的存档"><a href="#提取压缩的存档" class="headerlink" title="提取压缩的存档"></a>提取压缩的存档</h3><p><img src="/../../../../images/clip_image038-171729888530920.jpg" alt="img"></p><p>如果解压两次，内容会覆盖，第一次解压test1，在第二次解压前，对第一次解压文件进行修改或增加，第二次解压，会覆盖其内容</p><p>要申明压缩的压缩格式，才能正确解压归档包，文件名不代表文件格式</p><h2 id="在系统之间安全的传输文件"><a href="#在系统之间安全的传输文件" class="headerlink" title="在系统之间安全的传输文件"></a>在系统之间安全的传输文件</h2><p>注意：如果传输出现报错，可查看两边的目录的权限，还有用户权限</p><p>如果root不行，就需要去sshd配置文件修改参数，rhel9默认不允许直接登录root</p><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>从本地传输⽂件到远程</p><p><img src="/../../../../images/clip_image040-171729888530919.jpg" alt="img"></p><p>从远程把⽂件下载到本地</p><p><img src="/../../../../images/clip_image042-171729888530921.jpg" alt="img"></p><h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3><p><img src="/../../../../images/clip_image044-171729888530922.jpg" alt="img"></p><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><p>rsync 命令是在系统之间安全复制⽂件的另⼀种⽅式,此⼯具采⽤的算法可通过仅同</p><p>步已更改的⽂件部分来将复制的数据量最⼩化</p><p>rsync 将仅复制⽂件系统间的差异部分，⽽ scp 复制所有内容</p><p>rsync 的 -n 选项，为模拟运⾏，显⽰需要同步的⽂件清单，⽽不真正同步</p><p>rsync 另外两个重要选项为：-v （–verbose）和 -a（–archive）</p><p>rsync -a 开启的选项如下</p><p><img src="/../../../../images/clip_image046.jpg" alt="img"></p><p>#同步本地文件到远程 </p><p>rsync -av &#x2F;etc&#x2F; root@serverb:&#x2F;opt </p><p>#同步远程文件到本地 </p><p>rsync -av root@serverb:&#x2F;etc &#x2F;opt</p><p>-a：这是一个组合选项，包含了很多常用的同步选项，包括递归复制子目录、保留文件属性（权限、所有者等）、保留符号链接等。</p><p>-v：显示操作过程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;用户&quot;&gt;&lt;a href=&quot;#用户&quot; class=&quot;headerlink&quot; title=&quot;用户&quot;&gt;&lt;/a&gt;用户&lt;/h1&gt;&lt;p&gt; 切换用户&lt;/p&gt;
&lt;p&gt;1.1切换用户：su 和 su –&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../../../../images/cl</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>权限</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E6%9D%83%E9%99%90/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E6%9D%83%E9%99%90/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:43:36.172Z</updated>
    
    <content type="html"><![CDATA[<p> 用户权限</p><p><strong>用户：⽤⼾账⼾为不同⼈员和运⾏的程序之间提供安全边界</strong></p><p><strong>用户账户有三种主要类型：</strong></p><p><strong>超级用户(root)、系统用户(由系统分配,不可交互登录)、普通用户(superuser、system user、regular user)</strong></p><p><strong>superser    就是 root ⽤⼾，UID&#x3D;0，具有系统的最⾼权限</strong></p><p><strong>system user  ⽤于系统管理，例如运⾏服务，不需要⽤于系统登录</strong></p><p><strong>regular user  供⽤⼾进⾏⽇常系统管理，通常具有权限限制</strong></p><p><strong>用户的ID和组ID，密码有效期相关配置的信息</strong></p><p><strong><img src="/../../../../images/clip_image001-17172997028481.png" alt="img"></strong></p><p><img src="/../../../../images/clip_image003-17172997028492.png" alt="img"><img src="/../../../../images/clip_image005-17172997028493.png" alt="img"><img src="/../../../../images/clip_image007.png" alt="img"></p><p><strong>id****：查看当前登录的用户或某用户的信息</strong></p><p><strong><img src="/../../../../images/clip_image008.png" alt="img"></strong></p><p><strong>创建用户：useradd</strong></p><pre><code>**-d  --home-dir HOME_DIR home directory of the new****//默认情况下，创建用户会自动在/home目录下创建一个与用户名相同的目 录，作为用户的家目录，-d选项可以指定用户的家目录****-M, --no-create-home   do not create the user&#39;s home directory** **//不自动创建/home目录下的用户家目录，结合-d指定用户家目录****-g, --gid GROUP  name or ID of the primary group of the new account****//****不自动按照系统给的GID，自定义GID****-G, --groups  GROUPS list of supplementary groups of the new account** **//指定用户的附属组。****-u, --uid UID user ID of the new account****//**默认 情况下用户的uid会用1000开始以此类推指定uid编号，但是可以使用-u选项直接指定 uid编号，但是要注意不要重复** **-s, --shell SHELL login shell of the new account** **//****指定用户的shell类型（/bin/bash可交互式的shell,/sbin/nologin非交互式的 shell）**</code></pre><p><strong>创建user2并将其添加到root组里面</strong></p><p><strong><img src="/../../../../images/clip_image010-17172997028494.png" alt="img"></strong></p><p><strong>指定用户user3的shell类型</strong></p><p><strong><img src="/../../../../images/clip_image012.png" alt="img"></strong></p><p><strong>解释&#x2F;etc&#x2F;passdw的字段</strong></p><p><strong>root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</strong></p><p><strong>admin:x:972:972::&#x2F;home&#x2F;admin:&#x2F;sbin&#x2F;nologin</strong></p><p><strong>以” : ”分割成为7段，用户名：密码：所有者：所属组：标识：家目录：shell类型</strong></p><p><strong>注意：字段值的标识为”::”表示没用标识</strong></p><p><strong>解释&#x2F;etc&#x2F;shadow****的字段</strong></p><p><strong>记录的内容分别是：用户名：加过盐的密码：密码账号有效期相关的信息</strong></p><p><strong>root:$6$sjbF09qE46pvPo.i$7RjUqdRls8aYE&#x2F;vePXYKbckixBVtrrlogpXQnmo&#x2F;ZSU2dvvMo8mRXpjy6Q2WYV8.V.YTAr7uJwPFbhEnXVhlb1::0:99999:7:::</strong></p><p>用户的密码文件的记录内容：以：分割成为9段</p><p>密码部分使用“ $ ”将其分割成为3个部分</p><p>分$6这个是加密算法6（sha512算法）</p><p><strong>$sjbF09qE46pvPo.i</strong>盐，系统生成的随机数，用来防止密码冲突</p><p><strong>$7RjUqdRls8aYE&#x2F;vePXYKbckixBVtrrlogpXQnmo&#x2F;ZSU2dvvMo8mRXpjy6Q2WYV8.V.YTAr7uJwPFbhEnXVhlb1，</strong>就是用户的密码+盐通过算法计算后的用户密码(具有不可逆性)</p><p><strong>修改用户(usermod)</strong></p><pre><code>**-g, --gid GROUP force use GROUP as new primary group//修改GID****-G, --groups GROUPS new list of supplementary GROUPS // 修改附属组****-u, --uid UID new UID for the user account//修改uid** **-s, --shell SHELL new login shell for the user account //修改shell类型** **-L, --lock lock the user account //锁定用户****-U, --unlock unlock the user account //解锁用户**</code></pre><p><strong><img src="/../../../../images/clip_image014.png" alt="img"></strong></p><p><strong>删除用户(userdel)</strong></p><p><strong>-r, –remove remove home directory and mail spool</strong> </p><p>**&#x2F;&#x2F;**<strong>删除用户同时也删除他的家目录</strong></p><p><strong><img src="/../../../../images/clip_image016.png" alt="img"></strong></p><p><strong>注意：假如user3(1002)在没有被删除前，创建了一个文件(file1)，所属者user3(1002),用户user3被删除后，file1的所属者是1002，如果再创建一个用户user4,其UID是1002，那么该file1的所属者是user4</strong></p><p><strong>给用户添加密码(passwd)</strong></p><p><strong>#passwd</strong> <strong>交互式</strong></p><p><strong><img src="/../../../../images/clip_image018.png" alt="img"></strong></p><p><strong>#passwd</strong> <strong>非交互式</strong></p><p><strong><img src="/../../../../images/clip_image019-17172997028495.png" alt="img"></strong></p><p><strong>创建用户组(groupadd)</strong></p><p><strong><img src="/../../../../images/clip_image020.png" alt="img"></strong></p><p><strong>-g, –gid GID         use GID for the new group</strong></p><p><strong>解释&#x2F;etc&#x2F;group的字段</strong></p><p><strong>root:x:0:</strong></p><p><strong>以” : ”分割成为4段，组名：密码：组id:保留</strong></p><p><strong>修改用户组groupmod</strong></p><pre><code>**-g, --gid GID         change the group ID to GID  //****修改Gid****-n, --new-name NEW_GROUP   change the name to NEW_GROUP //****修改组名****-U, --users USERS list of user members of this group //****在用户组添加用户**</code></pre><p><strong>删除用户组groupdel</strong></p><pre><code>**配置密码生命周期chage****-d, --lastday LAST_DAY set date of last password change to LAST_DAY** **//修改最后登录时间****-I(i), --inactive INACTIVE set password inactive after expiration to INACTIVE** **//不可用周期(宽限期)****-l, --list show account aging information //查看用户密码信息****-m, --mindays MIN_DAYS set minimum number of days before password change to MIN_DAYS**  **//最小生命周期,离下一次的修改的密码的时间间隔，在最小时间内，是不能够修改密码****-M, --maxdays MAX_DAYS set maximum number of days before password change to MAX_DAYS   //最大生命周期，有max时间是有效****-W, --warndays WARN_DAYS set expiration warning days to WARN_DAYS**  </code></pre><p><strong>&#x2F;&#x2F;警告周期</strong></p><p><strong><img src="/../../../../images/clip_image022.png" alt="img"></strong></p><h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><p><strong>解释Linux文件系统权限</strong></p><p><strong>文件权限类别：读取(r，4)，写入(w，2)，执行(x，1)</strong></p><p><img src="/../../../../images/clip_image024.png" alt="img"></p><p><strong>-rw-r–r–</strong></p><p><strong>第一位文件类型: -</strong></p><p><strong>普通文件，d目录，l软链接，b块设备，</strong></p><p><strong>c****字符设备，p管道，s  socket</strong></p><p><strong>剩下九位表示文件权限:</strong></p><p><strong>分三组(所属用户(u),所属组(g),其他用户(o))  u-user，g-group，o-other</strong></p><p><strong>每组三个字符代表权限</strong></p><p><strong>修改文件的的身份</strong></p><p><strong>修改文件所属者：chown</strong></p><p><img src="/../../../../images/clip_image026-17172997028496.jpg" alt="img"></p><p><strong>修改文件所属组：chown 或者 chgrp</strong></p><p><img src="/../../../../images/clip_image028-17172997028498.jpg" alt="img"></p><p><strong>修改⽂件权限的⽅法</strong></p><p>u所有者 g所属组 o其他人，a所有人</p><p>读(read)：r，4   写(write)：w，2  执行：x，1</p><p>设置文件权限</p><p><img src="/../../../../images/clip_image030-17172997028497.jpg" alt="img"></p><p><strong>减少文件权限</strong></p><p><img src="/../../../../images/clip_image032-17172997028499.jpg" alt="img"></p><p><strong>给所有的身份添加&#x2F;去除权限</strong></p><p><img src="/../../../../images/clip_image034-171729970284910.jpg" alt="img"></p><p><strong>数字表示法：r(4) w(2) x(1)</strong></p><p><img src="/../../../../images/clip_image035.png" alt="img"></p><p><strong>特殊权限</strong></p><p>SUID（4 他只对⼆进制⽂件有效）、SGID（2 针对⽬录）、STICKY（1 针对⽬录）</p><p><img src="/../../../../images/clip_image037-171729970285011.jpg" alt="img"></p><p><strong>注意：对root无效</strong></p><p><strong>SUID</strong></p><p><strong>只对二进制文件有效</strong></p><p><strong>效果：能够使得所有人能够以文件的用户身份执行</strong></p><p><strong>例如:&#x2F;etc&#x2F;shadow,只能root能够cat打开,如果给cat的执行文件添加s权限，那么所有用户，可以利用cat打开shadow文件，但其他命令不能,例如tail、head等</strong></p><p><strong>注意：如果文件自身没有可执行权限，那么suid就是大写的，但效果一样</strong></p><p><img src="/../../../../images/clip_image039-171729970285012.jpg" alt="img"><img src="/../../../../images/clip_image041-171729970285013.jpg" alt="img"></p><p><img src="/../../../../images/clip_image043-171729970285015.jpg" alt="img"><img src="/../../../../images/clip_image045-171729970285014.jpg" alt="img"> </p><p><strong>s权限借的是所有者的身份，sudo获取的是root的特权</strong></p><p><strong>sgid(g+s)</strong></p><p><strong>所属组自动设置为上级目录的所属组</strong></p><p><strong>效果：设置g+s后，t1目录的所属组是test1，root用户在t1里面创建文件，其文件的所属者和所属组分别是：root:test1</strong></p><p><strong><img src="/../../../../images/clip_image047.png" alt="img"></strong> <strong><img src="/../../../../images/clip_image049-171729970285016.png" alt="img"></strong></p><p><strong>sticky****权限(o+t)</strong></p><p><strong>作用：在这个目录下，不能删除其他用户拥有的文件或目录，也无法强制强制保持其他用户所拥有的文件(包括其他用户拥有的目录下创建文件)</strong></p><p><strong>注意：sticky控制的是所有者，尽管该文件属组是t1，而用户t1的组是t1，也无法进行删除等操作</strong></p><p><strong><img src="/../../../../images/clip_image051-171729970285017.png" alt="img"></strong><img src="/../../../../images/clip_image053-171729970285018.jpg" alt="img"></p><p>**<br>**</p><p><strong>attr****权限</strong></p><p><strong>常用参数：</strong></p><p>**+I,**<strong>文件不可删除，不可追加，不可写入</strong></p><p><strong>+a, 文件变成只可追加写入，不可删除，不可覆盖写入</strong></p><p><strong>作用：添加若干特殊权限，包括root也受限。</strong></p><p><strong>一般适应范围：用于保护日志等文件不被破坏</strong></p><p><img src="/../../../../images/clip_image055-171729970285019.jpg" alt="img"></p><p><strong>文件默认权限</strong></p><p><strong>文件的默认满权限：666，目录的满权限：777</strong></p><p><strong>默认情况下：</strong></p><p>**umask(UID&gt;199)**<strong>：002</strong></p><p>**umask(UID&lt;199)**<strong>：022</strong></p><p><strong>可以修改默认umask，vim &#x2F;etc&#x2F;bashrc</strong></p><p><img src="/../../../../images/clip_image057-171729970285020.jpg" alt="img"></p><p><strong>&#x2F;etc&#x2F;profile****、&#x2F;etc&#x2F;bashrc    系统级，是系统全局环境变量设定</strong></p><p><strong><del>&#x2F;.profile****、</del>&#x2F;.bashrc       用户级，当前目录下的私有环境变量设定</strong></p><p><strong>当登录系统时候会获得一个shell进程时，其读取环境设定档，以下流程：</strong></p><p><strong><img src="/../../../../images/clip_image059-171729970285021.png" alt="img"></strong></p><p><strong><del>&#x2F;.profile****与</del>&#x2F;.bashrc的区别</strong></p><p><strong>~&#x2F;.profile****可以设定本用户专有路径,环境变量等，它只能登入的时候执行一次</strong></p><p><strong>~&#x2F;.bashrc****也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次，bashrc文件智慧对指定的shell类型起作用，bashrc值会被bash shell调用</strong></p><p>bashrc文件就像是一个个性化的“设置清单”，它存储了用户特定的配置信息，比如用户经常使用的命令、别名、函数等。这些信息是在用户登录后会被加载并应用的，让用户能够更方便地使用计算机。比如，用户可以在.bashrc文件中定义一些自定义的命令别名，这样就可以用更简短的命令来完成复杂的操作。</p><p>而.profile文件则像是系统的“环境配置文件”，它在用户登录时被读取和执行，用来设置系统范围内的环境变量和执行一些初始化命令。这些环境变量和初始化命令会影响所有登录到系统的用户。比如，在.profile文件中可以设置系统的PATH环境变量，这样用户在任何地方都能够使用系统中的命令。</p><p><strong>ACL</strong></p><p><strong>这个与⽂件系统有关系,xfs的⽂件系统默认⽀持，他可以针对⽤⼾个⽤⼾组进⾏赋权，但是不会影响到原始⽂件的权限</strong></p><p><strong>setfacl -m u:student:rwx &#x2F;root &#x2F;给student用户添 加&#x2F;root目录的读写进入权限</strong></p><p><strong>getfacl  查看目录权限</strong></p><p><strong>setfacl -b &#x2F;root 删除该&#x2F;root目录的全部acl参数</strong></p><p><img src="/../../../../images/clip_image061-171729970285022.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 用户权限&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户：⽤⼾账⼾为不同⼈员和运⾏的程序之间提供安全边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户账户有三种主要类型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;超级用户(root)、系统用户(由系统分配,不可交互登录</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>系统目录-语法</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95-%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95-%E8%AF%AD%E6%B3%95/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:13:22.762Z</updated>
    
    <content type="html"><![CDATA[<p>Linux–&gt;原名：GNU&#x2F;Linux</p><p>Fedora—社区版的Linux系统，每六个月更新一次，不适合企业，稳定性不够</p><p>EPEL是Fedora的一个软件仓库源</p><p>Linux系统是基于Core(内核)，而使用者不能直接操作内核，必须要通过一个”中间层”而间接操作内核，这个中间层叫做”Shell(命令解释器)”</p><p>Linux命令行由Shell程序提供的</p><p>redhat9默认Shell类型：Bash</p><p>总而言之，我们所学的命令，其实是学习Shell的语法</p><p>-—————————————————–</p><p>[用户名@主机名 所在路径]  </p><p>$-普通用户，#-超级用户(root)</p><p>ctrl+alt+F1-F6进行console切换(tty1-tty6)，切换虚拟终端</p><p>在redhat9，在有图形环境，将在tty1中运行</p><p>远程访问方式：</p><p>①ssh <a href="mailto:root@192.168.66.66">root@192.168.66.66</a>  &#x2F;&#x2F;用户+IP地址</p><p>②ssh <a href="mailto:root@www.test.com">root@www.test.com</a>  &#x2F;&#x2F;用户+域名</p><p>关机&#x2F;重启</p><p>poweroff&#x2F;reboot  init 0&#x2F;init 6</p><p>一行执行多条命令用”;(分号)”隔开</p><p>例如：touch file1; vim file1</p><p>&amp;&amp;  第一个命令执行成功，后面的命令才能执行</p><p><img src="/../../../../images/clip_image002.gif" alt="img"></p><p>|| 第一个命令执行失败，后面的命令才能执行</p><p><img src="/../../../../images/clip_image004.gif" alt="img"></p><p>date显示时间类型</p><p><img src="/../../../../images/clip_image006.gif" alt="img"></p><p>file 显示文件类型</p><p><img src="/../../../../images/clip_image008.gif" alt="img"></p><p>注意：Linux中，文件的后缀名无法表述文件类型的归属，例如exe,py.excel等等</p><p>常用查看文件内容</p><p>cat、head、tail、less</p><p>cat：查看一个或多个文件内容，还可以将内容重定向到新文件</p><p>less：一次只显示一页内容，可滚动</p><p>head 和 tail：显示文件首或尾10行，-n 选项可以指定显示的行数</p><p><img src="/../../../../images/clip_image010.gif" alt="img"></p><p>注意：tail -f 实现实时监控文件</p><p>wc </p><p>计算文件中行,字数,字符数,具有-l,-w,-c选项,分别显示行数,字数,字符数</p><p><img src="/../../../../images/clip_image012.gif" alt="img"></p><p>如果系统中，Tab补全失败，则该安装bash-completion</p><p><img src="/../../../../images/clip_image014.gif" alt="img"></p><p>在多行上编写长命令：</p><p>命令太长，为提高可读性，可用‘\’命令多行显示</p><p><img src="/../../../../images/clip_image016.gif" alt="img"></p><p>history 显示之前执行命令的列表，带有编号</p><p>!number 执行指定编号的命令</p><p><img src="/../../../../images/clip_image018.gif" alt="img"></p><p>如果shell终端关闭，系统会记录一些文件(.bash_history)</p><p><img src="/../../../../images/clip_image020.gif" alt="img"></p><p>命令行的快捷键</p><p>Ctrl+A   跳到命令行的开头</p><p>Ctrl+E   跳到命令行的末尾</p><p>Ctrl+U   将光标到命令行开头的内容清除</p><p>Ctrl+K   将光标到命令行末尾的内容清除</p><p>Linux重要目录</p><pre><code class="perl">/boot   开始启动过程所需要的文件/dev    供系统用于访问硬件的特殊设备文件/etc    特定于系统的配置文件/home   普通用户的家目录/root   root的主目录/lib64   保存系统的64位动态库文件/lib    系统的32位库/mnt    临时挂载点/proc   系统开机后运行的服务进程会映射到这个目录里面(目录名是数字，代表进程)/run    内存的一些映射关系/tmp    临时文件的存储/var    日志、计划任务等相关文件/sbin   只有root能够执行的命令/bin    命令的二进制文件/dev    设备文件的保存位置/media   媒体设备/挂载点/opt    第三方应用安装的目录/sys    驱动文件的保存/usr    安装的软件、共享的库等文件pwd  查看当前目录</code></pre><p>cd 切换目录</p><p>cd - 回到之前一个目录</p><p>cd .. 进入父目录(上一级目录)</p><p>cd ~  进入家目录</p><p>ls -l（⻓列出格式）、-a（显示隐藏文件）、-R（递归方式，包含所 有子目录的内容）</p><p><img src="/../../../../images/clip_image022.gif" alt="img"></p><p>注意：文件名的第一个带”.” 代表隐藏文件 ，ls -a才能显示出来</p><p>文件格式：</p><p>文件类型-文件权限-链接数-文件的所有者-文件的所属组-文件的大小–文件的创建&#x2F;修改时间-文件名</p><p>文件类型：</p><p>-  文件  d  目录  s  套接字文件进程间通信  p  管道文件</p><p>c  字符设备io   c  字符设备    b  块设备文件磁盘</p><p><img src="/../../../../images/clip_image024.gif" alt="img"></p><p>文件的权限：</p><p>r  读   4</p><p>w  写   2</p><p>x  执行  1</p><p><img src="/../../../../images/clip_image026.gif" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux–&amp;gt;原名：GNU&amp;#x2F;Linux&lt;/p&gt;
&lt;p&gt;Fedora—社区版的Linux系统，每六个月更新一次，不适合企业，稳定性不够&lt;/p&gt;
&lt;p&gt;EPEL是Fedora的一个软件仓库源&lt;/p&gt;
&lt;p&gt;Linux系统是基于Core(内核)，而使用者不能直接操</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>脚本-三剑客</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%84%9A%E6%9C%AC-%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%84%9A%E6%9C%AC-%E4%B8%89%E5%89%91%E5%AE%A2/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:32:04.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><h2 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h2><p>vi&#x2F;vim等⽂本编辑器，创建打开⼀个⽂件。这个⽂件的命名没有强制要求，但是建议 以.sh结尾，⽤来提⽰⼀下这是个脚本⽂件。</p><p>在⽂件内部需要以#!&#x2F;bin&#x2F;bash，#！⽤来指定脚本的解释器的作⽤，也可以调⽤shell的 内置命令，这样的话才能保证它是⼀个脚本，⽽不是⼀堆命令的集合。</p><p>shell脚本⽂件#后⾯的内容不会被解释器解析，会以注释的⽅式⽤作提⽰作⽤</p><p>#一个简单的脚本</p><p><img src="/../../../../images/clip_image002-17172991055811.jpg" alt="img"></p><h2 id="脚本的执行方式"><a href="#脚本的执行方式" class="headerlink" title="脚本的执行方式"></a>脚本的执行方式</h2><p>bash 或者 sh + 脚本的方式执行，把脚本当作参数,交给bash或者解释器执行</p><p><img src="/../../../../images/clip_image003.png" alt="img"></p><p>. 或者 source +脚本的方式执行，把脚本交给.</p><p><img src="/../../../../images/clip_image004-17172991055812.png" alt="img"></p><p>. hello.sh没有x权限也可以。 . 代表当前shell终端，它只把程序交给 当前shell进程，shell进程创建一个子进程，然后把test.sh作为参数传给进程里面去执行</p><p>脚本赋予可执⾏权限后再去执⾏(推荐使⽤这种⽅式，运⾏shell脚本)</p><p><img src="/../../../../images/clip_image006-17172991055813.jpg" alt="img"></p><h2 id="shell脚本中的变量"><a href="#shell脚本中的变量" class="headerlink" title="shell脚本中的变量"></a>shell脚本中的变量</h2><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>变量名的规则：只能包含数字，字⺟、_，并且不能以数字开头</p><p>变量的赋值通过变量名&#x3D;变量值的⽅式进⾏操作，&#x3D;两边不能有空格的存在，否则他会把值或者变量名识别成为命令， 导致出现command not found错误。$+变量名可以解析读取变量的值。</p><p><img src="/../../../../images/clip_image008-17172991055824.jpg" alt="img"></p><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p><img src="/../../../../images/clip_image010-17172991055825.jpg" alt="img"></p><p>$* 和 $@区别</p><p>$*， 它会把所有的命令行参数当作一个整体对待，无论参数中是否有空格或引号，都会被连接成一个字符串</p><p>$@，它会把每个命令行参数都当作独立的单词，保留空格和引号</p><p>运行脚本时输入了 .&#x2F;script.sh arg1 “arg 2” arg3</p><p>使用 $* 会得到一个字符串：”arg1 arg 2 arg3”</p><p>使用 $@ 会得到三个独立的单词：”arg1”，”arg 2”，和 “arg3”。</p><p><img src="/../../../../images/clip_image012-17172991055826.jpg" alt="img"></p><p><img src="/../../../../images/clip_image014-17172991055827.jpg" alt="img"></p><p>$?存在两种情况，0(代表前面的命令执行成功了)或者非0（代表前面的命令执行失败）</p><p><img src="/../../../../images/clip_image016-17172991055828.jpg" alt="img"></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>用户的某种特殊属性，它的有效范围是全局范围有效，环境变量⼀般使⽤⼤写字⺟命名，可以使⽤env或者printenv命令读取出所有的环境变量</p><p><img src="/../../../../images/clip_image018-17172991055829.jpg" alt="img"></p><h3 id="系统环境变量的配置文件"><a href="#系统环境变量的配置文件" class="headerlink" title="系统环境变量的配置文件"></a>系统环境变量的配置文件</h3><p><img src="/../../../../images/clip_image020-171729910558210.jpg" alt="img"></p><h3 id="export将普通变量提升为环境变量"><a href="#export将普通变量提升为环境变量" class="headerlink" title="export将普通变量提升为环境变量"></a>export将普通变量提升为环境变量</h3><p><img src="/../../../../images/clip_image022-171729910558211.jpg" alt="img"></p><h3 id="shell脚本⾥⾯的⼀些特殊的符号"><a href="#shell脚本⾥⾯的⼀些特殊的符号" class="headerlink" title="shell脚本⾥⾯的⼀些特殊的符号"></a>shell脚本⾥⾯的⼀些特殊的符号</h3><p>‘’(单引号)、””(双引号)、&#96;&#96;(反引号)、(反斜杠)、|(管道)、1&gt;&gt;、2&gt;&gt;、1&gt;、2&gt;</p><p><img src="/../../../../images/clip_image024-171729910558212.jpg" alt="img"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>test命令或者[ ]，可以⽤来进⾏条件判断，[]这个需要在中括号和条件表达式之间都存在⼀个空格</p><p>⽂档类型的测试</p><p><img src="/../../../../images/clip_image026-171729910558213.jpg" alt="img"></p><p><img src="/../../../../images/clip_image028-171729910558214.jpg" alt="img"></p><h3 id="测试⽂件的权限"><a href="#测试⽂件的权限" class="headerlink" title="测试⽂件的权限"></a>测试⽂件的权限</h3><p><img src="/../../../../images/clip_image030-171729910558215.jpg" alt="img"></p><p><img src="/../../../../images/clip_image031-171729910558216.png" alt="img"></p><h3 id="测试字符串-随便看看"><a href="#测试字符串-随便看看" class="headerlink" title="测试字符串(随便看看)"></a>测试字符串(随便看看)</h3><p><img src="/../../../../images/clip_image033-171729910558217.jpg" alt="img"></p><p>使⽤test命令对字符串的操作只有判断测试的字符串是否为空以及字符串是否是某个值。 对于n 选项来说，都是判断字符串是否为空，如果字符串为空，那么test命令就会返回逻辑假的 值。 如果字符串不为空，就返回逻辑真的值。⽽对于选项-z来说，返回的结果和-n选项正好相 反。 对于相同符号“&#x3D;”和不相同符号“！&#x3D;”来说，只要是符号左右两边的字符串相同（或不 同），那么就返回逻辑真（假）的结果。</p><h3 id="测试数值"><a href="#测试数值" class="headerlink" title="测试数值"></a>测试数值</h3><p><img src="/../../../../images/clip_image035-171729910558218.jpg" alt="img"><img src="/../../../../images/clip_image037-171729910558219.jpg" alt="img"></p><p><img src="/../../../../images/clip_image039-171729910558220.jpg" alt="img"></p><h3 id="复合测试条件"><a href="#复合测试条件" class="headerlink" title="复合测试条件"></a>复合测试条件</h3><p><img src="/../../../../images/clip_image041-171729910558221.jpg" alt="img"></p><p><img src="/../../../../images/clip_image043-171729910558222.jpg" alt="img"></p><h3 id="单分支-if-then结构"><a href="#单分支-if-then结构" class="headerlink" title="单分支(if-then结构)"></a>单分支(if-then结构)</h3><p>#结构：&#x2F;&#x2F;这个结构要完整，有开始有结束，否则会报语法错误</p><p><img src="/../../../../images/clip_image044.png" alt="img"></p><h3 id="多分⽀（if-then-else）"><a href="#多分⽀（if-then-else）" class="headerlink" title="多分⽀（if-then-else）"></a>多分⽀（if-then-else）</h3><p><img src="/../../../../images/clip_image046-171729910558223.jpg" alt="img"></p><h3 id="case结构基础（选择菜单）"><a href="#case结构基础（选择菜单）" class="headerlink" title="case结构基础（选择菜单）"></a>case结构基础（选择菜单）</h3><p><img src="/../../../../images/clip_image048.jpg" alt="img"></p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><img src="/../../../../images/clip_image049.png" alt="img"></p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><img src="/../../../../images/clip_image051-171729910558224.jpg" alt="img"></p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>跳出符合条件的循环以及后续的循环</p><p><img src="/../../../../images/clip_image053-171729910558225.jpg" alt="img"></p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>符合条件的退出，继续执⾏剩下的循环</p><p><img src="/../../../../images/clip_image054.png" alt="img"></p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="正则表达式的含义："><a href="#正则表达式的含义：" class="headerlink" title="正则表达式的含义："></a>正则表达式的含义：</h2><p>正则表达式（Regular Expression）就是使⽤简单的字符按照预先设定的规则来完成复杂的功能。</p><p>正则表达式⼀般是由普通字符以及特殊字符组成的字符串。</p><p>正则表达式的组成可以是单个的字符、字符集合、字符范围、字符 间的选择 或者是这些字符之间的任意组合。</p><h2 id="正则表达式分类："><a href="#正则表达式分类：" class="headerlink" title="正则表达式分类："></a>正则表达式分类：</h2><p>posix⻛格的正则表达式  pcre⻛格的正则表达式</p><p>基本正则表达式 扩展正则表达式</p><p>注：不同类型的正则表达式，能够兼容的⽂本处理⼯具也会有差异，正则表达式，由普通的⽂ 本字符（a-zA-Z0-9）和具有特殊功能的字符（元字符）</p><h2 id="部分元字符的功能"><a href="#部分元字符的功能" class="headerlink" title="部分元字符的功能"></a>部分元字符的功能</h2><p>点（.），含义是表示有且只有一个任意字符</p><p><img src="/../../../../images/clip_image056.jpg" alt="img"></p><p>#[ ] 含义是：一个中括号只表示一个字符，中括号里面的内容表示其中一个字符</p><p><img src="/../../../../images/clip_image058.jpg" alt="img"></p><p>^含义是： 排除^后面的字符，就符合匹配规则</p><p><img src="/../../../../images/clip_image059.png" alt="img"></p><h2 id="次数匹配"><a href="#次数匹配" class="headerlink" title="次数匹配"></a>次数匹配</h2><p>?表示？号前面的字符只有一个或零个</p><p><img src="/../../../../images/clip_image061-171729910558226.jpg" alt="img"></p><p>*表示匹配它前面的字符0次或者若干次</p><p><img src="/../../../../images/clip_image063-171729910558227.jpg" alt="img"></p><p>+含义是匹配前面的字符至少1次</p><p><img src="/../../../../images/clip_image064.png" alt="img"></p><p>{ } 表示前面的字符重复的次数</p><p><img src="/../../../../images/clip_image066.jpg" alt="img"></p><h2 id="位置锚定"><a href="#位置锚定" class="headerlink" title="位置锚定"></a>位置锚定</h2><p>^表示以后面的字符开头</p><p><img src="/../../../../images/clip_image067.png" alt="img"></p><p>$表示结尾</p><p><img src="/../../../../images/clip_image068-171729910558228.png" alt="img"></p><p>&lt; 或 \b 匹配一个单词的首部</p><p><img src="/../../../../images/clip_image069.png" alt="img"></p><p>&gt; 或 \b 定位的是一个单词的尾部</p><p><img src="/../../../../images/clip_image070.png" alt="img"></p><p>匹配文件里面的空行</p><p><img src="/../../../../images/clip_image071.png" alt="img"></p><h2 id="分组（）"><a href="#分组（）" class="headerlink" title="分组（）"></a>分组（）</h2><p>会将括号内的部分作为⼀个整体进⾏匹配，⽽不是单个字符进⾏匹配</p><p><img src="/../../../../images/clip_image073.jpg" alt="img"></p><h2 id="分⽀-表⽰或的关系"><a href="#分⽀-表⽰或的关系" class="headerlink" title="分⽀ | 表⽰或的关系"></a>分⽀ | 表⽰或的关系</h2><p><img src="/../../../../images/clip_image075-171729910558329.jpg" alt="img"></p><h2 id="贪婪匹配和懒惰匹配"><a href="#贪婪匹配和懒惰匹配" class="headerlink" title="贪婪匹配和懒惰匹配"></a>贪婪匹配和懒惰匹配</h2><p>默认，正则表达式和扩展正则表达式，是贪婪的，最⻓匹配。 PERL正则表达式，可在量 词后⾯直接加上⼀个问号（?），实现懒惰匹配，最短匹配 （？实现懒惰匹配，只适合 PCRE，不适合POSIX标准正则表达式）</p><p>贪婪模式（尽可能多的匹配）</p><p><img src="/../../../../images/clip_image077-171729910558330.jpg" alt="img"></p><p>懒惰模式（尽可能少的匹 配）</p><p><img src="/../../../../images/clip_image078-171729910558332.png" alt="img"></p><h1 id="⽂本处理的⼀些常⽤⼯具"><a href="#⽂本处理的⼀些常⽤⼯具" class="headerlink" title="⽂本处理的⼀些常⽤⼯具"></a>⽂本处理的⼀些常⽤⼯具</h1><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>⾏⽂本匹配⼯具，以⾏为单位，查找匹配的内容</p><p><img src="/../../../../images/clip_image080-171729910558331.jpg" alt="img"></p><p><img src="/../../../../images/clip_image082-171729910558333.jpg" alt="img"></p><p><img src="/../../../../images/clip_image084.jpg" alt="img"><img src="/../../../../images/clip_image086.jpg" alt="img"></p><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>可以查找和编辑⽂件的内容，它时按照流的⽅式，以⾏为单位进⾏匹配，取⼀⾏内容到sed缓 存⾥⾯，处理完毕后显⽰处理结果，并将下⼀⾏内容读取到缓存⾥⾯，以此⼀直到将整个⽂件 的所有⾏全部处理完毕，相⽐较vim这样的⼯具他的执⾏效率更⾼⼀些。</p><h3 id="处理流程："><a href="#处理流程：" class="headerlink" title="处理流程："></a>处理流程：</h3><p><img src="/../../../../images/clip_image088.jpg" alt="img"></p><p>它默认情况下不会直接修改原⽂件，修改的只是缓存⾥⾯的内容，要想直接修改原⽂件，需要 加选项-i</p><h3 id="sed常用的命令"><a href="#sed常用的命令" class="headerlink" title="sed常用的命令"></a>sed常用的命令</h3><p><img src="/../../../../images/clip_image090.jpg" alt="img"></p><h3 id="常用的选项"><a href="#常用的选项" class="headerlink" title="常用的选项"></a>常用的选项</h3><p><img src="/../../../../images/clip_image092.jpg" alt="img"></p><p>打印第二行，第三行</p><p><img src="/../../../../images/clip_image094.jpg" alt="img"></p><p>#如果不想让他显示未被匹配的内容可以使用-n选项</p><p><img src="/../../../../images/clip_image095.png" alt="img"></p><p>#打印This 开头的行</p><p><img src="/../../../../images/clip_image096.png" alt="img"></p><p>##打印除前四行以外的其他行，不知道一共有多少行，可以用 ！反选</p><p><img src="/../../../../images/clip_image097.png" alt="img"></p><p>#打印第一行到匹配到 third 的行</p><p><img src="/../../../../images/clip_image099-171729910558334.jpg" alt="img"></p><p>#插入：a 命令和 i 命令 a 命令和 i 命令的使用方法相同，不同的是 a 命令是在行之后添加内容，i 命令是在行之前插入内容。</p><p>#添加add one 到第一行下面、#添加add two到第一行的上面</p><p><img src="/../../../../images/clip_image101.jpg" alt="img"></p><p>#在第一行之前加 start，在最后一行之后加 end，对单个文件进行多个操作可以用 -e</p><p><img src="/../../../../images/clip_image103-171729910558335.jpg" alt="img"></p><p>#删除二到三行</p><p><img src="/../../../../images/clip_image104.png" alt="img"></p><p>#将第一行替换为“hahahaha”</p><p><img src="/../../../../images/clip_image105.png" alt="img"></p><p>#将全文的 line 替换为 text，不加 g 只替换每一行的第一个 line</p><p><img src="/../../../../images/clip_image107-171729910558336.jpg" alt="img"></p><p>#修改源文件</p><p><img src="/../../../../images/clip_image108.png" alt="img"></p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>是⼀种处理⽂本⽂件的语⾔，是⼀个强⼤的⽂本分析⼯具。 之所以叫 AWK 是因为其取了三位 创始⼈ Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的⾸字符 linux 中有三剑客之称： 三剑客之⾸就是 AWK。</p><h3 id="awk⼯具⼯作的过程"><a href="#awk⼯具⼯作的过程" class="headerlink" title="awk⼯具⼯作的过程"></a>awk⼯具⼯作的过程</h3><p>类似于sed⼯具，都是在⽂件⾥⾯取⼀⾏处理⼀⾏，⼀直到所有的内容处理完毕。</p><p>grep,sed和awk都是读一行处理一行，直到处理完成。 接收一行作为输入 把刚刚读入进来得到文本进行分解 使用处理规则处理文本 输入一行，赋值给$0，直至处理完成 把处理完成之后的所有数据交给END{}来再次处理</p><h3 id="awk⾃⼰的内置变量"><a href="#awk⾃⼰的内置变量" class="headerlink" title="awk⾃⼰的内置变量"></a>awk⾃⼰的内置变量</h3><p>#$0 表示当前行，相当于文档的所有内容, -F是分割，：作为分割符</p><p><img src="/../../../../images/clip_image110.jpg" alt="img"></p><p>#$1表示:分隔的第一个列</p><p><img src="/../../../../images/clip_image112.jpg" alt="img"></p><p>#$2表示:分隔的第二列，以此类推</p><p>#NF: 表示字段数，每一行的字段,例如 root：x：0 字段数为3</p><p>#NR 表示是行号</p><p>#FS : 指定文本内容分隔符(默认是空格) $NF最后一列，$1第一列类似于F选项</p><p><img src="/../../../../images/clip_image114.jpg" alt="img"></p><p>#OFS : 指定打印分隔符(默认空格)</p><p><img src="/../../../../images/clip_image116.jpg" alt="img"></p><h3 id="awk中的定位"><a href="#awk中的定位" class="headerlink" title="awk中的定位"></a>awk中的定位</h3><p>#(awk中匹配有root内容的行)</p><p><img src="/../../../../images/clip_image118.jpg" alt="img"></p><h3 id="⽐较表达式-匹配⽂本之内的内容"><a href="#⽐较表达式-匹配⽂本之内的内容" class="headerlink" title="⽐较表达式(匹配⽂本之内的内容)"></a>⽐较表达式(匹配⽂本之内的内容)</h3><p>&gt; : ⼩于 &lt; : ⼤于 &gt;&#x3D; : ⼤于等于 &lt;&#x3D; : ⼩于等于</p><p>~ : 正则匹配(包含)  !~ : 正则匹配(不包含)</p><p>#要求打印属组ID大于属主ID的行</p><p><img src="/../../../../images/clip_image120.jpg" alt="img"></p><p>#打印结尾包含bash</p><p><img src="/../../../../images/clip_image122.jpg" alt="img"></p><h3 id="条件表达式-⽂本之外的内容"><a href="#条件表达式-⽂本之外的内容" class="headerlink" title="条件表达式(⽂本之外的内容)"></a>条件表达式(⽂本之外的内容)</h3><p>&#x3D;&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D;</p><p>#要求打印第三行</p><p><img src="/../../../../images/clip_image123.png" alt="img"></p><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>&amp;&amp; : 逻辑与  || : 逻辑或 ！ : 逻辑非</p><p>#找到$3+$4 &gt; 2000 且 $3*$4 &gt; 2000</p><p><img src="/../../../../images/clip_image125-171729910558337.jpg" alt="img"></p><p>#找到$3+$4 &gt; 2000 或者 $3*$4 &gt; 2000</p><p><img src="/../../../../images/clip_image127-171729910558338.jpg" alt="img"></p><p>#查找$3 + $4 不大于2000</p><p><img src="/../../../../images/clip_image129-171729910558339.jpg" alt="img"></p><h3 id="算数表达式"><a href="#算数表达式" class="headerlink" title="算数表达式"></a>算数表达式</h3><p>+ :加 - ：减 * ：乘 &#x2F; ：除 % ：求余</p><p>#for每一行打印10次</p><p><img src="/../../../../images/clip_image131.jpg" alt="img"></p><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>分割列，同样是以⼀⾏为单位，⼀次处理⼀⾏，可以指定这个⾏当中的分隔符号，然后输 出⼀ ⾏当中可以被分成的列</p><p>#查看第一字段</p><p><img src="/../../../../images/clip_image132.png" alt="img"></p><p>#先抓取root行，然后通过cut，输出本行以冒号为分隔符的第一列</p><p><img src="/../../../../images/clip_image134.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;脚本&quot;&gt;&lt;a href=&quot;#脚本&quot; class=&quot;headerlink&quot; title=&quot;脚本&quot;&gt;&lt;/a&gt;脚本&lt;/h1&gt;&lt;h2 id=&quot;创建脚本&quot;&gt;&lt;a href=&quot;#创建脚本&quot; class=&quot;headerlink&quot; title=&quot;创建脚本&quot;&gt;&lt;/a&gt;创建脚本&lt;/h</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计划-调优-selinux-磁盘的管理</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%AE%A1%E5%88%92-%E8%B0%83%E4%BC%98-selinux-%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%AE%A1%E5%88%92-%E8%B0%83%E4%BC%98-selinux-%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T04:29:23.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h1><h2 id="一次性的计划任务"><a href="#一次性的计划任务" class="headerlink" title="一次性的计划任务"></a>一次性的计划任务</h2><p>它只⽣效⼀次，任务执⾏完毕后这个任务会⾃动删除。</p><p>由atd服务提供此功能</p><p><img src="/../../../../images/clip_image002-17173002220683.jpg" alt="img"></p><p>#设置一个at计划任务，任务要求从现在1分钟以后，执行echo 123 &gt; &#x2F;tmp&#x2F;at.txt</p><p><img src="/../../../../images/clip_image004-17173002220681.jpg" alt="img"></p><p>#at计划任务会保存在一下位置</p><p><img src="/../../../../images/clip_image006-17173002220682.jpg" alt="img"></p><p>#查看当前存在的at计划任务</p><p><img src="/../../../../images/clip_image007-17173002220684.png" alt="img"></p><p>#通过命令查看当前存在的某个at计划任务的详情</p><p><img src="/../../../../images/clip_image009.jpg" alt="img"></p><p>#删除at计划任务</p><p><img src="/../../../../images/clip_image011.jpg" alt="img"></p><h2 id="周期性的计划任务"><a href="#周期性的计划任务" class="headerlink" title="周期性的计划任务"></a>周期性的计划任务</h2><p><img src="/../../../../images/clip_image013.jpg" alt="img"></p><h3 id="服务的配置文件"><a href="#服务的配置文件" class="headerlink" title="服务的配置文件"></a>服务的配置文件</h3><p><img src="/../../../../images/clip_image015.jpg" alt="img"></p><p><img src="/../../../../images/clip_image017.jpg" alt="img"></p><p>使⽤*&#x2F;数字，描述的时”每”的含义。例如：*&#x2F;2 * * * *表示每小时的每两分钟</p><p>使⽤x-y替代*,表⽰的是⼀个时间段。例如：* 9-14 * * *表示每天的9点到14点</p><p>使⽤，分割不连续的时间。例如：* * 1，4，12 * *表示每个月的1,4,12号</p><p>注意，02 * * * *表示每小时的02分，不是每隔两分钟</p><p><img src="/../../../../images/clip_image019.jpg" alt="img"></p><p>root⽤⼾可以为普通⽤⼾设置周期计划任务，普通⽤⼾只能给⾃⼰设置周期计划任务</p><h3 id="使⽤命令⾏设置周期性计划任务"><a href="#使⽤命令⾏设置周期性计划任务" class="headerlink" title="使⽤命令⾏设置周期性计划任务"></a>使⽤命令⾏设置周期性计划任务</h3><p><img src="/../../../../images/clip_image021-17173002220695.jpg" alt="img"></p><p>#设置计划任务给student，执行每分钟往&#x2F;tmp&#x2F;cron.txt文件追加写入hello任务</p><p><img src="/../../../../images/clip_image023-17173002220696.jpg" alt="img"></p><h3 id="使⽤配置文件设置周期性计划任务"><a href="#使⽤配置文件设置周期性计划任务" class="headerlink" title="使⽤配置文件设置周期性计划任务"></a>使⽤配置文件设置周期性计划任务</h3><p>&#x2F;etc&#x2F;crontab和&#x2F;etc&#x2F;cron.d中是系统级别的cron任务，可能需要root用户权限</p><p><img src="/../../../../images/clip_image025-17173002220697.jpg" alt="img"></p><p><img src="/../../../../images/clip_image027-17173002220698.jpg" alt="img"></p><p>&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.hourly、 &#x2F;etc&#x2F;cron.monthly、&#x2F;etc&#x2F;cron.weekly</p><p>分别代表每天、每小时、每月、每周的计划任务，可以根据需要执行脚本，注意权限问题，如果在计划任务执行脚本，需要添加+x权限等等</p><p><img src="/../../../../images/clip_image029-17173002220699.jpg" alt="img"></p><h3 id="删除计划任务"><a href="#删除计划任务" class="headerlink" title="删除计划任务"></a>删除计划任务</h3><p><img src="/../../../../images/clip_image031-171730022206910.jpg" alt="img"></p><h2 id="systemd的计划任务"><a href="#systemd的计划任务" class="headerlink" title="systemd的计划任务"></a>systemd的计划任务</h2><p><img src="/../../../../images/clip_image033-171730022206911.jpg" alt="img"></p><p><img src="/../../../../images/clip_image035-171730022206912.jpg" alt="img"></p><p><img src="/../../../../images/clip_image037-171730022206913.jpg" alt="img"></p><h1 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h1><p><img src="/../../../../images/clip_image039-171730022206914.jpg" alt="img"></p><p><img src="/../../../../images/clip_image041-171730022206915.jpg" alt="img"></p><p>tuned-adm提供了一系列的调优模板</p><p><img src="/../../../../images/clip_image043-171730022206916.jpg" alt="img"></p><p>常⽤选项</p><p>active show active profile &#x2F;&#x2F;查看当前激活的调优模板名 profile switch to a given profile, or list available &#x2F;&#x2F;⽤来设置调优模板</p><p>recommend，recommend profile &#x2F;&#x2F;根据系统的情况，tuned服务推荐的调优模板</p><h3 id="查看系统内的所有可⽤的调优模板"><a href="#查看系统内的所有可⽤的调优模板" class="headerlink" title="查看系统内的所有可⽤的调优模板"></a>查看系统内的所有可⽤的调优模板</h3><p><img src="/../../../../images/clip_image045-171730022206918.jpg" alt="img"></p><p>其所有可用的调优模板对应的用途</p><p><img src="/../../../../images/clip_image047-171730022206917.jpg" alt="img"></p><p><img src="/../../../../images/clip_image049-171730022206919.jpg" alt="img"></p><p>配置文件目录：&#x2F;etc&#x2F;tuned&#x2F;</p><h1 id="selinux"><a href="#selinux" class="headerlink" title="selinux"></a>selinux</h1><p>加强版本的安全linux,就是在传统的linux权限的基础之上，⼜添加了⼀个安全的权限验证层， 进程访问系统内的⽂件，⾸先进⾏传统权限的验证，通过之后，还需要通过selinux安全系统的 附加验证，同时通过才能正常访问，否则会被拒绝访问，selinx是内核功能，默认是安装好 的，它本⾝是⼀些策略，为了简化使⽤，它提供了⼀些⼯具来操作selinux的权限。</p><h2 id="配置⽂件："><a href="#配置⽂件：" class="headerlink" title="配置⽂件："></a>配置⽂件：</h2><p><img src="/../../../../images/clip_image051-171730022206920.jpg" alt="img"></p><h2 id="查看selinux的标签"><a href="#查看selinux的标签" class="headerlink" title="查看selinux的标签"></a>查看selinux的标签</h2><p>系统会根据进程层面的selinux标签(httpd)，就能够访问带有httpd标签的相关文件</p><p>系统会根据进程的selinux标签进行匹配，进程访问目录或文件会根据自己的selinux标签与目录的selinux的标签，如果能够匹配，就能够访问，如果不能匹配 ，就不能够访问，即使是root用户也不能够访问</p><p>#查看文件的selinux标签</p><p><img src="/../../../../images/clip_image053.png" alt="img"></p><p>#查看目录的selinux标签</p><p><img src="/../../../../images/clip_image055.png" alt="img"></p><p>#查看进程的selinux标签</p><p><img src="/../../../../images/clip_image057.png" alt="img"></p><p>能够访问&#x2F;var&#x2F;www&#x2F;html目录，其目录下。index1和2都能访问，index3不能访问 ，其标签导致不能访问。</p><p>#selinux将系统内的所有资源文件、目录、端口等都打上selinux的标签，进程访问文 件，目录的时候会进行标签匹配，通过允许访问，不通过拒绝访问。要在selinux的状态 是enforcing的状态</p><h2 id="命令⾏设置selinux的状态"><a href="#命令⾏设置selinux的状态" class="headerlink" title="命令⾏设置selinux的状态"></a>命令⾏设置selinux的状态</h2><p><img src="/../../../../images/clip_image059-171730022206921.jpg" alt="img"></p><h2 id="修改selinux的标签"><a href="#修改selinux的标签" class="headerlink" title="修改selinux的标签"></a>修改selinux的标签</h2><p><img src="/../../../../images/clip_image061-171730022206922.jpg" alt="img"></p><h2 id="修改selinux标签规则库-推荐"><a href="#修改selinux标签规则库-推荐" class="headerlink" title="修改selinux标签规则库(推荐)"></a>修改selinux标签规则库(推荐)</h2><p><img src="/../../../../images/clip_image063-171730022206923.jpg" alt="img"></p><p>port       Manage network port type definitions</p><p>fcontext    Manage file context mapping definitions</p><p>#添加selinux标签的规则</p><p><img src="/../../../../images/clip_image065-171730022207024.jpg" alt="img"></p><p>#根据seliunx标签库的规则给文件添加标签</p><p><img src="/../../../../images/clip_image067-171730022207026.jpg" alt="img"></p><p>-R：是递归操作。  -v是显示过程</p><h2 id="修改端⼝的selinux标签"><a href="#修改端⼝的selinux标签" class="headerlink" title="修改端⼝的selinux标签"></a>修改端⼝的selinux标签</h2><p><img src="/../../../../images/clip_image069-171730022207025.jpg" alt="img"></p><p>查看服务对应的端口</p><p>lsof -i:端口        lsof -i -P -n |grep 服务名  </p><h2 id="selinux的布尔值"><a href="#selinux的布尔值" class="headerlink" title="selinux的布尔值"></a>selinux的布尔值</h2><p>#查看服务的bool</p><p><img src="/../../../../images/clip_image071.jpg" alt="img"></p><p>#修改服务的selinux bool</p><p><img src="/../../../../images/clip_image073-171730022207028.jpg" alt="img"></p><p>#永久修改selinux bool，查看是否为永久BOOL</p><p><img src="/../../../../images/clip_image075-171730022207029.jpg" alt="img"></p><h2 id="通过cockpit使⽤web界⾯管理selinux"><a href="#通过cockpit使⽤web界⾯管理selinux" class="headerlink" title="通过cockpit使⽤web界⾯管理selinux"></a>通过cockpit使⽤web界⾯管理selinux</h2><h1 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h1><h2 id="对磁盘进⾏分区"><a href="#对磁盘进⾏分区" class="headerlink" title="对磁盘进⾏分区"></a>对磁盘进⾏分区</h2><p>磁盘分区将硬盘驱动器划分为多个逻辑存储单元，这些单元称为分区 系统管理员可以使⽤不同的分区执⾏不同功能</p><h2 id="分区的类型"><a href="#分区的类型" class="headerlink" title="分区的类型"></a>分区的类型</h2><p>MBR:(计较古⽼)</p><p><img src="/../../../../images/clip_image077-171730022207027.jpg" alt="img"></p><p>最多⽀持4个主分区，可以牺牲⼀个主分区，形成15个扩展分区。 MBR类型的任务格式最多⽀持2T的磁盘容量的管理。</p><p>GPT：（⽐较新的分区⽅案）</p><p><img src="/../../../../images/clip_image079.jpg" alt="img"></p><p>最多可以有128个分区 它突破了2T磁盘空间管理的限制</p><h2 id="分区的操作"><a href="#分区的操作" class="headerlink" title="分区的操作"></a>分区的操作</h2><h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk:"></a>fdisk:</h3><p>⽐较久远的⼀个⼯具，优点是他会⾃动计算分区的起始位置，然后操作的过程是在内存⾥⾯， 最后操作完毕，需要保存，否则他的设置不会落盘。</p><p><img src="/../../../../images/clip_image081.jpg" alt="img"></p><h3 id="parted："><a href="#parted：" class="headerlink" title="parted："></a>parted：</h3><p>#显示磁盘的信息</p><p><img src="/../../../../images/clip_image083.jpg" alt="img"></p><p>默认情况下，</p><p>parted 单位是10进制（KB、MB、GB） 10的1， 10的2， 10的3次⽅这样计算的 </p><p>2进制的⽅式（KiB、MiB、GiB） 2的1，2的2，2的3次⽅这样的⽅式计算 </p><p>s 是磁盘的单位叫”扇区” 一般2048s&#x3D;2kb    B表示字节</p><p>#设置磁盘的分区表类型</p><p><img src="/../../../../images/clip_image085-171730022207031.jpg" alt="img"></p><p>#创建一个分区(直接落盘，谨慎操作)</p><p><img src="/../../../../images/clip_image087-171730022207030.jpg" alt="img"></p><p>#删除分区</p><p><img src="/../../../../images/clip_image089-171730022207032.jpg" alt="img"></p><p>#非交互式的磁盘分区操作</p><p><img src="/../../../../images/clip_image091-171730022207033.jpg" alt="img"></p><h2 id="格式化操作："><a href="#格式化操作：" class="headerlink" title="格式化操作："></a>格式化操作：</h2><p><img src="/../../../../images/clip_image093-171730022207034.jpg" alt="img"></p><h2 id="挂载："><a href="#挂载：" class="headerlink" title="挂载："></a>挂载：</h2><h3 id="手动挂载："><a href="#手动挂载：" class="headerlink" title="手动挂载："></a>手动挂载：</h3><p><img src="/../../../../images/clip_image095-171730022207035.jpg" alt="img"></p><h3 id="自动挂载："><a href="#自动挂载：" class="headerlink" title="自动挂载："></a>自动挂载：</h3><p><img src="/../../../../images/clip_image097-171730022207036.jpg" alt="img"></p><h2 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h2><p>虚拟内存，当物理内存不⾜的时候，他会将内存中不常⽤的数据，临死存放在交换分区⾥⾯， 当需要这些数据的时候，会直接读取，⼀定程度上缓解，内存不⾜的问题，但是要彻底解决问题，添加物理内存。</p><p>如果程序启动的内存大于物理内存，那交换分区是起不了作用</p><h3 id="交换分区的推荐⼤⼩"><a href="#交换分区的推荐⼤⼩" class="headerlink" title="交换分区的推荐⼤⼩"></a>交换分区的推荐⼤⼩</h3><p><img src="/../../../../images/clip_image099-171730022207037.jpg" alt="img"></p><p>修改分区类型</p><p><img src="/../../../../images/clip_image101-171730022207038.jpg" alt="img"></p><p>格式化为swap，并进行挂载</p><p><img src="/../../../../images/clip_image103-171730022207039.jpg" alt="img"></p><h3 id="设置-SWAP-分区优先级"><a href="#设置-SWAP-分区优先级" class="headerlink" title="设置 SWAP 分区优先级"></a>设置 SWAP 分区优先级</h3><p>系统默认会按顺序使⽤ swap，即内核先使⽤第⼀个已激活swap，直⾄其空间已满， 然后开始使⽤第⼆个 swap 可以为每个 swap 定义⼀个优先级，从⽽强制按该顺序使⽤swap 可以在 &#x2F;etc&#x2F;fstab 中使⽤ pri 选项，默认优先级是 -2，值越⾼，优先级越⾼ swapon –show 可以显⽰ swap 分区优先级 当 swap 分区具有相同的优先级时，内核会以轮循⽅式向其中写⼊。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计划任务&quot;&gt;&lt;a href=&quot;#计划任务&quot; class=&quot;headerlink&quot; title=&quot;计划任务&quot;&gt;&lt;/a&gt;计划任务&lt;/h1&gt;&lt;h2 id=&quot;一次性的计划任务&quot;&gt;&lt;a href=&quot;#一次性的计划任务&quot; class=&quot;headerlink&quot; title=&quot;一</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>进程工具参数</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%82%E6%95%B0/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%82%E6%95%B0/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:39:54.946Z</updated>
    
    <content type="html"><![CDATA[<p><strong>PS</strong>：列出当前进程</p><p><strong>特点：只是查看某一个时刻的状态，不具有实时性</strong></p><p><strong>三种风格：UNIX、BSD、GNU</strong></p><p><img src="/../../../../images/clip_image002-17172994745881.jpg" alt="img"></p><p>UNIX风格参数：</p><pre><code class="perl">-A 显示所有进程-e 显示所有进程-l 显示长列表-f 显示完整格式的输出-o 自定义输出 例如: ps -o uid.pid.time.time</code></pre><p><img src="/../../../../images/clip_image004-17172994745892.jpg" alt="img"></p><p>名词解释：</p><pre><code class="perl">F:   指内核分配给进程的系统标记。S: 指进程状态(O是正在运行。S是休眠。R是可运行，正等待运行。Z是僵化，进程已结束但父进程已不存在,T是停止)。UID: 指启动这些进程的用户。PID: 是指进程ID。 PPID: 是指：父进程ID（该进程是由另一个进程启动的）。C:  是指进程生命周期中的CUP利用率。 STIME:是指进程启动时的系统时间。TTY: 是指进程启动时的终端设备。TIME: 是指运行进程需要的累计CPU时间。CMD: 是指启动的程序名称。PRT: 是指进程的优先级（越大数字表越低的优先级）。 NT:  是指谦让度值，用来参与决定优先级。 ADDR: 是指进程的内存地址。 SZ:  是指假如进程被换出，所需的交换空间在大致大小。 WCHAN:是指进程休眠的内核函数的地址。</code></pre><p>BSD风格</p><p>r  只显示运行中的进程</p><p>a  显示与任意终点关联的所有进程</p><p>l  采用长模式</p><p><img src="/../../../../images/clip_image006-17172994745894.jpg" alt="img"></p><p>VSZ: 指进程再内存中的大小，单位kb</p><p>RSS: 指进程在未换出时占用的物理内存</p><p>STAT:代表当前进程状态的双字符状态码</p><p>pstree：以树形的结构列出系统内的进程</p><p>top 动态、实时查看系统内的进程状态</p><p><img src="/../../../../images/clip_image008-17172994745893.jpg" alt="img"></p><p><img src="/../../../../images/clip_image010-17172994745895.jpg" alt="img"></p><p>系统的启动时间 系统的状态up 登录系统的⽤⼾数，负载状态（1分钟 5分钟 15分钟）</p><p><img src="/../../../../images/clip_image012-17172994745898.jpg" alt="img"></p><p>任务的总数，运⾏中的任务，休眠中的任务，停⽌状态的任务 僵停状态的任务数</p><p><img src="/../../../../images/clip_image014-17172994745896.jpg" alt="img"></p><p>cpu的使⽤率 ⽤⼾空间的cpu使⽤率 内核空间的cpu使⽤率 nice值 id系统的繁忙状态 IO相关属性</p><p>ni：表示允许低优先级进程的CPU时间比例,负值表示高优先级，正值则相反</p><p><img src="/../../../../images/clip_image016-17172994745897.jpg" alt="img"></p><p>物理内存空间相关的信息 总数 空闲 使⽤数 缓存</p><p><img src="/../../../../images/clip_image018-17172994745899.jpg" alt="img"></p><p>虚拟内存相关的统计数 总数 空闲 使⽤ 可⽤的</p><p><img src="/../../../../images/clip_image020-171729947458910.jpg" alt="img"></p><p>进程的ID ⽤⼾ 优先级 nice 虚拟内存 物理内存 进程的状态 cpu的占⽤率 内存的占⽤率 使⽤的 CPU的时间 进程启动命令名称</p><p>进程状态包括： D &#x3D; 不可中断睡眠 R &#x3D; 运行中或可运行  S &#x3D; 睡眠中</p><p>​             T &#x3D; 已停止或已跟踪   Z &#x3D; 僵停</p><p>P：根据CPU的使用率，降序排列</p><p>M：根据内存的使用率，降序排列</p><p>-d 每n秒查看一次</p><p>-n 最大执行次数</p><p>-p 进程号</p><p><img src="/../../../../images/clip_image022-171729947458912.jpg" alt="img"></p><p>uptime</p><p>查看系统的负载情况，以及系统时间</p><p><img src="/../../../../images/clip_image024-171729947458911.jpg" alt="img"></p><p>vmstat</p><p>查看系统性能的即时系统信息</p><p><img src="/../../../../images/clip_image026-171729947458913.jpg" alt="img"></p><p>free</p><p>查看系统内存使用情况</p><p><img src="/../../../../images/clip_image028-171729947458914.jpg" alt="img"></p><p>默认显示单位:Kb, -m 是Mib，-h是Gid</p><p>作业和会话(job and session)</p><pre><code class="perl">1、job control 是 shell 的⼀种功能，允许单个 shell 实例运⾏和管理多个命令2、⼀个终端同⼀时间只能对⼀个作业发送信号和读取信息，这个作业进程成为前台进程3、可以将作业进程放⼊后台，可以运⾏也可以暂停4、每个 terminal 就是⼀个会话，⾥⾯可能含有⼀个前台进程和任意数量的后台进程。⼀个 作业只能属于⼀个会话5、ps 输出中有些进程由系统启动，不是由 shell 提⽰符启动。这种进程没有 terminal，⽆ 法切换到前台，在 ps 中显⽰为 ？</code></pre><p>后台运行作业</p><p>后台工作：命令 + &amp;</p><p>查看后台作业的ID：jobs</p><p><img src="/../../../../images/clip_image030-171729947458916.jpg" alt="img"></p><p>fg %job id 可将后台作业转⾄前台</p><p><img src="/../../../../images/clip_image031-171729947458915.png" alt="img"></p><p>ctrl+z 可将前台进程放到后台，并暂停运⾏</p><p><img src="/../../../../images/clip_image032-171729947458917.png" alt="img"></p><p>bg %jobid 可以在后台继续运⾏作业</p><p><img src="/../../../../images/clip_image033-171729947458918.png" alt="img"></p><p>nohup</p><p>作用：在后台运行，不受终端挂断的影响</p><p>例如：主机的虚拟主机serverA执行：nohup ping baidu.com &gt; &#x2F;dev&#x2F;null &amp; 如果退出终端，换另一个serverB，serverA的那个任务也不会被影响</p><p>控制进程调度</p><p>1、 通过使⽤称为 time-slicing 或 multitasking 的技术，Linux 和其他操作系统可运⾏超出</p><p>其处理单元数的进程</p><p>2、 操作系统进程调度程序在单个核⼼上的进程之间快速切换，从⽽给⼈⼀种有多个进程 在同时运⾏的印象</p><p>进度优先级：</p><p>可以设置针对不同的进程，采⽤不同的调度策略</p><p>系统上运⾏的⼤多数进程所使⽤的调度策略称为SCHED_OTHER</p><p>(也称为 SCHED_NORMAL), 是Linux默认的调度策略， 其目标是安装进程的优先级和运行</p><p>时间的比例来分配CPU时间，以确保公平性</p><p>可为采⽤ SCHED_NORMAL 策略运⾏的进程指定相对优先级，优先级称为 nice 值</p><p><img src="/../../../../images/clip_image035-171729947458919.jpg" alt="img"></p><p>nice值范围：-20(max)~19(min)</p><p>默认情况下：进程将继承其父进程的nice值，通常为0</p><p>nice 值越⾼，表⽰优先级越低（该进程容易将其 CPU 使⽤量让给其他进程）；nice 值越低，</p><p>表⽰优先级越⾼ （该进程更加不倾向于让出 CPU）</p><p>如果不存在资源争⽤（例如，当活动进程数少于可⽤ CPU 核⼼数时），即使 nice 值 ⾼的</p><p>进程也将仍使⽤尽可能 多 CPU 资源</p><p>设置nice值和权限</p><p>只有root用户可以降低进程的nice值，普通用户的权限仅限于提高自己进程</p><p>的nice值，不能降低自己进程的nice值</p><p><img src="/../../../../images/clip_image037-171729947459022.jpg" alt="img"></p><p>更改现有进程的NICE级别</p><p>1、    renice命令</p><p>2、    top命令，在交互式界面中，按r键访问renice命令,输入pid，nice值</p><p>中断进程(kill)</p><p>使用signals来控制进程</p><p>signals 指的是发给进程的软件中断</p><p>signals 向执⾏中的程序报告事件</p><p>⽣成 signals 的事件可以是错误或者外部事件</p><pre><code class="perl">一些常见的signals：1 HUP 挂起：常⽤来重新加载配置，不是终⽌，与19有区别 2 INT 键盘中断：导致程序终⽌，通过键⼊ ctrl-c发送 3 QUIT 键盘退出：与2类似，在终⽌是发⽣进程转储。输⼊ quit或者 ctrl-\ 发送 9 KILL 中断：⽆法拦截 导致⽴即终⽌进程，最致命 15 TERM 终⽌：（默认） 正常关闭 18 CONT 继续：恢复进程 19 STOP 暂时停⽌：⽆法拦截 20 TSTP 键盘停⽌：通过 ctrl-z 发送，可以被拦截、忽略或处理</code></pre><p>kill(杀死进程)</p><p>kill -l   查看可以发生的signals</p><p>格式：kill -signal PID</p><pre><code class="perl">killall(运行通过进程名字结束进程, 而不是通过PID)格式： killall [选项] 进程名  注意：选项是可选的-i：交互式确认-u：仅终止属于指定用户的进程-e：要求进程名与指定的名称完全匹配，而不是部分匹配例如：killall -u jack httpd  终止所有名为httpd，且用户”jack”的进程</code></pre><p>pkill -SIGKILL -u username 强制中断某⼀⽤⼾的所有进程（注：pkill -9 -u username 也可）</p><p><img src="/../../../../images/clip_image039-171729947458920.jpg" alt="img"></p><p>以管理员⾝份注销⽤⼾</p><p>w命令：显⽰当前登录系统的⽤⼾</p><p><img src="/../../../../images/clip_image041-171729947459021.jpg" alt="img"></p><pre><code class="perl">TTY列：显示用户的位置，pts/N表示图形化终端, ttyN表示文字界面终端FROM列：显示用户来自，:0表示本机JCPU：表示后台程序使用CPU时间PCPU：表示前台程序使用CPU时间所有用户登录会话都与某个终端设备(TTY)相关联。如果设备名称为 pts/N，说明这是一个与图形终端窗口或远程登录会话相关联的伪终端。如果为 ttyN，则说明用户位于一个系统控制台、替代控制台或其他直接连接的终端设备上</code></pre><p>查看终端的名称：tty</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;：列出当前进程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：只是查看某一个时刻的状态，不具有实时性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三种风格：UNIX、BSD、GNU&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:24:54.373Z</updated>
    
    <content type="html"><![CDATA[<p> 进程</p><p><strong>定义：是指正在运行的程序，包括：</strong></p><p><strong>分配的内存地址空间、安全属性、包括所有权和特权、⼀个或多个线程、进程状态</strong></p><p><strong>进程的环境包括：本地和全局变量、当前调度上下****⽂、分配的系统资源，如⽂件和⽹络端⼝</strong></p><p><strong>是当前进程（parent）复制⾃⼰的地址空间 (fork) 来创建⼀个新的（⼦）进程结构，每个进程具PID。</strong></p><p><strong>例子：主机A利用SSH登录，相当于启动了一个进程，这个终端相当于一个父进程(Shell)，</strong></p><p><strong>所有操作都是在这个Shell里面操作，Shell里面执行任务(命令)的过程，首先接触新的任务，然后Shell拷贝一个自己的环境，来接收新的指令，替换到子进程来执行，当子进程执行过程时，父进程处于锁定状态(等待子进程资源的释放。)</strong></p><p><strong>进程状态：</strong></p><pre><code class="perl">运行：R，在运行或者等待运行。睡眠：1、S，等待一个条件的成立(例如passwd，当输入两次密码之间，sleep状态)2、D，不响应信号，相当于windows的死机3、K，允许等待中的任务响应中断(不完全卡死，能够热重启)4、I，接受致命信号(能够强制退出)僵停1、Z，除了进程身份的ID，其他资源已经释放。2、X，已经彻底释放，但是游离存在进程</code></pre><p><strong>注意：</strong>在单 CPU 系统上，⼀次只能运⾏⼀个进程。可以看到多个状态为R 的进程。但是，并⾮ 所有进程都在连续运 ⾏，其中⼀些处于等待状态</p><p>**PS(**<strong>静态查看系统的进程)</strong></p><p><strong>PS命令的三种风格：</strong></p><p><strong><img src="/../../../../images/clip_image002-17172985895591.png" alt="img"></strong></p><p><strong>dash表示：-</strong></p><p><strong>PS****命令列出当前进程，包括：</strong></p><p><strong>运行进程的⽤⼾ UID、进程 PID、CPU 在其上运⾏时间、分配的内存量、进程的 stdout 位置，称为控制终端、当前进程状态</strong></p><p><strong>注意：ps -aux（UNIX 格式） 不等于 ps aux（BSD 格式）</strong></p><p><strong>ps 的常⽤选项是 aux、lax（⻓列表）、-ef，-o(定制ps的输出格式)</strong></p><p><strong><img src="/../../../../images/clip_image004-17172985895602.png" alt="img"></strong></p><p><strong>PPID表示：父进程</strong></p><p><strong>pstree(<strong>以树形的结构列出系统内的进程</strong>)</strong></p><p><img src="/../../../../images/clip_image006.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 进程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义：是指正在运行的程序，包括：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分配的内存地址空间、安全属性、包括所有权和特权、⼀个或多个线程、进程状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程的环境包括：本地和全局变量、</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>逻辑卷-autofs</title>
    <link href="http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E5%8D%B7-autofs/"/>
    <id>http://example.com/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E5%8D%B7-autofs/</id>
    <published>2024-06-01T16:00:00.000Z</published>
    <updated>2024-06-02T03:34:18.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑卷的管理"><a href="#逻辑卷的管理" class="headerlink" title="逻辑卷的管理"></a>逻辑卷的管理</h1><p>物理的存储设备、物理卷、卷组、逻辑卷</p><p>物理卷：是物理的存储设备映射到物理卷</p><p>卷组：多个物理卷的融合，卷组可以动态扩容</p><p>逻辑卷：是卷组中的部分&#x2F;全部。</p><p><img src="/../../../../images/clip_image002-17172992261091.jpg" alt="img"></p><h2 id="实施LVM工作流"><a href="#实施LVM工作流" class="headerlink" title="实施LVM工作流"></a>实施LVM工作流</h2><p>Block Device―&gt;PV―&gt;VG―&gt;LV―&gt;File System―&gt;mount</p><p>#创建物理卷（可以是整个磁盘，也可以是分区）</p><p><img src="/../../../../images/clip_image004-17172992261103.jpg" alt="img"></p><p>#创建卷组</p><p><img src="/../../../../images/clip_image006-17172992261104.jpg" alt="img"></p><p>#创建逻辑卷</p><p><img src="/../../../../images/clip_image008-17172992261102.jpg" alt="img"></p><p>#格式化逻辑卷</p><p><img src="/../../../../images/clip_image010-17172992261105.jpg" alt="img"></p><p>#查看UUID的方式</p><p><img src="/../../../../images/clip_image012-17172992261106.jpg" alt="img"> </p><p>#自动挂载</p><p><img src="/../../../../images/clip_image014-17172992261107.jpg" alt="img"></p><p>#查看逻辑卷、查看卷组</p><p><img src="/../../../../images/clip_image016-17172992261108.jpg" alt="img"></p><p>#删除逻辑卷</p><p><img src="/../../../../images/clip_image018-17172992261109.jpg" alt="img"></p><p>#删除卷组</p><p><img src="/../../../../images/clip_image019.png" alt="img"></p><p>#删除物理卷</p><p><img src="/../../../../images/clip_image021.jpg" alt="img"></p><p>#指定PE的大小</p><p><img src="/../../../../images/clip_image023.jpg" alt="img"></p><h2 id="扩容逻辑卷"><a href="#扩容逻辑卷" class="headerlink" title="扩容逻辑卷"></a>扩容逻辑卷</h2><p>ext4类型</p><p><img src="/../../../../images/clip_image025.jpg" alt="img"></p><p>xfs类型</p><p><img src="/../../../../images/clip_image027.jpg" alt="img"></p><p>lvextend和lvresize区别</p><p>lvextend：支持扩展逻辑卷，不支持缩小逻辑卷</p><p>lvresize：支持扩展和缩小逻辑卷</p><h2 id="管理分层存储"><a href="#管理分层存储" class="headerlink" title="管理分层存储"></a>管理分层存储</h2><p><img src="/../../../../images/clip_image029.jpg" alt="img"></p><p>特点：</p><p>1、    直接在磁盘里面创建两个没有大小的文件系统，可以创建不同类型的文件系统</p><p>2、    不划区域，直接使用</p><p>创建</p><p><img src="/../../../../images/clip_image031.jpg" alt="img"></p><h1 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a>nfs</h1><h2 id="配置⽂件："><a href="#配置⽂件：" class="headerlink" title="配置⽂件："></a>配置⽂件：</h2><p><img src="/../../../../images/clip_image033-171729922611110.jpg" alt="img"></p><p>#创建共享目录、配置nfs共享、启动nfs服务、验证nfs共享配置(关闭防火墙)</p><p><img src="/../../../../images/clip_image035-171729922611111.jpg" alt="img"></p><p>客户端验证nfs共享(实验环境关闭防火墙)、挂载nfs共享到本地</p><p><img src="/../../../../images/clip_image037-171729922611112.jpg" alt="img"></p><p>验证:</p><p><img src="/../../../../images/clip_image039-171729922611113.jpg" alt="img"></p><p><img src="/../../../../images/clip_image041-171729922611114.jpg" alt="img"></p><h2 id="autofs⾃动挂载"><a href="#autofs⾃动挂载" class="headerlink" title="autofs⾃动挂载"></a>autofs⾃动挂载</h2><p>我们在使用Linux时，如果要访问硬件资源，则需要使用mount命令进行挂载，将硬件资源与一个目录进行对应，然后才可以访问使用该存储介质。如果使用samba或者是NFS服务，也需要对远程存储设备进行挂载。mount挂载是使用外部存储介质或者文件系统所必须的一步操作，但是如果挂载的资源过多，则会给网络资源和服务器资源造成一定的负载，从而降低服务器性能。</p><p>为了解决这一问题，我们可以使用autofs服务，autofs是一种系统守护进程，我们可以把挂载信息写入其配置文件中，如果用户不访问其他存储介质的，则系统不会进行挂载，如果用户尝试访问该存储介质，则autofs会自动进行挂载操作，上述所有操作对用户而言是透明的，这样一来，autofs服务节省了服务器的网络和硬件资源</p><h3 id="安装autofs"><a href="#安装autofs" class="headerlink" title="安装autofs"></a>安装autofs</h3><p><img src="/../../../../images/clip_image043-171729922611115.jpg" alt="img"></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><img src="/../../../../images/clip_image045-171729922611116.jpg" alt="img"></p><p><img src="/../../../../images/clip_image047-171729922611117.jpg" alt="img"></p><p>客户端</p><p><img src="/../../../../images/clip_image049-171729922611118.jpg" alt="img"></p><p><img src="/../../../../images/clip_image051-171729922611119.jpg" alt="img"><img src="/../../../../images/clip_image052.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逻辑卷的管理&quot;&gt;&lt;a href=&quot;#逻辑卷的管理&quot; class=&quot;headerlink&quot; title=&quot;逻辑卷的管理&quot;&gt;&lt;/a&gt;逻辑卷的管理&lt;/h1&gt;&lt;p&gt;物理的存储设备、物理卷、卷组、逻辑卷&lt;/p&gt;
&lt;p&gt;物理卷：是物理的存储设备映射到物理卷&lt;/p&gt;
&lt;p&gt;卷组</summary>
      
    
    
    
    <category term="Linux - 基础" scheme="http://example.com/categories/Linux-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
