<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试</title>
      <link href="/2024/06/07/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0_%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/06/07/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B0_%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/YouXiuM/typora_img/master/imagesstretched-1920-1080-1251975.jpg" alt="stretched-1920-1080-1251975"></p>]]></content>
      
      
      <categories>
          
          <category> 容器 - Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker_01</title>
      <link href="/2024/06/07/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/Docker-01/"/>
      <url>/2024/06/07/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/Docker-01/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker技术的背景"><a href="#Docker技术的背景" class="headerlink" title="Docker技术的背景"></a>Docker技术的背景</h2><p>一、背景：物理服务器时代 —&gt; 虚拟化的时代</p><p>1、<strong>部署非常慢</strong></p><p>服务器上每次部署一套LNMP，首先需要创建一个系统</p><p>2、<strong>成本非常高</strong></p><p>搭建服务，就会涉及软件版本、依赖包、进程、端口，端口是不可以重复，当有些执行同样的软件，所依赖的软件包版本有要求，可能报错概率非常大。</p><p>3、<strong>资源浪费</strong></p><p>物理服务器(一般8核+64G)，就为了搭建一个LNMP，估计资源利用率小于20%。</p><p>4、<strong>难于迁移和扩展</strong></p><p>打包系统或软件，里面数据才是最重要，估计数量和大小估计1个月都搞不定，这里所说的数据不只是10G，20G这种小数量</p><p>5、<strong>可能会被限定硬件厂商</strong></p><p>物理服务器的内核有包括AMD、Intel等等，不同厂商的内核可能不同，每个厂商设备的配置都不太相同。</p><p>二、背景：虚拟化时代 —&gt; 容器化时代</p><p>1、vmware虚拟化架构，<strong>解决了环境隔离问题，应用迁移和省钱等问题</strong>。</p><p>2、但是虚拟化也是有局限性，每一个虚拟机都是一个完整的操作系统，要分配系统资源，操作系统本身资源也要消耗一部分资源，当创建几百台虚拟机时，有一天出现宿主机资源不够，需要加资源，这时候扩容就非常难了，因为虚拟机正在跑业务。</p><p>3、<strong>解决应用部署问题</strong>；包括：网络空间(ip，port，接口等)、进程空间(进程pid)、文件系统空间;就比如要搭建多套LNMP，端口、ip、进程号都不能一样，那么端口和IP这些需要改，而且有些程序会导致死命开进程，导致进程不够用，直接导致服务器死机。为什么包括文件系统空间呢？假如两套LNMP，所需要的python版本是不同的，一个是3.9一个是3.6版本，那么她们的命令要求在&#x2F;usr&#x2F;local&#x2F;sbin下，那么执行命令就有问题了，同一个sbin下两个版本的python。</p><p><strong>容器技术解决的是：基于namespace的资源隔离</strong></p><p>资源隔离：是指对namespace(主要是进程空间、网络空间、文件系统空间)的隔离，每一台机器都有自己的pid、ip、port等，运行更多独立的应用，并且不冲突。</p><p>简单地说，就是能够实现每台机器都有自己的独立的端口号(0~65535)、IP、进程号、文件系统等。</p><p><strong>容器最大优势之一：</strong></p><p>1、<strong>轻量级</strong></p><pre><code class="perl">实现如虚拟机一样环境隔离，有独立的namespace，虚拟机创建虚拟机3分钟，容器需要几秒钟​容器：环境交付的一致性(对镜像(发行版+数据)打包)​提供隔离的运行环境，多个程序之间，不会出现依赖冲突例如：容器1:yum install nginx,容器2也安装nginx；完全不影响宿主机，只是产生一些数据而已​可以理解为在你宿主机跑100个进程(进程之间是隔离的)</code></pre><p>3、<strong>高性能</strong></p><pre><code>    容器没有对宿主机资源的损耗，浪费，例如虚拟机是要具体的分配资源，1核2内存这样​容器是直接使用宿主机的最高配置，宿主机2核4内存，那容器也是使用2核4内存；但是，一般我们会限制容器的使用资源，不然会把宿主机搞宕机，就比如你开一个程序CPU占100%，你的电脑还能使用嘛</code></pre><p>4、<strong>容器直接使用宿主机内核，容器没有自己的内核</strong></p><pre><code>容器共用宿主机的内核，只是为了发行版；发行版就是镜像，例如centos，说白了就是获取yum工具、lib库文件、依赖包等等，因为没有永宿主机的yum工具，怎么安装系统lib库文件。</code></pre><p><strong>Docker和容器的关系：</strong></p><p>docker就是一个对容器增删改查的一个工具，就是一个基于golang开发的一个软件。</p><p><strong>容器的作用：</strong></p><p>1、创建独立的namespace，一个隔离的环境</p><p>2、以及对资源进行限制(cgroups)</p><p>3、以及容器是直接使用宿主机的硬件配置(没有虚拟化这种资源损耗)</p><h2 id="1、Docker原理流程-架构"><a href="#1、Docker原理流程-架构" class="headerlink" title="1、Docker原理流程&#x2F;架构"></a>1、Docker原理流程&#x2F;架构</h2><h3 id="1-1-Docker工作流程"><a href="#1-1-Docker工作流程" class="headerlink" title="1.1 Docker工作流程"></a>1.1 Docker工作流程</h3><hr><p><strong>Namespaces（命名空间）</strong>：提供了进程级的隔离，包括进程ID、网络、用户ID、文件系统挂载点等。通过命名空间，容器中的进程与外部系统的进程是隔离的，它们彼此之间看不到对方的资源。</p><p><strong>Cgroups（控制组）</strong>：提供了对系统资源（如CPU、内存、磁盘I&#x2F;O等）的管理和限制。通过cgroups，可以限制一个容器使用的资源量，保证系统的稳定性和性能。</p><p><strong>大致流程：</strong></p><pre><code>1、Linux本身支持LXC技术(对Linux内核的资源隔离，如果namespace,cgroup)。2、docker能够调用LXC技术，从而管理容器，进行增删改查。3、运维和开发人员，基于容器，部署应用。4、利用docker的命令(docker run...)，从而创建容器</code></pre><p><strong>发行版</strong>：发行版是基于Linux内核的完整操作系统，包括了内核、系统工具、应用软件和包管理系统等</p><p>内核是发行版的基础，但发行版不仅仅是内核。发行版还包括了：</p><ol><li><strong>包管理系统</strong>：用于安装、更新和管理软件包。例如，Debian使用APT，Red Hat使用YUM&#x2F;DNF。</li><li><strong>用户界面</strong>：如GNOME、KDE等桌面环境。</li><li><strong>系统工具</strong>：如系统监控工具、配置工具等。</li><li><strong>应用软件</strong>：预装的应用程序，如浏览器、办公软件等</li></ol><p><img src="/../../../images/image-20240531210835336.png" alt="image-20240531210835336"></p><h3 id="1-2-Docker底层架构"><a href="#1-2-Docker底层架构" class="headerlink" title="1.2 Docker底层架构"></a>1.2 Docker底层架构</h3><p><strong>LXC (Linux Containers)</strong> 是一种轻量级的虚拟化技术，允许在单个Linux内核上运行多个隔离的Linux系统（容器）。LXC利用Linux内核的cgroups（control groups）和namespaces（命名空间）来实现这一点。</p><p><strong>通俗地说，就是能够让你在Linux上创建和管理多个独立的容器</strong></p><hr><p><strong>小历史</strong></p><p>LXC只能在Linux平台创建容器，centos，ubuntu等</p><p>然后用户也想要在window上创建、管理容器，但是LXC实现不来，因为创建容器需要内核支持。</p><p>然后再开发一个底层工具，libcontainer，然后这个工具能够跨平台，能够在window创建也能够Linux创建</p><p>刚开始这个libcontainer只能支持部分跨平台，假设只支持戴尔机器上跑，CPU类型不支持等。</p><p>然后2015年，成立OCI组织，制定一个统一的容器标准，容器标准格式是一种不受上层结构绑定的协议，即不限定某种特定的操作系统，硬件CPU架构、公有云等，运行任何人在遵循标准的情况下开发应用容器技术。</p><p>OCI成立后，后面加入了一个CLI工具，<strong>runC</strong>，真正和Linux内核交互，可以直接修改内核。</p><p>LXC—-发展(实现容器跨平台)—-&gt;libcontainer—-迭代(可以直接修改内核)—-&gt;runC</p><hr><p><img src="/../../../images/image-20240604182106389.png" alt="image-20240604182106389"></p><ol><li><strong>runc：</strong><br>**作用: **munc是一个用于运行容器的命令行工具，它实际上是一个容器运行时规范的实现。runc允许你创建和运行符合0pen Container Initiative (0cl)标准的容器。</li></ol><p>  **功能: **runc负责创建容器的隔离环境，包括进程隔离、文件系统隔离、网络隔离等。它可以从容器映像中启动容器，并管理容器的生命周期(启动、停止、销毁等)。runc是容器运行时的核心组件之一，用于执行容器中的应用程序进程。</p><pre><code class="perl">#真正和Linux内核进行交互，比如创建一个namespace空间，就是runC实现启动容器</code></pre><p>  <strong>runC是最底层的工具，可以直接修改内核</strong></p><ol start="2"><li><strong>containerd-shim:</strong><br>**作用: **containerd-shim是containerd的一部分，它充当容器进程与containerd之间的代理。它是一个辅助进程，负责与容器进程进行通信以监控其状态和处理容器的I&#x2F;0。</li></ol><p>  **功能: **containerd-shim帮助containerd管理容器进程的生命周期，包括启动、停止、重启等。它还负责处理容翳的标准输入、输出和错误流，以便与容器的交互。</p><pre><code class="perl">#contained-shim作为容器的父进程，这个进程去操作容器，状态收集、维持stdin等工作。#containerd-shim来调用runc来启动容器</code></pre><ol start="3"><li><strong>containerd:</strong><br>**作用: **containerd是一个容器运行时管理器，它负责管理容器的生命周期、镜像管理以及容器的基本操作。</li></ol><p>  <strong>功能:</strong> containerd与runc集成，充当runc的守护进程，提供高级容器管理功能。它可以与容器编排工具(如Kubernetes)通信，以管理大规模的容器集群。containerd可以被看作是低级容器运行时的一种，为容器生命周期管理提供了一致的API。</p><pre><code class="perl">#调用container-shim(容器父进程)”</code></pre><ol start="4"><li><strong>Docker Engine:</strong><br><strong>作用:</strong> Docker Engine是Docker平台的核心组件，它提供了一个综合性的容器解决方案，包括容器引擎、镜像构建工具、容器编排工具、容器注册表等。</li></ol><p>  **功能: **Docker Engine允许用户创建、构建、打包、运行和部署容器化的应用程序。它使用runc和containerd等底层技术来执行容器中的应用程序，并提供了用户友好的命令行界面和AP1，以便用户轻松管理容器。Docker Engine也提供了一些高级功能，如Docker Compose和Swarm，用于容器编排和集群管理。</p><pre><code class="perl">#用户与docker服务端直接命令操作，只是命令行工具</code></pre><h3 id="1-3-Docker进程架构"><a href="#1-3-Docker进程架构" class="headerlink" title="1.3 Docker进程架构"></a>1.3 Docker进程架构</h3><p>Docker服务器进程(Server Docker Daemon)、REST API 接口、Docker服务端命令行(Client Docker CLI)</p><p><img src="/../../../images/image-20240531204129180.png" alt="image-20240531204129180"></p><p><strong>Docker Daemon</strong></p><p>安装使用Docker，得先运行Docker Daemon进程，用于管理docker(images、containers、network、Data Volumes)。</p><p><strong>Rest接口</strong></p><p>提供Daemon交互的API接口；</p><p>写代码，直接核docker主进程交互，对容器管理。</p><h2 id="2、实践-理论理解"><a href="#2、实践-理论理解" class="headerlink" title="2、实践+理论理解"></a>2、实践+理论理解</h2><h3 id="2-1-容器到底什么？"><a href="#2-1-容器到底什么？" class="headerlink" title="2.1 容器到底什么？"></a>2.1 容器到底什么？</h3><p>容器，你可以理解为是：宿主机上的一个进程(被docker进程管理的程序)</p><p><img src="/../../../images/image-20240601222111408.png" alt="image-20240601222111408"></p><h3 id="2-2-为什么docker启动后会有多一张虚拟网卡？"><a href="#2-2-为什么docker启动后会有多一张虚拟网卡？" class="headerlink" title="2.2 为什么docker启动后会有多一张虚拟网卡？"></a>2.2 为什么docker启动后会有多一张虚拟网卡？</h3><p><img src="/../../../images/image-20240601222343883.png" alt="image-20240601222343883"></p><p>docker0网卡，相当于宿主机和容器之间的”虚拟交换机”，可以理解为，如果没有”虚拟交换机”，那多个容器怎么和宿主机通信，宿主机和容器之间网络，可以理解为”内网”。</p><p>vetha870f61@if10网卡，是和容器的网卡(例如ens3)进行临时绑定，使得能够与外部通信。</p><p>**为什么叫做”临时“？ **</p><p>因为如果容器关机，该网卡就会消失&#x2F;解绑，再开机则又会出现&#x2F;绑定。</p><p>一般流量走向：</p><p><img src="/../../../images/image-20240601223904953.png" alt="image-20240601223904953"></p><p><img src="/../../../images/image-20240603232455781.png" alt="image-20240603232455781"></p><p>查看路由，发现网关就是docker1那个网卡(172.17.0.1)</p><h3 id="2-3-镜像分层原理"><a href="#2-3-镜像分层原理" class="headerlink" title="2.3 镜像分层原理"></a>2.3 镜像分层原理</h3><p>docker的镜像下载：</p><p>是下载了一层一层的镜像文件(docker history redis能查看分层关系)</p><p>为什么需要镜像分层?</p><p>主要原因是：为了节省磁盘空间。</p><p><img src="/../../../images/image-20240601231157415.png" alt="image-20240601231157415"></p><p>如图中，docker pull redis</p><p>a2abf6c4d29d、c7a4e4382001…这种就是一层一层的下载镜像</p><p>下载redis容器，如一般步骤：</p><ol><li>下载发行版(基础镜像，如centos、ubuntu等)</li><li>安装redis软件</li><li>执行redis程序</li></ol><p>”a2abf6c4d29d: Already exists“这个就是已经存在的，不需要重新下载这个层，称这个层为：<strong>公共层</strong>。因为我之前下载过nginx容器，可能nginx和redis使用的发行版是一样的，所以直接使用nginx的发行版。</p><p>如果图中的docker pull nginx，因为下载过一次nginx容器，所以自然无需再下载，就直接使用”缓存”镜像。</p><p><strong>镜像体积</strong></p><p><img src="/../../../images/image-20240601233424226.png" alt="image-20240601233424226"></p><pre><code class="perl">#图中看到她们的体积分别为141MB、113MB，它们总共254MB，但是她们的实际体积是小于254MB，因为她们俩使用的是同一个发行版。docker history可以查看到底层的镜像09675....，是它们俩最起初的一层镜像，占80.4MB，其余的就是下载软件以及部署环境/配置所占用的体积大小。</code></pre><p>例如，运行nginx容器、jump server容器，假设它们使用的发行版、mysql、mysql的版本一致，那么它们的分层如下图所示</p><p>公共层+中间各自的层(各自的逻辑部署)</p><p><img src="/../../../images/image-20240602000959662.png" alt="image-20240602000959662"></p><p>为什么docker run nginx出现以下情况？</p><p><img src="/../../../images/image-20240602003711571.png" alt="image-20240602003711571"></p><p>docker run nginx：前台运行，日志打印再前台；又因为nginx镜像的最上层是执行cmd命令，也就是在执行nginx命令。</p><p><img src="/../../../images/image-20240602003819661.png" alt="image-20240602003819661"></p><h3 id="2-3-容器的本地运行模式和对外运行模式"><a href="#2-3-容器的本地运行模式和对外运行模式" class="headerlink" title="2.3 容器的本地运行模式和对外运行模式"></a>2.3 容器的本地运行模式和对外运行模式</h3><ol><li><strong>本地运行模式</strong>（同一个docker0下的容器，都可以互相访问），例如：nginx只在容器内的网络空间运行，不对外，（docker run 别加端口映射参数)</li><li><strong>对外运行模式</strong>，对外运行一个 1.19.7的nginx  ，直接访问宿主机的 78就看到 1.19.7的 nginx（docker run -d -p 78:80 nginx:1.19.7）</li></ol><hr><h3 id="2-4-容器如果没有执行前台进程，则会立即挂掉"><a href="#2-4-容器如果没有执行前台进程，则会立即挂掉" class="headerlink" title="2.4 容器如果没有执行前台进程，则会立即挂掉"></a>2.4 容器如果没有执行前台进程，则会立即挂掉</h3><p>如果是：docker run -d nginx 这种除外，-d是能够让容器后台运行，容器退出不挂掉</p><p>centos没有出现提示词，而nginx却在执行程序</p><p><img src="/../../../images/image-20240603001129306.png" alt="image-20240603001129306"></p><p>同样都是执行docker run，为什么出现在命令行的效果不一样？</p><p><img src="/../../../images/image-20240603001245342.png" alt="image-20240603001245342"></p><p>因为nginx有执行前台进程，所以docker run时，它会执行前台进程，而centos却只是执行bash而已，没有进程，自然run完就自动挂掉。</p><p>容器本质：就是包裹着一个运行中断进程，是一个容器空间。</p><p>容器内的应用，必须是前台运行的，例如mysql、nginx程序等</p><p>可以手工执行，例如：nginx -g “daemon off”，能够使得nginx前台运行，然后把窗口关闭，再然后另外开一个窗口即可。</p><h3 id="2-5-如何判断你在容器内还是宿主机？"><a href="#2-5-如何判断你在容器内还是宿主机？" class="headerlink" title="2.5 如何判断你在容器内还是宿主机？"></a>2.5 如何判断你在容器内还是宿主机？</h3><pre><code class="perl"># 看ip     看hostname  网络    network namespace     # 看进程     进程pid namespace     ps -ef| wc -l#  命令提示符  看boot目录   file system namespace     ， cat /etc/os-release</code></pre><h3 id="2-6-为什么需要自制docker镜像"><a href="#2-6-为什么需要自制docker镜像" class="headerlink" title="2.6 为什么需要自制docker镜像"></a>2.6 为什么需要自制docker镜像</h3><p>官方给的镜像未必适合我们的需求；官方镜像给我们的是最小化系统，里面很多命令、软件都是没有的，都是给我们自己来扩展。</p><p>例如：docker run -d nginx，他会自动帮我运行nginx，但是里面的版本不一定适合我们，nginx可能可以固定版本，nginx:xxx等等，但是基础环境呢，官方默认把nginx在Debian基础镜像上运行，但我想要centos7.9上运行，那该怎么办呢，再想想，基础镜像很多命令都没有的，例如ifconfig,route,vim等等，都需要我们自己去安装。</p><pre><code class="perl">#当我们自制镜像的时候，尽量减少无用操作，使得镜像精简化，让镜像体积最小化。例如更新yum源(yum makecache)，因为最后还是得清空缓存(yum clean all),所以直接下载软件，不用生成缓存等操作，降低容器内资源的占用，最终这个容器会被提交为镜像文件，镜像文件是有体积的</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器 - Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-02</title>
      <link href="/2024/06/07/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/Docker-02/"/>
      <url>/2024/06/07/%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8/Docker-02/</url>
      
        <content type="html"><![CDATA[<ol><li>部署docker</li></ol><h3 id="1-1手动开启宿主机内核数据包转发功能"><a href="#1-1手动开启宿主机内核数据包转发功能" class="headerlink" title="1.1手动开启宿主机内核数据包转发功能"></a>1.1手动开启宿主机内核数据包转发功能</h3><pre><code class="perl">cat &lt;&lt;EOF&gt;/etc/sysctl.d/docker.confnet.ipv4.ip forward=lnet.bridge.bridge-nf-call-ip6tables =1net.bridge.bridge-nf-call-iptables = 1EOFsysctl -p /etc/sysctl.d/docker.conf1.net.bridge.bridge-nf-call-ip6tables =1#这个设置允许IPV6的网络包通过iptables规则进行处理。Docke外部世界的网络通信，因此需要确保IPv6的网络包也能够通过2.net.bridge.bridge-nf-call-iptables = 1#这个设置允许IPv4的网络包通过iptables规则进行处理。与前面包能够通过iptables进行适当的处理，包括端口转发、防火墙规3.net.ipv4.ip forward=l#这个设置允许Linux系统上的IP数据包进行转发，在Docker中，通常会使用网络式为&quot;bridge&quot;的容器，这要求主机上启用IP数据包转发，以便容器之间可以相互通信以及与外部网络通信。启用此选项允许Linux主机上的IP数据包在网络接口之间进行正确的路由和转发。</code></pre><h3 id="1-2安装流程"><a href="#1-2安装流程" class="headerlink" title="1.2安装流程"></a>1.2安装流程</h3><p>我使用的Centos7,官方建议 3.10 以上，3.8以上好像也可以。</p><p><strong>1.查看当前的内核版本</strong></p><p>uname -r</p><p><strong>2.使用 root 权限更新 yum 包（生产环境中此步操作需慎重，看自己情况，学习的话随便搞）</strong></p><p>**注意 **</p><p>yum -y update：升级所有包同时也升级软件和系统内核；  </p><p>yum -y upgrade：只升级所有包，不升级软件和系统内核</p><p><strong>3.卸载旧版本（如果之前安装过的话）</strong></p><p>yum remove docker  docker-common docker-selinux docker-engine</p><p><strong>4.安装需要的软件包， yum-util 提供yum-config-manager功能，另两个是devicemapper驱动依赖</strong></p><p>yum install -y yum-utils device-mapper-persistent-data lvm2</p><p><strong>5.配置yum源</strong></p><p>yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></p><p><strong>6.选择docker版本并安装</strong></p><p>yum list docker-ce –showduplicates | sort -r</p><p>这里我选择默认</p><p>yum install docker-ce -y</p><p><strong>7.启动 Docker 并设置开机自启</strong></p><p>systemctl start docker </p><p>systemctl enable docker</p><p>这里就能够正常使用了！！！</p><hr><p>如果出现以下情况：</p><p><img src="/.com//../..%5Cimages%5Cimage-20240601001827044.png" alt="image-20240601001827044"></p><ol><li>首先使用yum 安装docker，yum install docker -y。使用docker -v检查docker是否安装成功</li></ol><p><img src="/.com//../..%5Cimages%5Cimage-20240601001953821.png" alt="image-20240601001953821"></p><ol start="2"><li>因为docker使用了iptables的映射规则，而centos7的防火墙是firewall，需要停用 firewall，安装并设置iptables.</li></ol><pre><code class="perl">systemctl stop firewalld;systemctl disable firewalld;yum -y install iptables-services;systemctl enable iptables ;systemctl start iptables;</code></pre><ol start="3"><li>如果centos7版本的内核比较旧，如我的安装完内核是3.10。需要升级linux内核或者修改配置文件。</li></ol><p><strong>这里我选择”升级linux内核”</strong></p><p>可以使用如下命令  </p><pre><code class="perl">yum update nss \&amp;&amp; rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org \&amp;&amp; rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm \&amp;&amp; yum clean all \&amp;&amp; yum --enablerepo=elrepo-kernel install kernel-ml -y \&amp;&amp; grub2-set-default 0</code></pre><p>升级完重启一下系统。</p><p>最后，systemctl start docker</p><p><strong>8.配置docker镜像下载加速器</strong></p><p><strong>方案1</strong>(建议)，用你自己的 阿里云镜像加速器(需要登录)</p><pre><code class="perl">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;&#123;  &quot;registry-mirrors&quot;: [&quot;https://ms9glx6x.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><p><strong>方案1</strong>，执行如下脚本即可<br>curl -sSL <a href="https://get.daocloud.io/daotools/set_mirror.sh">https://get.daocloud.io/daotools/set_mirror.sh</a> | sh -s <a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></p><p>注意！！！</p><p><a href="https://hub.docker.com/">https://hub.docker.com/</a>  #注册，然后，就会有账号密码，里面管理你自己的私有镜像。</p><p>去获取你自己的阿里云镜像站，别用别人的，因为用别人的出现问题也无法处理。</p><h2 id="2-镜像管理"><a href="#2-镜像管理" class="headerlink" title="2. 镜像管理"></a>2. 镜像管理</h2><h3 id="2-1-搜索镜像"><a href="#2-1-搜索镜像" class="headerlink" title="2.1 搜索镜像"></a>2.1 搜索镜像</h3><pre><code class="perl">docker search 镜像名:镜像版本docker search nginx # 默认最新版本 nginx:latest# 要找官方镜像，防止其他镜像有后门</code></pre><h3 id="2-2-下载镜像"><a href="#2-2-下载镜像" class="headerlink" title="2.2 下载镜像"></a>2.2 下载镜像</h3><pre><code class="perl">docker pull 镜像名**注意！**下载官方认证的镜像是最安全的，防止留后门。查询具体的版本号yum install jq -y#这是查询centos容器，如果想查询mysql容器，把centos改成mysql即可curl -s https://registry.hub.docker.com/v1/repositories/centos/tags  |   jq##jq的作用是：让你查看的结果以json格式输出[root@docker-200 ~]#curl -s https://registry.hub.docker.com/v1/repositories/centos/tags  | jq |grep 7.9    &quot;name&quot;: &quot;7.9.2009&quot;    &quot;name&quot;: &quot;centos7.9.2009&quot;    #查询镜像docker images#可以利用关键字查询docker images centos*</code></pre><h3 id="2-3-查看镜像信息"><a href="#2-3-查看镜像信息" class="headerlink" title="2.3 查看镜像信息"></a>2.3 查看镜像信息</h3><pre><code>docker inspect 镜像名:tag</code></pre><p><img src="/../../../images/image-20240605145604545.png" alt="image-20240605145604545"></p><h3 id="2-4-修改镜像名"><a href="#2-4-修改镜像名" class="headerlink" title="2.4 修改镜像名"></a>2.4 修改镜像名</h3><pre><code>docker tag 旧镜像名:旧tag  新镜像名:新tag</code></pre><p><img src="/../../../images/image-20240605142223818.png" alt="image-20240605142223818"></p><h3 id="2-5-删除镜像"><a href="#2-5-删除镜像" class="headerlink" title="2.5 删除镜像"></a>2.5 删除镜像</h3><pre><code class="Perl">docker rmi 镜像名/id#如果有容器使用该镜像，删除失败，除非&quot;docker rmi -f&quot;强制性删除，但谨慎！！！ </code></pre><h3 id="2-6-导出镜像"><a href="#2-6-导出镜像" class="headerlink" title="2.6 导出镜像"></a>2.6 导出镜像</h3><pre><code class="perl">docker save 镜像名/镜像ID &gt;  文件名#默认导出的镜像类型是tar包</code></pre><p><img src="/../../../images/image-20240605141141460.png" alt="image-20240605141141460"></p><h3 id="2-7-导入镜像"><a href="#2-7-导入镜像" class="headerlink" title="2.7 导入镜像"></a>2.7 导入镜像</h3><pre><code class="perl">docker load &lt; 镜像文件# 例如 docker load &lt; ubuntu.tardocker load -i 完整路径文件</code></pre><p><img src="/../../../images/image-20240605141215134.png" alt="image-20240605141215134"></p><h3 id="2-8-容器打包为镜像"><a href="#2-8-容器打包为镜像" class="headerlink" title="2.8 容器打包为镜像"></a>2.8 容器打包为镜像</h3><pre><code>docker commit 容器名/ID 镜像名</code></pre><h3 id="2-9-上传镜像"><a href="#2-9-上传镜像" class="headerlink" title="2.9 上传镜像"></a>2.9 上传镜像</h3><pre><code class="perl">#上传前需要修改tagdocker push  注册docker用户名/REPOSITORY:TAG </code></pre><h3 id="2-10-自制docker镜像"><a href="#2-10-自制docker镜像" class="headerlink" title="2.10 自制docker镜像"></a>2.10 自制docker镜像</h3><pre><code class="perl">#当我们自制镜像的时候，尽量减少无用操作，使得镜像精简化，让镜像体积最小化。例如更新yum源(yum makecache)，因为最后还是得清空缓存(yum clean all),所以直接下载软件，不用生成缓存等操作，降低容器内资源的占用，最终这个容器会被提交为镜像文件，镜像文件是有体积的</code></pre><p><strong>方式一</strong></p><pre><code>1、运行容器2、进入容器，进行安装、配置你所要求3、容器打包称镜像</code></pre><p><img src="/../../../images/image-20240604003421916.png" alt="image-20240604003421916"></p><p><strong>方式二</strong>(推荐)</p><pre><code>1、创建Dockerfile文件2、在dockerfile文件中填写你的需求3、然后利用Dockerfile构建镜像</code></pre><pre><code class="perl"># 使用的基础镜像FROM ubuntu:20.04# 维护者信息LABEL maintainer=&quot;your_email@example.com&quot;# 设置工作目录WORKDIR /app# 复制当前目录下的文件到工作目录COPY . /app# 安装依赖RUN apt-get update &amp;&amp; apt-get install -y python3 python3-pip# 安装 Python 包依赖RUN pip3 install -r requirements.txt# 暴露应用程序的端口EXPOSE 5000# 指定容器启动时运行的命令CMD [&quot;python3&quot;, &quot;app.py&quot;]</code></pre><p><img src="/../../../images/image-20240604003639139.png" alt="image-20240604003639139"></p><pre><code class="perl">docker build -t centos_2 .#解释：-t 可以自定义镜像名  .(点)，表示Dockerfile在当前目录</code></pre><h2 id="3-容器管理"><a href="#3-容器管理" class="headerlink" title="3. 容器管理"></a>3. 容器管理</h2><h3 id="3-1-开启-停止容器"><a href="#3-1-开启-停止容器" class="headerlink" title="3.1 开启&#x2F;停止容器"></a>3.1 开启&#x2F;停止容器</h3><pre><code class="perl">docker run -it ubuntu bash# docker run 的参数# -t 开启一个终端-t, --tty                            Allocate a pseudo-TTY# 标准输入，给容器输入些东西-i, --interactive                    Keep STDIN open even if not attached命令解释：-i，就相当于能够让你在容器内，用键盘输入-t，给你开一个终端进入容器内，就比如ssh开多一个窗口。-p，指定映射端口-P，宿主机随机端口映射容器的指定端口bash，就是让你能够宿主机和容器的bash进行交互，不然就类似于你讲中文，它讲英语，就交互不了。docker run ubuntu 命令 #在运行容器后自动执行命令；例如：docker run ubuntu yum install -y vimdocker stop 容器名/id  #停止容器</code></pre><h3 id="3-2-批量处理容器"><a href="#3-2-批量处理容器" class="headerlink" title="3.2 批量处理容器"></a>3.2 批量处理容器</h3><pre><code class="perl">#写法一docker stop $(docker ps -q) #关掉运行中的所有容器docker rm $(docker ps -qa) #删除已经停止的容器,因为rm 不能删除运行中的容器，rm -f 才可以强制删除。#写法二docker start `docker ps -qa` #开启所有容器docker rm -f `docker ps -qa` #删除所有容器</code></pre><h3 id="3-3-查看容器进程列表"><a href="#3-3-查看容器进程列表" class="headerlink" title="3.3 查看容器进程列表"></a>3.3 查看容器进程列表</h3><pre><code class="perl">docker ps #查看运行中的容器记录docker ps -a #查看所有的容器记录docker ps -qa #查看所有的容器记录，只显示container ID</code></pre><h3 id="3-4-进入容器"><a href="#3-4-进入容器" class="headerlink" title="3.4 进入容器"></a>3.4 进入容器</h3><pre><code class="perl">#进入容器运行bash解释器docker exec -it 容器名/容器ID bash#不进入容器，不开终端，之间在容器内执行xx命令docker exec -it 容器名/容器ID systemctl start nginx</code></pre><p><img src="/../../../images/image-20240605144412395.png" alt="image-20240605144412395"></p><h3 id="3-5-查看容器信息"><a href="#3-5-查看容器信息" class="headerlink" title="3.5 查看容器信息"></a>3.5 查看容器信息</h3><pre><code>docker inspect 容器名/id</code></pre><p><img src="/../../../images/image-20240605145431494.png" alt="image-20240605145431494"></p><h3 id="3-6-拷贝容器数据"><a href="#3-6-拷贝容器数据" class="headerlink" title="3.6 拷贝容器数据"></a>3.6 拷贝容器数据</h3><pre><code>#容器文件拷贝到宿主机docker cp 容器名/ID:完整路径文件名  存放拷贝文件路径#宿主机文件拷贝到容器内docker cp 文件  容器名/ID:存放位置</code></pre><p><img src="/../../../images/image-20240605145244116.png" alt="image-20240605145244116"></p><h3 id="3-7-限制容器资源使用"><a href="#3-7-限制容器资源使用" class="headerlink" title="3.7 限制容器资源使用"></a>3.7 限制容器资源使用</h3><pre><code>docker run  -d  --memory=500M nginx</code></pre><p><img src="/../../../images/image-20240605143058079.png" alt="image-20240605143058079"></p><p><img src="/../../../images/image-20240605143234626.png" alt="image-20240605143234626"></p><h3 id="3-8-容器数据持久化"><a href="#3-8-容器数据持久化" class="headerlink" title="3.8 容器数据持久化"></a>3.8 容器数据持久化</h3><pre><code class="perl">docker run --name nginx -d -v /opt:/opt nginx #容器内的/opt目录下写数据，相当于在宿主机的/opt目录下写数据</code></pre><p><img src="/../../../images/image-20240605143651270.png" alt="image-20240605143651270"></p><h2 id="4-部署私有registry"><a href="#4-部署私有registry" class="headerlink" title="4. 部署私有registry"></a>4. 部署私有registry</h2><pre><code class="perl"># 创建 Docker Registry认证文件目录mkdir /var/lib/registry_auth# 使用htpasswd 来创建加密文件yum install -y httpd-tools# 创建账密htpasswd -Bbn admin admin &gt; /var/lib/registry_auth/htpasswd# 运行registry容器docker run -p 5000:5000 --restart=always --name my-docker-registry \-v /var/lib/registry:/var/lib/registry \-v /var/lib/registry_auth/:/auth/ \-e &quot;REGISTRY_AUTH=htpasswd&quot; \-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \-e &quot;REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd&quot; \-d registry#修改镜像tag，指定上传镜像到哪里docker tag nginx  172.25.250.131:5000/my_nginx:v1# 上传镜像docker push 172.25.250.131:5000/my_nginx:v1#注意docker不允许http仓库，必须走https如果不修改配置文件，会报错Get &quot;https://172.25.250.131:5000/v2/&quot;: http: server gave HTTP response to HTTPS client#添加证书cat /etc/docker/daemon.json &#123;  &quot;registry-mirrors&quot;: [&quot;https://hub.docker.com&quot;,&quot;https://ms9glx6x.mirror.aliyuncs.com&quot;],  &quot;insecure-registries&quot;: [&quot;172.25.250.131:5000&quot;]&#125;#登录账号docker login 172.25.250.131:5000#如果不登录账号是上传不了，会报错&quot;no basic auth credentials&quot;# 上传镜像docker push 172.25.250.131:5000/my_nginx:v1# 下载镜像docker pull 172.25.250.131:5000/my_nginx:v1#查看registry仓库所有镜像访问：http://172.25.250.131:5000/v2/_catalog#查看registry仓库nginx所有版本访问：http://172.25.250.131:5000/v2/my_nginx/tags/list</code></pre><h2 id="5-上传docker-hub公有仓库"><a href="#5-上传docker-hub公有仓库" class="headerlink" title="5. 上传docker hub公有仓库"></a>5. 上传docker hub公有仓库</h2><p>1、Docker hub注册用户：到官网注册账号：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p><img src="/../../../images/image-20240603131036550.png" alt="image-20240603131036550"></p><p>2、在本地宿主机登录docker</p><p><img src="/../../../images/image-20240603131214943.png" alt="image-20240603131214943"></p><p>3、查看镜像</p><p><img src="/../../../images/image-20240603131902110.png" alt="image-20240603131902110"></p><p>4、tag修改镜像名称，使得推送到仓库</p><pre><code class="perl">推送镜像的规范是：docker push  注册docker用户名/REPOSITORY:TAG #注意repository如果没有，会自动创建</code></pre><p><img src="/../../../images/image-20240603133112999.png" alt="image-20240603133112999"></p><p>5、将镜像push到Docker Hub</p><p><img src="/../../../images/image-20240603132952621.png" alt="image-20240603132952621"></p><p><img src="/../../../images/image-20240603133043259.png" alt="image-20240603133043259"></p><p>6、删除本地hello-world镜像</p><p><img src="/../../../images/image-20240603133349737.png" alt="image-20240603133349737"></p><p>7、复制pull命令，从docker Hub仓库下载hello-world镜像到本地</p><p><img src="/../../../images/image-20240603133453919.png" alt="image-20240603133453919"></p><p><img src="/../../../images/image-20240603133624093.png" alt="image-20240603133624093"></p><h2 id="6-portainer可视化管理容器"><a href="#6-portainer可视化管理容器" class="headerlink" title="6. portainer可视化管理容器"></a>6. portainer可视化管理容器</h2><ol><li>下载portainer镜像</li></ol><pre><code>docker pull portainer/portainer</code></pre><ol start="2"><li>运行该portainer容器</li></ol><pre><code class="Perl"> docker run --name portainer -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock  portainer/portainer #-v映射的原因是：portainer是一个容器，因为我们要要portainer可视化管理容器，就是相当于容器内调用宿主机的docker管理，所以必须映射要映射宿主机的docker.sock</code></pre><ol start="3"><li>访问宿主机IP:9000,并注册用户</li></ol><p><img src="/.com//../..%5Cimages%5Cimage-20240605140910016.png" alt="image-20240605140910016"></p>]]></content>
      
      
      <categories>
          
          <category> 容器 - Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL_Server/SQLServer/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL_Server/SQLServer/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h1><p>什么是数据库？</p><p>是存放数据的一个仓库；这个仓库不是传统意义上的”存放干粮这种仓库”；数据库就是多张二维表的集合，二维表就是行(值)和列(属性)组成</p><p>当我们注册QQ号时，叫你输入密码，手机号，名字等等，当你填完这些，然后把这些数据存到一个数据库里面，这样下次输入账号密码，你就能够登录QQ。再比如你注销你的QQ号，在数据库的视角中，只是删除它其中一个表的一行数据。</p><p>数据模型是什么？</p><p><strong>是对现实世界中的数据结构和数据关系的一种抽象和表示，用于指导数据库的设计和实现。</strong>通俗地说，数据模型就像是地图，它告诉你如何组织和存储数据，以及这些数据之间的关系</p><p>组成要素：数据结构、数据操作、数据完整性约束</p><p>常见的数据模型：</p><ol><li><p>层次模型</p><p>这种模型将数据组织成树形结构，其中每个节点表示一个记录，而每个记录包含一个或多个字段。父子关系用于表示数据之间的层次关系。</p><p>例如：</p><p>一个学校的组织结构</p><p>校长-副校长-各个院系的院长-各个院系的主任</p></li><li><p>网状模型</p></li></ol><p>   网状模型类似于层次模型，但节点可以有多个父节点，这使得它可以表示更复杂的多对多关系。</p><p>   例如：课程和学生之间</p><p>   数据库课程：A同学、B同学</p><p>   网络课程：B同学、C同学</p><p>   B同学同时注册了数据库课程和网络课程，表示为多个父节点</p><ol start="3"><li><strong>关系模型</strong></li></ol><p>​关系模型使用表来表示数据，其中每个表包含行和列。表之间通过外键建立联系</p><h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><p>学生关系数据模型</p><p><img src="/../../../../images/image-20240602154144639.png" alt="image-20240602154144639"></p><pre><code>1. 关系数据模型简称关系模型;2. 关系数据模型中的核心元素是关系，实体及其联系都用关系来表示3. 关系也就是二维表，一个关系数据库由若干个表组成4. 关系数据模型 由关系数据结构、关系操作集合和关系完整性约束三部分组成。</code></pre><h3 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h3><ol><li><p>数据模型中的数据结构描述数据的静态特性。关系模型的数据结构非常单一，在关系模型中，现实世界中的所有事物（实体）及其联系均用关系来表示。</p></li><li><p>关系，就是我们常用的<strong>二维表</strong>，<strong>关系数据结构就是二维表结构。</strong></p></li></ol><p>就是定义二维表的属性，例如教室表，属性可以有：教工号，姓名，性别等。</p><p><img src="/../../../../images/image-20240602155035431.png" alt="image-20240602155035431"></p><h3 id="关系操作集合"><a href="#关系操作集合" class="headerlink" title="关系操作集合"></a>关系操作集合</h3><p>关系操作：查询和编辑</p><p>查询操作：<strong>选择、投影、连接、并、交、差</strong>等</p><p>编辑类操作：<strong>插入、删除和修改</strong></p><p><strong>操作的对象和结果都是元组（行）的集合</strong></p><p><strong>选择（Selection）</strong></p><p>选择操作用于从表中提取满足特定条件的行。它相当于SQL中的<code>SELECT</code>语句加上<code>WHERE</code>子句。</p><p>从“员工”表中选择所有年龄大于30岁的员工。</p><pre><code class="perl">SELECT * FROM Employees WHERE Age &gt; 30;</code></pre><p><strong>投影（Projection）</strong></p><p>投影操作用于从表中提取特定的列。它相当于SQL中的<code>SELECT</code>语句指定具体的列。</p><p>从“员工”表中选择所有员工的名字和年龄。</p><pre><code>SELECT Name, Age FROM Employees;</code></pre><p><strong>连接（Join）</strong></p><p>连接操作用于将两个表中的行按照某个相关列组合在一起。它相当于SQL中的<code>JOIN</code>操作。</p><p>从“订单”表和“客户”表中获取所有订单及其对应的客户信息</p><pre><code>SELECT Orders.OrderID, Customers.CustomerNameFROM OrdersJOIN Customers ON Orders.CustomerID = Customers.CustomerID;</code></pre><p><strong>并（Union）</strong></p><p>并操作用于将两个表的结果集合并在一起，包含所有不重复的行。它相当于SQL中的<code>UNION</code>操作。</p><p>从“员工_旧”表和“员工_新”表中获取所有员工的名字。</p><pre><code>SELECT Name FROM Employees_OldUNIONSELECT Name FROM Employees_New;</code></pre><p><strong>交（Intersection）</strong></p><p>交操作用于获取两个表中共有的行。它相当于SQL中的<code>INTERSECT</code>操作（一些数据库管理系统如MySQL不直接支持<code>INTERSECT</code>，可以通过<code>JOIN</code>或子查询实现）。</p><p>从“项目A”表和“项目B”表中获取在两个项目中都参与的员工ID。</p><pre><code>SELECT EmployeeID FROM ProjectAINTERSECTSELECT EmployeeID FROM ProjectB;</code></pre><p><strong>差（Difference）</strong></p><p>差操作用于获取在一个表中有但在另一个表中没有的行。它相当于SQL中的<code>EXCEPT</code>操作（一些数据库管理系统如MySQL不直接支持<code>EXCEPT</code>，可以通过<code>LEFT JOIN</code>和<code>WHERE</code>子句实现）。</p><p>从“项目A”表中获取在“项目B”表中没有参与的员工ID。</p><pre><code>SELECT EmployeeID FROM ProjectAWHERE EmployeeID NOT IN (SELECT EmployeeID FROM ProjectB);</code></pre><h3 id="关系完整性约束"><a href="#关系完整性约束" class="headerlink" title="关系完整性约束"></a>关系完整性约束</h3><p><strong>关系的完整性约束</strong>包括<strong>实体完整性</strong>、<strong>参照完整性</strong>和<strong>用户定义的完整性</strong></p><p>​1. <strong>实体完整性</strong>是保证关系中<strong>每个实体的唯一性</strong>必须要满足的约束，在具体的DBMS实现中表现为<strong>表中主键</strong>的设置</p><p>​2. <strong>参照完整性</strong>是保证关系之间的联系正常有效而同样必须要满足的约束，在具体的DBMS中表现为<strong>外键</strong>的设置</p><p>​3.  <strong>用户定义的完整性</strong>是实际的应用领域需要遵循的约束条件，体现了<strong>具体应用的实际约束</strong>，如给定条件的<strong>检查约束</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Podman-搭建与使用</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/Blog/Podman-%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/Blog/Podman-%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Podman安装与配置"><a href="#Podman安装与配置" class="headerlink" title="Podman安装与配置"></a>Podman安装与配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="/../../../../images/clip_image002-17172999161452.jpg" alt="img"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>全局的配置文件：</p><p><img src="/../../../../images/clip_image004-17172999161441.jpg" alt="img"></p><p>配置镜像加速器:</p><p><img src="/../../../../images/clip_image006-17172999161453.jpg" alt="img"></p><p>仓库的先后顺序，决定查找优先级</p><p>配置镜像下载Url顺序：</p><p><img src="/../../../../images/clip_image008-17172999161454.jpg" alt="img"></p><p>普通⽤⼾的配置⽂件：</p><p><img src="/../../../../images/clip_image010-17172999161465.jpg" alt="img"></p><h1 id="Podman镜像管理与镜像结构"><a href="#Podman镜像管理与镜像结构" class="headerlink" title="Podman镜像管理与镜像结构"></a>Podman镜像管理与镜像结构</h1><h2 id="Podman镜像管理"><a href="#Podman镜像管理" class="headerlink" title="Podman镜像管理"></a>Podman镜像管理</h2><p>1、列出镜像列表</p><p><img src="/../../../../images/clip_image012-17172999161466.jpg" alt="img"></p><pre><code class="perl">REPOSITORY：镜像的仓库源 TAG：镜像的标签。例如:latest表示最新版本IMAGE ID：镜像的IDCREATED：镜像创建时间SIZE：镜像大小注意：同一仓库源可以有多个TAG</code></pre><p>2、搜索镜像</p><p><img src="/../../../../images/clip_image014-17172999161468.jpg" alt="img"></p><pre><code class="perl">INDEX：索引NAME：镜像仓库名DESCRIPTION：镜像的描述STATRS：表示点赞量或喜欢的意思OFFICAL：是否官方发布AUTOMATED：自动创建</code></pre><p>3、获取镜像</p><p><img src="/../../../../images/clip_image016-17172999161467.jpg" alt="img"></p><p>4、使用tag命令添加镜像标签</p><p><img src="/../../../../images/clip_image018-17172999161469.jpg" alt="img"></p><p>注意：如果利用ID来删除是把镜像删除，而不是删除标签</p><p>5、删除镜像</p><p><img src="/../../../../images/clip_image020-171729991614610.jpg" alt="img"></p><p>6、清理镜像(执行前一定确认清楚！！！)</p><p><img src="/../../../../images/clip_image022-171729991614612.jpg" alt="img"></p><p>作用：清理系统中所有不再被使用的镜像，包括悬挂的镜像。</p><pre><code class="perl">悬挂的镜像，这些是没有与任何容器关联的镜像。当您构建一个新的容器镜像，或者通过拉取一个镜像时，可能会产生悬挂的镜像。这些镜像没有被任何正在运行的容器使用，并且可以被视为不再需要的。未被容器引用的镜像： 这些是没有被当前正在运行的容器引用的镜像。如果一个容器使用了特定版本的镜像，并且该容器已经停止或删除，那么该版本的镜像就不再被使用，可以被清理。</code></pre><p>7、导出镜像</p><p><img src="/../../../../images/clip_image024-171729991614613.jpg" alt="img"></p><p>8、导入镜像</p><p><img src="/../../../../images/clip_image026-171729991614611.jpg" alt="img"></p><p>9、镜像历史</p><p>作用：查看镜像的构建历史信息。可以查看到镜像构建的整个过程</p><p><img src="/../../../../images/clip_image028-171729991614614.jpg" alt="img"></p><h2 id="Podman镜像结构"><a href="#Podman镜像结构" class="headerlink" title="Podman镜像结构"></a>Podman镜像结构</h2><p>提供文件系统，例如一个centos:7的镜像，大小大致200M，但不包含操作系统Linux内核，容器的内涵是宿主机提供的，一起共用一个内核</p><p><img src="/../../../../images/clip_image030-171729991614615.jpg" alt="img"></p><p>流程：</p><pre><code class="perl">1、先下载centos:7的镜像，然后生成容器(A)，然后在容器A执行 mkdir /dir，然后打包为镜像A(e1d…)，然后把容器A删除2、然后利用镜像A创建容器(B),执行 touch /dir/file，然后打包为镜像B(b34…),然后把容器B删除3、然后利用镜像B创建容器(C),执行，CMD”/bin/bash”和提交，然后打包为镜像C(33b…),最后删除容器C</code></pre><p><img src="/../../../../images/clip_image032-171729991614618.jpg" alt="img"></p><p>Podman 镜像构建过程，如上图所示，通过 podman history 可以看到镜像的构建历史信息，新镜像是从base 镜像一层一层叠加生成的。每执行一个任务，就在现有镜像的基础上增加一层。都是在Base镜像基础上逐步叠加。</p><p>3、镜像缓存</p><p>podman会把构建过程中的每一层临时镜像进行缓存。使用Podmanfile文件构建完镜像以后，新镜像时，，可以直接使用之前缓存的镜像层这样能加速镜像的</p><p>构建。</p><p><img src="/../../../../images/clip_image034-171729991614616.jpg" alt="img"></p><p>修改之前的Podmanfile文件，Podmanfile文件里面共三条指令，前两条指令都是用之前构建镜像的缓存，只有第三个指令才重新构建了缓存层。如果希望在构建镜像时不使用缓存，可以在podman build命令中加上–no-cache参数。</p><p>4、    COPY指令和ADD指令用于复制宿主机上的文件到目标镜像中</p><p>COPY只是用于复制，ADD复制和解压</p><p><src>:  要复制的源文件或目录，支持通配符</src></p><p><dest>: 目标路径，即正创建的镜像的文件系统路径，建议使用绝对路径，否则，COPY指令会以WORKDIR为其起始路径。如果路径中如果包含空白字符，建议使用第二种格式用引号引起来，否则会被当成两个文件。</dest></p><p><img src="/../../../../images/clip_image036-171729991614617.jpg" alt="img"></p><p>5、    WORDDIR指令用于指定工作目录，可以指定多个，每个WORKDIR指影响他下面的指令，直到遇到下一个WORKDIR为止。类似与”cd(切换目录)”</p><p>6、    VOLUME指令用于在镜像中创建一个挂载点目录。两种类型：绑定挂载和podman管理的卷，在Podmanfile中只支持Podman管理的卷，也就是说只能指定容器内的路径，不能指定宿主机的路径。</p><p>7、    EXPOSE指令用于指定容器中待暴露的端口，例如，容器提供httpd服务且要对外提供访问，那就需要指定待暴露80端口，，然后在使用此镜像启动容器时搭配-P的参数才能将待暴露的状态转换为真正暴露的状态，转换的同时443也会转换成一个随机端口，跟-p :443一个意思。EXPOSE指令可以次指定多个端口，例如: EXPOSE 11111&#x2F;udp 11112&#x2F;tcp</p><p>9、ENV指令用于为镜像定义所需的环境变量，并可被ENV指令后面的其它指令所调用。调用格式为$variable_name或者$(variable_name)，使用podman run 启动容器的时候加上-e 的参数为variable name赋值，可以覆盖Podmanfile中ENV指令指定的此variable name的值。但是不会影响到Dockerfile中已经引用过此变量的文件名，格式如下</p><p>ENV <key> <value></value></key></p><p>ENV <key> <value>…</value></key></p><p>注意：podman run -e 指定环境变量，如果变量名相同她会覆盖dockerfile的变量</p><p><img src="/../../../../images/clip_image038-171729991614619.jpg" alt="img"></p><p>10、RUN指令运行于Podman build过程中运行的程序，可以是任何命令。RUN指令后所执行的命令必须在FROM指令后的基础镜像中存在才行</p><p>11、CMD指令用于用户指定启动容器的默认要运行的程序，ENTRYPOINT指令类似CMD指令的功能，用于容器指定默认运行程序。podman run命令会覆盖CMD指令，ENTRYPOINT不会被覆盖。</p><p>三种构建镜像：<br> 1、podman commit命令</p><p>2、基于本地模板导入</p><p>3、Podmanfile构建文件</p><h1 id="Podman容器的管理"><a href="#Podman容器的管理" class="headerlink" title="Podman容器的管理"></a>Podman容器的管理</h1><p>1、    创建容器(podman create)</p><p><img src="/../../../../images/clip_image040-171729991614620.jpg" alt="img"></p><pre><code class="perl">-i：让容器的标准输入保持打开-t：分配一个伪终端并绑定到容器的标准输入-d：让容器后台运行podman create -d 适用于需要在后台运行的容器，通常用于服务或长时间运行的应用。podman create -it 适用于需要与容器进行交互的场景，例如手动调试或运行交互式应用程序。</code></pre><p>2、查看容器(podman ps)</p><p><img src="/../../../../images/clip_image042-171729991614721.jpg" alt="img"></p><p>3、启动和关闭容器</p><p><img src="/../../../../images/clip_image044-171729991614722.jpg" alt="img"></p><p>4、创建并启动容器</p><p><img src="/../../../../images/clip_image046-171729991614723.jpg" alt="img"></p><p>加&#x2F;bin&#x2F;bash原因：指定容器内要启动Bash shell，这样就可以使用各种命令等</p><p>5、容器的pause和unpause</p><p><img src="/../../../../images/clip_image048-171729991614725.jpg" alt="img"></p><p>6、    删除所有停止状态的容器(podman container prune)</p><p><img src="/../../../../images/clip_image050-171729991614724.jpg" alt="img"></p><p>7、进入容器</p><pre><code class="perl">在使用-d参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入:(1)podman attach: 不建议大家使用podman attach，因为退出容器终端，会导致容器的停止。(2) podman exec: 推荐大家使用podman exec命令，因为退出容器终端，不会导致容器的停止。podman attach</code></pre><p><img src="/../../../../images/clip_image052.jpg" alt="img"></p><p>podman exec</p><p><img src="/../../../../images/clip_image054.jpg" alt="img"></p><p>8、删除容器</p><p>podman rm 只能删除停止的容器</p><p>podman rm -f 删除停止或运行中的容器(强制删除)</p><p><img src="/../../../../images/clip_image056-171729991614726.jpg" alt="img"></p><p>9、查看容器的日志信息</p><pre><code class="perl">podman logs container_id 或 name-f 动态跟踪容器的日志输出(类似于tail -f)--since 和 –until 限制输出日志的时间范围。指定开始时间和结束时间podman logs -f --since=10m &lt;container_id_or_name&gt;动态跟踪模式输出容器最近10分钟内的日志</code></pre><p>10、导入和导出容器</p><p><img src="/../../../../images/clip_image058-171729991614727.jpg" alt="img"></p><p>11、列出最近创建的容器</p><p>podman ps -n 3 或 podman ps -n -3</p><p>显示最近最近创建的3个容器的简要信息</p><p>12、显示正在运行容器中的进程信息</p><p><img src="/../../../../images/clip_image060.jpg" alt="img"></p><h1 id="Podman端口映射和持久性存储"><a href="#Podman端口映射和持久性存储" class="headerlink" title="Podman端口映射和持久性存储"></a>Podman端口映射和持久性存储</h1><p>1、容器端口映射</p><p>-P：随机端口</p><p>-p：指定端口</p><p><img src="/../../../../images/clip_image062.jpg" alt="img"><img src="/../../../../images/clip_image064.jpg" alt="img"></p><p><img src="/../../../../images/clip_image066-171729991614728.jpg" alt="img"><img src="/../../../../images/clip_image068.jpg" alt="img"></p><p>2、    查看容器日志</p><p><img src="/../../../../images/clip_image070-171729991614729.jpg" alt="img"></p><p>3、查看容器详细信息</p><p>podman inspect container_id or name</p><p>4、宿主机与容器之间的拷贝</p><p><img src="/../../../../images/clip_image072-171729991614730.jpg" alt="img"></p><p>5、持久化存储</p><p>作用：对宿主机与容器的目录或文件的映射，达到持久化存储，防止容器宕机而其重要内容也消失。</p><p>-v: ~&#x2F;nginx&#x2F;www:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html将我们自己创建的 www目录 挂载到容器d的v:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html.</p><p>-v: ~&#x2F;nginx&#x2F;conf&#x2F;nginxconf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf 将我们自己创建的nginx.conf挂载到容器的&#x2F;etc&#x2F;nginx&#x2F;nginx.conf.</p><p>-v: ~&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx 将我们自己创建的logs挂载到容器的&#x2F;var&#x2F;log&#x2F;nginx。</p><p><img src="/../../../../images/clip_image074.jpg" alt="img"></p><p><img src="/../../../../images/clip_image076.jpg" alt="img"><img src="/../../../../images/clip_image078.jpg" alt="img"><img src="/../../../../images/clip_image080-171729991614831.jpg" alt="img"></p><h1 id="Podman容器的开机自启"><a href="#Podman容器的开机自启" class="headerlink" title="Podman容器的开机自启"></a>Podman容器的开机自启</h1><h2 id="root用户下podman容器服务开机自启"><a href="#root用户下podman容器服务开机自启" class="headerlink" title="root用户下podman容器服务开机自启"></a>root用户下podman容器服务开机自启</h2><p>1、切换&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system目录</p><p>2、    将httpd镜像成为web容器，并运行该容器</p><p><img src="/../../../../images/clip_image082-171729991614832.jpg" alt="img"></p><p>3、生成httpd容器的systemd单元文件</p><p><img src="/../../../../images/clip_image084-171729991614933.jpg" alt="img"></p><p>注意：–name要求要和容器的名称或ID相同，不然找不到。</p><p>4、查看单元文件是否正确</p><p><img src="/../../../../images/clip_image086-171729991614934.jpg" alt="img"></p><p>5、重启服务，并设置自启，然后查看状态</p><p><img src="/../../../../images/clip_image088-171729991614937.jpg" alt="img"></p><h2 id="普通用户下podman容器服务开机自启"><a href="#普通用户下podman容器服务开机自启" class="headerlink" title="普通用户下podman容器服务开机自启"></a>普通用户下podman容器服务开机自启</h2><p>1、    切换普通用户不能su -命令，要用ssh</p><p><img src="/../../../../images/clip_image090-171729991614935.jpg" alt="img"></p><p>2、    启动容器my_nginx</p><p><img src="/../../../../images/clip_image092-171729991614936.jpg" alt="img"></p><p>3、在用户家目录下创建递归目录~&#x2F;.config&#x2F;systemd&#x2F;user目录，只能是该目录名，因为普通用户启动服务的时候一定只能是此目录</p><p><img src="/../../../../images/clip_image094-171729991614938.jpg" alt="img"></p><p>4、切换到该目录下，生成systemd管理的服务单元文件 </p><p><img src="/../../../../images/clip_image096.jpg" alt="img"></p><p>5、编辑单元文件container-my_nginx.service</p><p><img src="/../../../../images/clip_image098.jpg" alt="img"></p><p>6、    将my_nginx容器的服务进程container-my_nginx设置下次启动生效</p><p><img src="/../../../../images/clip_image100.jpg" alt="img"></p><p>7、启动逗留(作用：实现普通用户创建的服务可以被systemd管理)</p><p>给 container_user用户启用逗留功能(systemd 可以管理 user service，普通用户可以为自己的服务创建 unit 文件，并使用 systemctl 命令管理这些服务。</p><p>当用户服务类型为非根用户时，通过文本或者图形控制台或使用 ssh 打开第一个会话时，该服务将自动启动。当关闭最后一次会话时，服务将停止。这种行为与系统服务不同，系统服务在系统启动时启动，在系统关闭时停止。)</p><p><img src="/../../../../images/clip_image102.jpg" alt="img"></p><p>loginctl enable-linger username</p><p>这将启用用户 username 的 linger 特性，使得该用户的服务在用户注销后继续运行。</p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ansible-搭建与使用</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/Blog/Ansible-%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/Blog/Ansible-%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="部署ansible"><a href="#部署ansible" class="headerlink" title="部署ansible"></a>部署ansible</h1><h2 id="2-1构建ansible清单"><a href="#2-1构建ansible清单" class="headerlink" title="2.1构建ansible清单"></a>2.1构建ansible清单</h2><p>主机清单：&#x2F;etc&#x2F;ansible&#x2F;hosts 系统的默认静态清单文件，通常不使用该文件</p><p><img src="/../../../../images/clip_image002-17173099547301.jpg" alt="img"></p><p>注意：</p><p>ungrouped主机组含有清单中明确列出，但不属于任何 其他组的每一个主机</p><p>all主机组含有清单中明确列出的每一个主机</p><p>localhost不在清单文件中，但仍然生效，是自带的</p><p>验证清单：</p><p>ansible 172.16.16.250 –list-hosts 验证172.16.16.250是否在主机清单中</p><h2 id="2-2管理ansible配置文件"><a href="#2-2管理ansible配置文件" class="headerlink" title="2.2管理ansible配置文件"></a>2.2管理ansible配置文件</h2><p>配置文件位置（优先级:从上到下优先级越高）：</p><p>1、&#x2F;etc&#x2F;ansible&#x2F;ansible.cfg</p><p>2、~&#x2F;.ansible.cfg</p><p>3、.&#x2F;ansible.cfg</p><p>~&#x2F;.ansible.cfg和.&#x2F;ansible.cfg，如果该两个文件不存在，默认使用&#x2F;etc&#x2F;ansible&#x2F;ansible.cfg</p><p><img src="/../../../../images/clip_image004-17173099547315.jpg" alt="img"></p><p>典型ansible.cfg文件：</p><p>[defaults]</p><p>inventory &#x3D; .&#x2F;inventory #指定清单</p><p>remote_user &#x3D; user­_01</p><p>ask_pass &#x3D; false</p><p>[privilege_escalation]</p><p>become &#x3D; true</p><p>become_method &#x3D; sudo</p><p>become_user &#x3D; root</p><p>become_askpass &#x3D; false</p><p><img src="/../../../../images/clip_image006-17173099547312.jpg" alt="img"></p><p>remote_user &#x3D; user­_01,通过ansible登录其他主机时，是用user_01登录，受管主机必须要有user_01这个用户</p><p>受管主机条件：</p><p>1、    受管主机必须要有user_01这个用户</p><p>2、    确保该用户sudo免密</p><p>3、    确保ssh免密(生成ssh-keygen,再上传ssh-copy-id等等)</p><h2 id="2-3使用临时命令-完整流程"><a href="#2-3使用临时命令-完整流程" class="headerlink" title="2.3使用临时命令(完整流程)"></a>2.3使用临时命令(完整流程)</h2><p>普通用户(student)</p><p>1、 创建ansible的工作目录</p><p>mkdir -p &#x2F;home&#x2F;student&#x2F;ansible</p><p>2、 生成配置文件</p><p><img src="/../../../../images/clip_image008-17173099547313.jpg" alt="img"></p><p>cd &#x2F;home&#x2F;student&#x2F;ansible</p><p>ansible-config init –disabled &gt; ansible.cfg #可以手动创建</p><p><img src="/../../../../images/clip_image010-17173099547314.jpg" alt="img"></p><p>3、 创建主机清单</p><p><img src="/../../../../images/clip_image012-17173099547316.jpg" alt="img"></p><p>4、 执行临时命令</p><p><img src="/../../../../images/clip_image014-17173099547318.jpg" alt="img"></p><p>5、 排错</p><p>尝试 ssh登录远程主机</p><p><img src="/../../../../images/clip_image016-17173099547317.jpg" alt="img"></p><p>发现要输入密码，则需要做免密操作</p><p>\1.  生成密钥</p><p><img src="/../../../../images/clip_image018-17173099547319.jpg" alt="img"></p><p>\2.  上传公钥</p><p><img src="/../../../../images/clip_image020-171730995473110.jpg" alt="img"></p><p>6、 再次执行临时命令</p><p><img src="/../../../../images/clip_image022-171730995473111.jpg" alt="img"></p><p>发现远程主机的用户，没有提权操作没有做好。</p><p><img src="/../../../../images/clip_image024-171730995473112.jpg" alt="img"></p><p>7、 再次执行临时操作</p><p><img src="/../../../../images/clip_image026-171730995473113.jpg" alt="img"></p><p>注意：如果一直报错，尝试ssh登录，发现一直要密码，上传公钥也没有时，有可能是当时生成密钥带有密码保护。</p><p><img src="/../../../../images/clip_image028-171730995473114.jpg" alt="img"></p><p>1、    首先把密钥文件都删除</p><p>rm -f ~&#x2F;.ssh&#x2F;*</p><p>2、    生成密钥</p><p>ssh-keygen -t rsa</p><p>3、    先把远程的~&#x2F;.ssh&#x2F;authorized_keys删除,再上传公钥</p><p>rm -f ~&#x2F;.ssh&#x2F;authorized_keys #受管主机</p><p>ssh-copy-id student@IP&#x2F;域名 #控制节点</p><p>-————————————————————–</p><p>提权操作</p><p><img src="/../../../../images/clip_image030-171730995473115.jpg" alt="img"></p><p>因为提权（become_user）</p><p><img src="/../../../../images/clip_image032-171730995473116.jpg" alt="img"></p><p>为什么同样的操作，而颜色为什么不同？</p><p><img src="/../../../../images/clip_image034-171730995473117.jpg" alt="img"></p><p>因为幂等性，先会检查文件，servera没有做任何改动(她的该目录已经有123.txt的文件且里面的内容是ansible123456)，其他主机则改动了(CHANGED)</p><p>Playbook的格式转译为临时命令</p><p>查看file模板的详细信息(ansible-doc file)</p><p><img src="/../../../../images/clip_image036-171730995473118.jpg" alt="img"></p><p>- name: Recursively remove directory</p><p> ansible.builtin.file:</p><p> path: &#x2F;etc&#x2F;foo</p><p> state: absent #消失</p><p>转译为临时命令</p><p>ansible servera -m file -a “path&#x3D;&#x2F;home&#x2F;student&#x2F;test.txt state &#x3D; absent”</p><p><img src="/../../../../images/clip_image038-171730995473119.jpg" alt="img"></p><p>append(附加选项):yes表示确保用户添加到指定的用户组中，不会影响原有的组的成员身份</p><p>转译为临时命令</p><p>ansible severa -m user -a “name&#x3D;user_01 shell&#x3D;&#x2F;bin&#x2F;bash groups&#x3D;root append&#x3D;yes</p><p>假设user_01存在，且GID为1001,现在groups&#x3D;root，则会添加附加组</p><p>command模块和shell模块的区别：</p><p>shell模块能够访问受控主机的环境变量,支持管道,通配符,重定向等</p><p>command模块不能够访问受控主机的环境变量</p><p>命令行参数</p><p><img src="/../../../../images/clip_image040-171730995473120.jpg" alt="img"></p><p>这些参数作用：不使用ansible.cfg里的配置，只是临时测试用，本次任务生效</p><p>例如：</p><p><img src="/../../../../images/clip_image042-171730995473121.jpg" alt="img"></p><h1 id="实施playbook"><a href="#实施playbook" class="headerlink" title="实施playbook"></a>实施playbook</h1><h2 id="3-1编写和运行playbook"><a href="#3-1编写和运行playbook" class="headerlink" title="3.1编写和运行playbook"></a>3.1编写和运行playbook</h2><p>playbook格式：</p><p>—开头</p><p>- name: 这个第1个play的名字</p><p>hosts: all 这个play执行的对象是谁</p><p> tasks: 定义任务</p><p>​    - name: 任务1的名字</p><p>​     user: 任务1的模块</p><p>​       name:模块里的参数</p><p>​       uid: 模块里的参数</p><p>​       state:模块里的参数</p><p>​    -name: 任务2的名字</p><p>​     file: 任务1的模块</p><p>​       name: 模块里的参数</p><p>​       uid: 模块里的参数</p><p>​       state: 模块里的参数</p><p>­­­­­­playbook缩进量建议要求</p><p>play是要顶格</p><p>一个play里，可以定义多个任务</p><p>每个级别之间使用相同的空格数。</p><p>比如一级目录，顶格，比如play的名字</p><p>二级目录，2个空格，比如hosts，tasks</p><p>三级目录，人物的名字，再加2个空格</p><p>四级目录，比如 模块的名字，file，2个空格</p><p>五级目录，模块里的参数，比如 state，2个空格</p><p>设置vi文本编辑器, 在$HOME&#x2F;.vimrc文件中添加下面这行后，如果vim&#x2F;vi检测到编辑YAML文件，它将在Tab键按下时执行一个双空格缩进，并自动缩进后续行</p><p>autocmd FileType yaml setlocal ai ts&#x3D;2 sw&#x3D;2 et</p><p>语法检验：–syntax-checl，只会检测语法、关键字是否正确，缩进量是否正确，但对其值对与否并不会检测出来。</p><p>执行空运行：对playbook执行空运行时对远程主机没有做任何改变。</p><p><img src="/../../../../images/clip_image044-171730995473123.jpg" alt="img"></p><p>注意：有些-c选项也检测不出，需要真正执行一次才知道，例如：磁盘空间问题</p><h2 id="3-2实施多个play"><a href="#3-2实施多个play" class="headerlink" title="3.2实施多个play"></a>3.2实施多个play</h2><p><img src="/../../../../images/clip_image046-171730995473124.jpg" alt="img"></p><p>可以指定在某个play单独指定用户执行</p><p>在play中，添加：remote_user: user_01</p><p>提权也是一样操作, become_user: root，提权到root</p><p>前提条件：</p><p>1、受管主机必须要有user_01这个用户</p><p>2、确保该用户sudo免密</p><p>3、确保ssh免密(生成ssh-keygen,再上传ssh-copy-id等等)</p><p>安装多个软件(启动服务也类似)</p><p><img src="/../../../../images/clip_image048-171730995473122.jpg" alt="img"></p><p>关于ansible-doc的描述</p><p>ansible-doc win-environment</p><p><img src="/../../../../images/clip_image050-171730995473125.jpg" alt="img"></p><p>status字段记录模块的开发状态：</p><p><img src="/../../../../images/clip_image052-171730995473126.jpg" alt="img"></p><p>supported_by字段记录上游Ansible社区中维护模块的人.可能的值包括：</p><p><img src="/../../../../images/clip_image054-171730995473127.jpg" alt="img"></p><p>幂等性和非幂等性</p><p><img src="/../../../../images/clip_image056-171730995473128.jpg" alt="img"> <img src="/../../../../images/clip_image058-171730995473129.jpg" alt="img"></p><p>yml文件字符串：</p><p>竖线(|)：保留字符串为多行</p><p><img src="/../../../../images/clip_image060-171730995473130.jpg" alt="img"></p><p>大于号(&gt;)：换行字符转换成空格合成一行，在一行输出</p><p><img src="/../../../../images/clip_image062-171730995473131.jpg" alt="img"></p><p>YAML字典</p><p><img src="/../../../../images/clip_image064-171730995473132.jpg" alt="img"></p><p>YAML列表</p><p><img src="/../../../../images/clip_image066-171730995473133.jpg" alt="img"></p><h1 id="编写playbook使用变量"><a href="#编写playbook使用变量" class="headerlink" title="编写playbook使用变量"></a>编写playbook使用变量</h1><h2 id="管理变量"><a href="#管理变量" class="headerlink" title="管理变量"></a>管理变量</h2><p>变量的命名规则</p><p>变量的名字只能包含_、字⺟、数字，且变量名的⾸位不能是数字。</p><p><img src="/../../../../images/clip_image068-171730995473134.jpg" alt="img"></p><p>定义变量(建议选择全局唯⼀的变量名称)</p><p>Ansible 中，可在多个位置定义变量，但不同位置具有不同的优先级 下表显⽰了定义变量的⽅法，按优先级从低到⾼排列:</p><p>在清单中定义的组变量 </p><p>在清单或 playbook 所在⽬录的 group_vars ⼦⽬录中定义的组变量</p><p>在清单中定义的主机变量 </p><p>在清单或 playbook 所在⽬录的 host_vars ⼦⽬录中定义的主机变量</p><p>在运⾏时中发现的主机事实</p><p>playbook 中的 play 变量（vars 和 vars_files） </p><p>任务变量 </p><p>在命令⾏中定义的额外变量，使⽤ –extra-vars 或 -e 选项定义</p><h3 id="在主机清单中定义变量"><a href="#在主机清单中定义变量" class="headerlink" title="在主机清单中定义变量"></a>在主机清单中定义变量</h3><p>主机变量（它的⽣效范围只是指定的主机），组变量（只会对该组的主机⽣效）。</p><p><img src="/../../../../images/clip_image070-171730995473135.jpg" alt="img"></p><p>#在主机清单里面定义主机变量</p><p><img src="/../../../../images/clip_image072-171730995473238.jpg" alt="img"></p><p>#在主机清单里面定义主机组变量</p><p><img src="/../../../../images/clip_image074-171730995473237.jpg" alt="img"></p><h3 id="在playbook⾥⾯定义变量"><a href="#在playbook⾥⾯定义变量" class="headerlink" title="在playbook⾥⾯定义变量"></a>在playbook⾥⾯定义变量</h3><p>#在playbook里面通过关键字vars定义play的变量</p><p><img src="/../../../../images/clip_image076-171730995473136.jpg" alt="img"></p><p>#在playbook里面引入外部的变量文件内定义的变量(必须是YAML文件)</p><p><img src="/../../../../images/clip_image078-171730995473239.jpg" alt="img"></p><h3 id="创建host-vars-主机变量-和group-vars（主机组变量）"><a href="#创建host-vars-主机变量-和group-vars（主机组变量）" class="headerlink" title="创建host_vars(主机变量)和group_vars（主机组变量）"></a>创建host_vars(主机变量)和group_vars（主机组变量）</h3><p>在 host_vars 目录中为每个主机创建一个 YAML 文件，文件名与主机名匹配。</p><p><img src="/../../../../images/clip_image080-171730995473240.jpg" alt="img"></p><p>在 group_vars 目录中为每个主机组创建一个 YAML 文件，文件名与主机组名匹配。</p><p><img src="/../../../../images/clip_image082-171730995473241.jpg" alt="img"></p><h3 id="在命令⾏传⼊变量"><a href="#在命令⾏传⼊变量" class="headerlink" title="在命令⾏传⼊变量"></a>在命令⾏传⼊变量</h3><p><img src="/../../../../images/clip_image084-171730995473242.jpg" alt="img"></p><h3 id="注册变量"><a href="#注册变量" class="headerlink" title="注册变量"></a>注册变量</h3><p>它的作⽤是将上⼀个模块执⾏的结果，收集到⼀个⾃定变量⾥，可以使⽤这个变量做下⼀个任务的条件判断</p><p>测试剧本</p><p><img src="/../../../../images/clip_image086-171730995473243.jpg" alt="img"></p><p>通过register关键字，定义了一个注册变量users收 集user模块执行的结果，这个关键字要与模块名的缩进相同。</p><p>输出结果</p><p><img src="/../../../../images/clip_image088-171730995473244.jpg" alt="img"></p><h3 id="字典用作变量"><a href="#字典用作变量" class="headerlink" title="字典用作变量"></a>字典用作变量</h3><p>#变量的文件</p><p><img src="/../../../../images/clip_image090-171730995473246.jpg" alt="img"></p><p>#测试剧本，写法一</p><p><img src="/../../../../images/clip_image092-171730995473245.jpg" alt="img"></p><p>#写法二</p><p><img src="/../../../../images/clip_image094-171730995473247.jpg" alt="img"></p><p>debug模块的msg参数和var参数的区别</p><p>msg参数: </p><p>msg 参数用于输出一条静态的文本消息。</p><p>通常用于输出一些简单的信息或者调试消息，不涉及变量的使用</p><p><img src="/../../../../images/clip_image096-171730995473248.jpg" alt="img"></p><p>var参数:</p><p>vars 参数用于输出变量的值。</p><p>通常用于输出某个变量的值，以便在调试时检查变量的内容。</p><p><img src="/../../../../images/clip_image098-171730995473249.jpg" alt="img"></p><p>msg也可以输出变量的值，但是需要和var结合使用</p><p><img src="/../../../../images/clip_image100-171730995473250.jpg" alt="img"></p><h3 id="读取变量的值"><a href="#读取变量的值" class="headerlink" title="读取变量的值"></a>读取变量的值</h3><p>#使用”“格式读取变量的值</p><p><img src="/../../../../images/clip_image102-171730995473251.jpg" alt="img"></p><h2 id="管理事实（facts）"><a href="#管理事实（facts）" class="headerlink" title="管理事实（facts）"></a>管理事实（facts）</h2><h3 id="ansible-的-facts"><a href="#ansible-的-facts" class="headerlink" title="ansible 的 facts"></a>ansible 的 facts</h3><p>Ansible 事实是 Ansible 从受管主机⾃动探查到的变量 </p><p>事实由 ansible.builtin.setup 模块调取，其中包含的信息存储到可重复使⽤的变量中</p><p>甚⾄可以创建⾃定义事实，这些事实存储在受管主机上并且对于该系统来说是唯⼀的</p><p>Ansible 事实可以成为 playbook 的⼀部分。例如： </p><p>可以根据当前内核版本来重新启动服务器 </p><p>可以根据可⽤的内存来⾃定义 MySQL 配置⽂件 </p><p>可以根据主机名称来创建⽤⼾ </p><p>对Ansible 事实的利⽤⼏乎不存在任何限制借助 </p><p>Ansible 事实,可以⽅便地检索受管节点的状态,并根据其状态决定要执⾏的操作 </p><p>事实提供如下相关的信息：主机名称、内核版本、⽹络接⼝、IP 地址、操作系统版本、 各种环境变量、CPU 数量、提供的或可⽤的内存、可⽤磁盘空间</p><p>输出以 JSON 格式返回，每个值存储在⼀个 Python 字典中。管理员⽽后可以浏览字典来检索特定的值 </p><p>通常每个 play 的第⼀个 task 运⾏前都会⾃动运⾏ setup 模块，以收集事实（在 play 中 不需要特地写 setup task）</p><p>下表显⽰了从受管节点收集的、可以在 playbook 中使⽤的⼀些事实：</p><p><img src="/../../../../images/clip_image104.jpg" alt="img"></p><p>收集受管主机相关事实(只需要记住关键字，就能模糊搜索事实)</p><p><img src="/../../../../images/clip_image106.png" alt="img"></p><p>方法一</p><p><img src="/../../../../images/clip_image108.jpg" alt="img"></p><p>方法二</p><p><img src="/../../../../images/clip_image110-171730995473252.jpg" alt="img"></p><p>#fqdn相关的事实</p><p><img src="/../../../../images/clip_image112.png" alt="img"></p><p>#磁盘相关的事实</p><p>[student@workstation ansible]$ ansible group1 -m setup -a ‘filter&#x3D;<em>device</em>‘ servera | SUCCESS &#x3D;&gt; { </p><p>“ansible_facts”: { </p><p>[student@workstation ansible]$ cat fact.yml </p><p>-– </p><p>- name: test fact variables </p><p>hosts: group1 </p><p>tasks: </p><p>- name: test fact variables </p><p>ansible.builtin.debug: </p><p>msg: ““</p><p><img src="/../../../../images/clip_image114.png" alt="img"></p><p>#bios版本相关的事实变量名</p><p><img src="/../../../../images/clip_image116-171730995473253.jpg" alt="img"></p><h3 id="关闭事实收集"><a href="#关闭事实收集" class="headerlink" title="关闭事实收集"></a>关闭事实收集</h3><p>为了加快 playbook 的运⾏速度，或受控节点不⽀持 setup 模块，可将事实收集功能关闭</p><p><img src="/../../../../images/clip_image118-171730995473254.jpg" alt="img"></p><h3 id="创建自定义事实"><a href="#创建自定义事实" class="headerlink" title="创建自定义事实"></a>创建自定义事实</h3><p>管理员可以⾃⾏创建事实，将它们推送到受管节点</p><p>创建后，⾃定义事实将由 ansible.builtin.setup 模块集成和读取 </p><p>⾃定义事实可⽤于 </p><p>基于⾃定义脚本定义系统的特定值 </p><p>基于程序执⾏定义值 </p><p>如果⾃定义事实⽂件保存在 &#x2F;etc&#x2F;ansible&#x2F;facts.d ⽬录中，Ansible 可以找到该事实 </p><p>⽂件的扩展名必须为 .fact，采⽤ INI 或 JSON 格式的纯⽂本⽂件 </p><p>在 INI 事实⽂件中，⾸先是定义事实的顶级分类例如：[packages]，后跟欲定义事实的键 值对：</p><p><img src="/../../../../images/clip_image120-171730995473255.jpg" alt="img"></p><p>如果以 JSON 格式提供，则需要使⽤下列语法:</p><p><img src="/../../../../images/clip_image122-171730995473256.jpg" alt="img"></p><p>#自定义事实变量</p><p><img src="/../../../../images/clip_image124.jpg" alt="img"></p><p>#读取本机自定义事实变量（变量：ansible_local）</p><p><img src="/../../../../images/clip_image126.jpg" alt="img"></p><p>#读取远程主机自定义事实变量</p><p>ansible_local是特殊的ansible变量，用于存储主机上的自定义事实信息</p><p>hostvars变量允许你访问远程主机的变量信息，包括 自定义信息</p><h3 id="Magic-Variables-魔法变量"><a href="#Magic-Variables-魔法变量" class="headerlink" title="Magic Variables 魔法变量"></a>Magic Variables 魔法变量</h3><p>⼀些变量并⾮是 ansible.buildin.setup 模块采集的事实或配置信息，但是很有⽤，仍可 以被ansible 使⽤，成为 magic variables</p><p>有 4 种常⽤类型</p><p>hostvars：列出受管主机的⾮事实变量</p><p>group_names：列出受管主机所属的所有组</p><p>groups：列出所有 inventory 中的 groups 和 hosts</p><p>inventory_hostname：列出当前受管主机在 inventory 中定义的主机名，可能和 事实变量不同</p><p>hostvars</p><p><img src="/../../../../images/clip_image128.jpg" alt="img"></p><p>group_names</p><p><img src="/../../../../images/clip_image130.jpg" alt="img"></p><p>groups</p><p><img src="/../../../../images/clip_image132.jpg" alt="img"></p><p>inventory_hostname</p><p><img src="/../../../../images/clip_image134-171730995473257.jpg" alt="img"></p><h2 id="管理秘密"><a href="#管理秘密" class="headerlink" title="管理秘密"></a>管理秘密</h2><h3 id="管理秘密-1"><a href="#管理秘密-1" class="headerlink" title="管理秘密"></a>管理秘密</h3><p>Ansible Vault</p><p><img src="/../../../../images/clip_image136.jpg" alt="img"></p><h3 id="创建加密的文件"><a href="#创建加密的文件" class="headerlink" title="创建加密的文件"></a>创建加密的文件</h3><p><img src="/../../../../images/clip_image138.jpg" alt="img"></p><p>#交互式的创建加密文件</p><p><img src="/../../../../images/clip_image140.jpg" alt="img"></p><p>#非交互式的方式：</p><p><img src="/../../../../images/clip_image142.jpg" alt="img"></p><p>查看加密的⽂件</p><p>Ansible Vault 使⽤ ansible-vault view filename 命令查看加密的⽂件，⽽不必打开它进⾏编辑</p><p><img src="/../../../../images/clip_image144.jpg" alt="img"></p><p>编辑现有的加密⽂件</p><p>要编辑现有的加密⽂件，Ansible Vault 提供了 ansible-vault edit filename 命令</p><p>此命令将⽂件解密为⼀个临时⽂件，并允许⽤⼾编辑该⽂件。保存时，它将复制其内容并 删除临时⽂件</p><p>注意：edit ⼦命令会改写⽂件，因此仅可在进⾏更改时使⽤它。若要查看⽂件的内容⽽不进⾏更改，始终应使⽤ view ⼦命令</p><p><img src="/../../../../images/clip_image146.jpg" alt="img"></p><h3 id="加密现有的⽂件"><a href="#加密现有的⽂件" class="headerlink" title="加密现有的⽂件"></a>加密现有的⽂件</h3><p>要加密已存在的⽂件，使⽤ ansible-vault encrypt filename 命令。此命令可取多个欲加 密⽂件的名称作为参数</p><p>使⽤ –output&#x3D;OUTPUT_FILE 选项，可将加密⽂件保存为新的名称。最多只能将⼀个输⼊⽂件⽤于 –output 选项</p><p><img src="/../../../../images/clip_image148.jpg" alt="img"></p><h3 id="解密现有的⽂件"><a href="#解密现有的⽂件" class="headerlink" title="解密现有的⽂件"></a>解密现有的⽂件</h3><p>已存在的加密⽂件可以通过 ansible-vault decrypt filename 命令永久解密</p><p>在解密单个⽂件时，可使⽤ –output 选项以其他名称保存解密的⽂件</p><p><img src="/../../../../images/clip_image150.jpg" alt="img"></p><p><img src="/../../../../images/clip_image152.jpg" alt="img"></p><h3 id="更改加密⽂件的密码"><a href="#更改加密⽂件的密码" class="headerlink" title="更改加密⽂件的密码"></a>更改加密⽂件的密码</h3><p>可以使⽤命令 ansible-vault rekey filename 更改 vault 密码</p><p>此命令可⼀次性更新多个数据⽂件的密钥。它将要求提供原始密码和新密码</p><p>在使⽤ vault 密码⽂件时，使⽤ –new-vault-password-file 选项</p><p><img src="/../../../../images/clip_image154.jpg" alt="img"></p><h3 id="Playbook-和-Ansible-Vault"><a href="#Playbook-和-Ansible-Vault" class="headerlink" title="Playbook 和 Ansible Vault"></a>Playbook 和 Ansible Vault</h3><p>为了运⾏可访问通过 Ansible Vault 加密的⽂件的 playbook，需要向 ansible-playbook 命令提供其加密密码。如果运⾏命令时没有这么做，它将返回错误</p><p><img src="/../../../../images/clip_image156.jpg" alt="img"></p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="使⽤-loop-构建循环"><a href="#使⽤-loop-构建循环" class="headerlink" title="使⽤ loop 构建循环"></a>使⽤ loop 构建循环</h2><p>循环使管理员不必编写相同的多个任务</p><p>Ansible ⽀持使⽤ loop 关键字在⼀组项上迭代任务</p><p>#打印数字1 2 3 4</p><p><img src="/../../../../images/clip_image158.jpg" alt="img"></p><h3 id="循环字典列表"><a href="#循环字典列表" class="headerlink" title="循环字典列表"></a>循环字典列表</h3><p>循环列表不⼀定是简单值列表</p><p>loop 遍历数字列表，而 item 则代表每次迭代中的当前值</p><p><img src="/../../../../images/clip_image160.jpg" alt="img"> </p><p>结果</p><p><img src="/../../../../images/clip_image162.jpg" alt="img"></p><h3 id="在循环中使⽤-register-变量"><a href="#在循环中使⽤-register-变量" class="headerlink" title="在循环中使⽤ register 变量"></a>在循环中使⽤ register 变量</h3><p>可将 register 关键字⽤于输出循环的结果</p><p><img src="/../../../../images/clip_image164.jpg" alt="img"></p><h2 id="有条件地运⾏任务"><a href="#有条件地运⾏任务" class="headerlink" title="有条件地运⾏任务"></a>有条件地运⾏任务</h2><p><img src="/../../../../images/clip_image166.jpg" alt="img"></p><p>条件任务语法</p><p><img src="/../../../../images/clip_image168.jpg" alt="img"></p><p>下表显⽰⼀些条件判断运算符</p><p><img src="/../../../../images/clip_image170.jpg" alt="img"></p><p>注意：⽤于测试条件中相等的 &#x3D;&#x3D; 运算符不可与变量赋值的 &#x3D; 运算符混淆</p><p>注意：when 表达式不属于模块，必须放在模块外部</p><p><img src="/../../../../images/clip_image172.jpg" alt="img"></p><p><img src="/../../../../images/clip_image174.jpg" alt="img"></p><p><img src="/../../../../images/clip_image176.jpg" alt="img"></p><h2 id="实施-Handler-任务"><a href="#实施-Handler-任务" class="headerlink" title="实施 Handler 任务"></a>实施 Handler 任务</h2><p>Ansible 的 handlers 程序</p><p><img src="/../../../../images/clip_image178.jpg" alt="img"></p><p>使⽤ handler 程序的注意事项</p><p><img src="/../../../../images/clip_image180.jpg" alt="img"></p><p>注意：handler 程序设计为仅在任务执⾏时处理操作，它们不应当⽤于取代任务</p><p>#两次notify只会执行一次handler</p><p><img src="/../../../../images/clip_image182.jpg" alt="img"></p><p>一个任务在其notify部分中调用多个处理程序</p><p><img src="/../../../../images/clip_image184.png" alt="img"></p><h2 id="处理任务错误"><a href="#处理任务错误" class="headerlink" title="处理任务错误"></a>处理任务错误</h2><p>管理 play 中的任务错误</p><p><img src="/../../../../images/clip_image186.jpg" alt="img"></p><p>忽略失败的任务 Ignore the failed task</p><p><img src="/../../../../images/clip_image188.jpg" alt="img"></p><p>Playbook</p><p><img src="/../../../../images/clip_image190.jpg" alt="img"></p><p>执行结果</p><p><img src="/../../../../images/clip_image192.jpg" alt="img"></p><h2 id="强制执⾏处理程序-Force-execution-of-handlers"><a href="#强制执⾏处理程序-Force-execution-of-handlers" class="headerlink" title="强制执⾏处理程序 Force execution of handlers"></a>强制执⾏处理程序 Force execution of handlers</h2><p><img src="/../../../../images/clip_image194.jpg" alt="img"></p><p><img src="/../../../../images/clip_image196.jpg" alt="img"></p><p><img src="/../../../../images/clip_image198.jpg" alt="img"></p><h2 id="覆盖-failed-状态"><a href="#覆盖-failed-状态" class="headerlink" title="覆盖 failed 状态"></a>覆盖 failed 状态</h2><p><img src="/../../../../images/clip_image200.jpg" alt="img"></p><p>标准输出 (stdout): 这是命令正常执行时产生的输出。比如，你运行 ls 命令列出文件，输出的文件列表就是标准输出。</p><p>标准错误 (stderr): 如果命令执行出现了问题，错误消息通常会被发送到标准错误。例如，如果你运行 ls xxx，其中的 “xxx” 文件夹不存在，错误消息会被发送到标准错误流中</p><p>faild_when，能够指定错误，强制任务失败</p><p>原始</p><p><img src="/../../../../images/clip_image202.jpg" alt="img"></p><p>加上faild_when语句</p><p><img src="/../../../../images/clip_image204.jpg" alt="img"></p><p>fail语句</p><p><img src="/../../../../images/clip_image206.jpg" alt="img"></p><h2 id="覆盖-changed-状态"><a href="#覆盖-changed-状态" class="headerlink" title="覆盖 changed 状态"></a>覆盖 changed 状态</h2><p><img src="/../../../../images/clip_image208.jpg" alt="img"></p><p>原始结果</p><p><img src="/../../../../images/clip_image210.jpg" alt="img"></p><p>添加changed_when关键字</p><p><img src="/../../../../images/clip_image212.jpg" alt="img"></p><h2 id="Ansible-blocks-和错误处理"><a href="#Ansible-blocks-和错误处理" class="headerlink" title="Ansible blocks 和错误处理"></a>Ansible blocks 和错误处理</h2><p><img src="/../../../../images/clip_image214.jpg" alt="img"></p><p><img src="/../../../../images/clip_image216.jpg" alt="img"></p><h1 id="管理主机上的⽂件"><a href="#管理主机上的⽂件" class="headerlink" title="管理主机上的⽂件"></a>管理主机上的⽂件</h1><h2 id="描述-files-模块"><a href="#描述-files-模块" class="headerlink" title="描述 files 模块"></a>描述 files 模块</h2><p><img src="/../../../../images/clip_image218.jpg" alt="img"></p><h3 id="file模块："><a href="#file模块：" class="headerlink" title="file模块："></a>file模块：</h3><p>创建⽂件，⽬录，链接，它还可以设置⽂件的selinux,权限属性</p><p>#创建一个文件</p><p><img src="/../../../../images/clip_image220.jpg" alt="img"></p><p>#创建一个目录</p><p><img src="/../../../../images/clip_image222.jpg" alt="img"></p><h3 id="copy模块："><a href="#copy模块：" class="headerlink" title="copy模块："></a>copy模块：</h3><p>⽤来将本地的⽂件拷⻉到远程主机上，和往⽬标⽂件⾥⾯写⼊指定内容，他会在写⼊内容的时候，⽬标⽂件不存在，会创建⽂件覆盖写⼊内容</p><p>#拷贝本地文件到远程主机</p><p><img src="/../../../../images/clip_image224.jpg" alt="img"></p><p>#拷贝内容到文件内部</p><p><img src="/../../../../images/clip_image226.jpg" alt="img"></p><h3 id="fetch模块："><a href="#fetch模块：" class="headerlink" title="fetch模块："></a>fetch模块：</h3><p>拷⻉远程主机上的⽂件到控制节点</p><p><img src="/../../../../images/clip_image228.jpg" alt="img"></p><h3 id="lineinfile模块："><a href="#lineinfile模块：" class="headerlink" title="lineinfile模块："></a>lineinfile模块：</h3><p>向⽂件⾥⾯追加写⼊指定的内容，⽬标⽂件必须存在，如果不存在，它不会⾃动创建，会报错</p><p><img src="/../../../../images/clip_image230.jpg" alt="img"></p><h3 id="blockinfile模块："><a href="#blockinfile模块：" class="headerlink" title="blockinfile模块："></a>blockinfile模块：</h3><p>将⽂本内容以⽂本块的⽅式写⼊到⽬标⽂件⾥⾯，与lineinfile⼀样，⽬标⽂件不存在，会报错</p><p><img src="/../../../../images/clip_image232.jpg" alt="img"></p><h3 id="jinja2模板"><a href="#jinja2模板" class="headerlink" title="jinja2模板"></a>jinja2模板</h3><p>使⽤ Jinja2 模板部署⾃定义⽂件</p><p><img src="/../../../../images/clip_image234.jpg" alt="img"></p><p>jinja2的分隔符：</p><p><img src="/../../../../images/clip_image236.jpg" alt="img"></p><p>部署模板使⽤ansible.builtin.template模块调⽤模板。</p><p>#创建模板文件</p><p><img src="/../../../../images/clip_image238.jpg" alt="img"></p><p>#在playbook里面调用模板</p><p><img src="/../../../../images/clip_image240.jpg" alt="img"></p><p>#执行剧本，验证执行结果</p><p><img src="/../../../../images/clip_image242.jpg" alt="img"></p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>可以在模板⽂件中使⽤ Jinja2 控制结构，以减少重复键⼊，为play 中的每个主机动态输⼊条⽬， 或者有条件地将⽂本插⼊到⽂件中</p><h2 id="使⽤循环"><a href="#使⽤循环" class="headerlink" title="使⽤循环"></a>使⽤循环</h2><p>Jinja2 使⽤ for 语句来提供循环功能。下例中，users 变量具有值列表。user 变量替换为 users 变量中的所有值，⼀⾏⼀个值</p><p><img src="/../../../../images/clip_image244.jpg" alt="img"></p><p><img src="/../../../../images/clip_image246.jpg" alt="img"></p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>它可以对模板的内容做⼀个格式化输出的操作</p><p><img src="/../../../../images/clip_image248.jpg" alt="img"></p><p>#默认变量过滤器default：默认情况下，当模板⾥⾯使⽤的变量不存在，会导致任务执⾏ 失败，后续的任务也会被影响，可以使⽤默认的变量过滤器指定⼀个默认值，当模板内的 变量不存在的时候，他会输出默认的内容替代变量的值，避免他会导致的语法错误。</p><p><img src="/../../../../images/clip_image250.jpg" alt="img"></p><h1 id="编写⼤型项⽬的playbook"><a href="#编写⼤型项⽬的playbook" class="headerlink" title="编写⼤型项⽬的playbook"></a>编写⼤型项⽬的playbook</h1><h2 id="主机清单"><a href="#主机清单" class="headerlink" title="主机清单"></a>主机清单</h2><p>静态的主机清单</p><p>动态的主机清单（清单⽂件本⾝具有可执⾏性，可以结合其他的资产管理或者监控系统⾃动的获取受管主机）</p><h2 id="配置主机清单"><a href="#配置主机清单" class="headerlink" title="配置主机清单"></a>配置主机清单</h2><p>注定准确的⽂件（在这个⽂件内的主机才会被管理）</p><p><img src="/../../../../images/clip_image252.jpg" alt="img"></p><p>#指定⼀个⽬录（只要在这个⽬录下存在的⽂件都会被认为是主机清单⽂件）</p><p>主机清单还可以在执⾏剧本或者临时命令的时候通过命令⾏指定主机清单</p><h2 id="主机清单内容的组成"><a href="#主机清单内容的组成" class="headerlink" title="主机清单内容的组成"></a>主机清单内容的组成</h2><p><img src="/../../../../images/clip_image254.jpg" alt="img"></p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>* &#x2F;&#x2F;表示所有的清单内的主机</p><p><img src="/../../../../images/clip_image256.jpg" alt="img"></p><p>#列表使用，（逗号）分割组名</p><p><img src="/../../../../images/clip_image258.jpg" alt="img"></p><p>#&amp;逻辑与的关系</p><p><img src="/../../../../images/clip_image260.jpg" alt="img"></p><p>#！逻辑非，排除的意思</p><p><img src="/../../../../images/clip_image262.jpg" alt="img"></p><h2 id="配置并⾏"><a href="#配置并⾏" class="headerlink" title="配置并⾏"></a>配置并⾏</h2><p>使⽤分叉（fork）在 Ansible 中配置并⾏(fork:同时执行任务的数量)</p><p><img src="/../../../../images/clip_image264.jpg" alt="img"><img src="/../../../../images/clip_image266.jpg" alt="img"></p><p><img src="/../../../../images/clip_image268.jpg" alt="img"></p><p><img src="/../../../../images/clip_image270.jpg" alt="img"></p><h2 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h2><p><img src="/../../../../images/clip_image272.jpg" alt="img"></p><p>#百分比的书写方式，他会按照主机清单的主机数量*serial指定的百分比，往小取整</p><p><img src="/../../../../images/clip_image274.jpg" alt="img"></p><p>#可以直接指定整数</p><p><img src="/../../../../images/clip_image276.jpg" alt="img"></p><h2 id="包含或导⼊⽂件"><a href="#包含或导⼊⽂件" class="headerlink" title="包含或导⼊⽂件"></a>包含或导⼊⽂件</h2><p>导⼊playbook,使⽤关键字import_palybook:</p><p><img src="/../../../../images/clip_image278.jpg" alt="img"></p><p>导⼊任务，使⽤关键字import_tasks或者include_tasks</p><p>#创建任务列表</p><p><img src="/../../../../images/clip_image280.jpg" alt="img"></p><p># include_tasks</p><p><img src="/../../../../images/clip_image282.jpg" alt="img"></p><p>#import_tasks</p><p><img src="/../../../../images/clip_image284.jpg" alt="img"></p><h1 id="对playbook和受管主机进⾏故障排除"><a href="#对playbook和受管主机进⾏故障排除" class="headerlink" title="对playbook和受管主机进⾏故障排除"></a>对playbook和受管主机进⾏故障排除</h1><h2 id="对-playbook-进⾏故障排除"><a href="#对-playbook-进⾏故障排除" class="headerlink" title="对 playbook 进⾏故障排除"></a>对 playbook 进⾏故障排除</h2><p>显⽰任务执⾏的详细反馈</p><pre><code class="perl">ansible all -m ping -v ansible all -m ping -vv ansible all -m ping -vvv ansible all -m ping -vvvv</code></pre><p>使⽤debug模块对变量进⾏检测</p><p><img src="/../../../../images/clip_image286.jpg" alt="img"></p><p>检查playbook中的⼀些错误</p><p><img src="/../../../../images/clip_image288.jpg" alt="img"></p><h2 id="对Ansible受管主机进⾏故障排除"><a href="#对Ansible受管主机进⾏故障排除" class="headerlink" title="对Ansible受管主机进⾏故障排除"></a>对Ansible受管主机进⾏故障排除</h2><h3 id="受管主机⾝份验证问题"><a href="#受管主机⾝份验证问题" class="headerlink" title="受管主机⾝份验证问题"></a>受管主机⾝份验证问题</h3><p><img src="/../../../../images/clip_image290.jpg" alt="img"></p><h3 id="名称或地址解析问题"><a href="#名称或地址解析问题" class="headerlink" title="名称或地址解析问题"></a>名称或地址解析问题</h3><p>在主机清单⾥⾯写的是IP地址，那么调⽤的时候就⽤IP地址，如果是主机名，就⽤主机名 （需要可以DNS解析）</p><p><img src="/../../../../images/clip_image292.jpg" alt="img"></p><h3 id="特权升级问题"><a href="#特权升级问题" class="headerlink" title="特权升级问题"></a>特权升级问题</h3><p><img src="/../../../../images/clip_image294.jpg" alt="img"></p><p><img src="/../../../../images/clip_image296.jpg" alt="img"></p><p><img src="/../../../../images/clip_image298.jpg" alt="img"></p><h3 id="将检查模式⽤作测试⼯具"><a href="#将检查模式⽤作测试⼯具" class="headerlink" title="将检查模式⽤作测试⼯具"></a>将检查模式⽤作测试⼯具</h3><p><img src="/../../../../images/clip_image300.jpg" alt="img"> <img src="/../../../../images/clip_image302.jpg" alt="img"></p><h2 id="shell-、command临时命令"><a href="#shell-、command临时命令" class="headerlink" title="shell 、command临时命令"></a>shell 、command临时命令</h2><h3 id="使⽤模块进⾏测试"><a href="#使⽤模块进⾏测试" class="headerlink" title="使⽤模块进⾏测试"></a>使⽤模块进⾏测试</h3><p><img src="/../../../../images/clip_image304.jpg" alt="img"></p><p><img src="/../../../../images/clip_image306.jpg" alt="img"></p><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><h2 id="利⽤⻆⾊构建-Ansible-playbook"><a href="#利⽤⻆⾊构建-Ansible-playbook" class="headerlink" title="利⽤⻆⾊构建 Ansible playbook"></a>利⽤⻆⾊构建 Ansible playbook</h2><p>角色就是模板</p><p>数据中⼼具有许多不同类型的主机。⼀些充当 Web 服务器，另⼀些充当数据库服务器 </p><p>⼀个 Ansible playbook 中如果包含所有任务，随着时间推移将变得硕⼤⽽复杂 Ansible ⻆⾊让管理员可以将 playbook 组织为独⽴、较⼩的 playbook 和⽂件</p><p><img src="/../../../../images/clip_image308.jpg" alt="img"> <img src="/../../../../images/clip_image310.jpg" alt="img"> <img src="/../../../../images/clip_image312.jpg" alt="img"></p><p>#配置角色的路径</p><p>1、    找到原始的ansible.cfg搜索collections_path和roles_path</p><p><img src="/../../../../images/clip_image314.jpg" alt="img"></p><p>2、    添加自定义collections_path和roles_path到自己的ansible.cfg</p><p><img src="/../../../../images/clip_image316.jpg" alt="img"></p><p>3、    在该目录下创建roles和mycollections目录</p><p>#查看角色的目录结构</p><p><img src="/../../../../images/clip_image318.jpg" alt="img"></p><h2 id="在playbook⾥⾯调⽤⻆⾊完成任务"><a href="#在playbook⾥⾯调⽤⻆⾊完成任务" class="headerlink" title="在playbook⾥⾯调⽤⻆⾊完成任务"></a>在playbook⾥⾯调⽤⻆⾊完成任务</h2><p>调用已有的角色完成任务</p><p><img src="/../../../../images/clip_image320.jpg" alt="img"></p><p>#验证角色执行的结果</p><p>ansible all -m shell -a ‘chronyc sources’</p><h2 id="特殊任务部分"><a href="#特殊任务部分" class="headerlink" title="特殊任务部分"></a>特殊任务部分</h2><p><img src="/../../../../images/clip_image322.jpg" alt="img"></p><p>剧本任务</p><p><img src="/../../../../images/clip_image324.jpg" alt="img"></p><p>执行结果</p><p><img src="/../../../../images/clip_image326.jpg" alt="img"></p><h2 id="创建⻆⾊"><a href="#创建⻆⾊" class="headerlink" title="创建⻆⾊"></a>创建⻆⾊</h2><p>创建和使⽤⻆⾊三个步骤</p><pre><code class="perl">1. 创建⻆⾊⽬录结构 2. 定义⻆⾊内容 3. 在 playbook 中使⽤⻆⾊</code></pre><p>#创建角色的目录</p><p><img src="/../../../../images/clip_image328.jpg" alt="img"></p><p>#定义角色的内容</p><p><img src="/../../../../images/clip_image330.jpg" alt="img"></p><p>#调用自定义的角色</p><p><img src="/../../../../images/clip_image332.jpg" alt="img"></p><h1 id="ansible-navigator安装"><a href="#ansible-navigator安装" class="headerlink" title="ansible-navigator安装"></a>ansible-navigator安装</h1><pre><code class="perl">1、    sudo dnf install python3-pip2、    python3 -m pip install ansible-navigator –user3、    echo &#39;export PATH=$HOME/.local/bin:$PATH&#39; &gt;&gt; ~/.profile4、    source ~/.profile5、    ansible-navigator</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux - Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>systemd守护进程</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/systemd%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/systemd%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="systemd-守护进程"><a href="#systemd-守护进程" class="headerlink" title="systemd 守护进程"></a>systemd 守护进程</h1><p>1、    systemd daemon（守护进程） 管理 Linux 的启动，包括服务的启动和管理</p><p>2、    systemd 可在系统引导时以及运⾏中的系统上激活系统资源、服务器守护进程和其他进程</p><p>3、    守护进程 daemon 是在后台运⾏或等待的进程，以执⾏不同的任务。通常 daemon 在系统启 动时运⾏，知道关机 时才结束运⾏。deamon 程序名称⼀般会有 d 字符</p><p>RHEL中，PID是systemd，提供以下功能：</p><p>a、    并⾏化功能（同时启动多个服务），可提⾼系统的启动速度</p><p>b、    按需启动守护进程，⽽不需要单独的服务</p><p>c、    ⾃动服务依赖关系管理，可以防⽌ timeouts。例如，只有在⽹络可⽤时，依赖⽹络 的服务才会尝试启动</p><p>d、    利⽤ Linux cgoups 追踪相关进程资源占⽤</p><h1 id="Unit的文件实现服务喝守护进程的管理"><a href="#Unit的文件实现服务喝守护进程的管理" class="headerlink" title="Unit的文件实现服务喝守护进程的管理"></a>Unit的文件实现服务喝守护进程的管理</h1><p>简而言之：服务都是通过文件产生的，而systemd通过unit文件管理服务，unit其实就是配置文件，unit有很多类型，其就是很多类型的配置文件，可以理解为通称</p><p>unit文件存储位置：</p><p>1、&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;     </p><p>2、&#x2F;etc&#x2F;systemd&#x2F;system&#x2F; 注意:这里unit是软连接，但优先级比较高</p><h1 id="service-units"><a href="#service-units" class="headerlink" title="service units"></a>service units</h1><p>systemd 使⽤ units 管理不同类型对象，常⻅的 units 类型包括：</p><p>1、.service：代表系统服务。这种单元⽤于启动经常访问的守护进程，如 httpd.service</p><p>2、.socket：代表 systemd 监控的进程间通信（IPC）socket。如果客戶端连接到 socket， systemd 将启动⼀个 守护进程并将连接传递给它。可使⽤ socket unit 来延迟系统启动时 的服务启动，或者按需启动不常使⽤的服务</p><p>3、.path：特定⽂件系统更改发⽣之后，服务才激活。如打印系统</p><p>所有可用units(systemctl -t help)</p><p><img src="/../../../../images/clip_image002.jpg" alt="img"></p><p>列出service units</p><p>1、     systemctl list-units –type&#x3D;service 列出所有 active 状态的service unit</p><p><img src="/../../../../images/clip_image004.jpg" alt="img"></p><p>2、    systemctl list-units –type&#x3D;service –all 列出所有 serviceunit</p><p><img src="/../../../../images/clip_image006-17172987701741.jpg" alt="img"></p><p>其中：UNIT 是 service unit 名称；LOAD 是 unit 的配置加载到了内存中；ACTIVE 表⽰ unit ⾼级激活状态，表⽰ 已经启动；SUB 表⽰ unit 低级别激活状态，有更多关于 unit 的状态信息；DESCRIPTION 是 unit 的简短描述</p><p># systemctl 列出所有已经 load 和 active 的 unit</p><p><img src="/../../../../images/clip_image008.jpg" alt="img"></p><p># systemctl list-unit-files 显⽰所有已经安装的 units 状态</p><p><img src="/../../../../images/clip_image010.jpg" alt="img"></p><p>查看service状态</p><p><img src="/../../../../images/clip_image012.jpg" alt="img"></p><p><img src="/../../../../images/clip_image014.jpg" alt="img"></p><p>systemctl status 输出中的服务状态</p><p><img src="/../../../../images/clip_image016.jpg" alt="img"><img src="/../../../../images/clip_image018.jpg" alt="img"> </p><p>验证服务的状态</p><p><img src="/../../../../images/clip_image020.jpg" alt="img"></p><p>控制系统服务</p><p><img src="/../../../../images/clip_image022.jpg" alt="img"></p><p>列出 unit 依赖关系</p><p><img src="/../../../../images/clip_image024.jpg" alt="img"></p><p><img src="/../../../../images/clip_image026.jpg" alt="img"></p><p>屏蔽和取消屏蔽服务</p><p>1、系统中的不同服务可能会彼此冲突，例如http和nginx都是80端口</p><p>2、systemctl mask 命令屏蔽服务，可防⽌管理员意外启动与其他服务冲突的服务。屏蔽操 作会创建指向 &#x2F;dev&#x2F;null ⽂ 件的链接，该⽂件可阻⽌服务启动</p><p>3、systemctl unmask 命令可取消屏蔽</p><p><img src="/../../../../images/clip_image028.jpg" alt="img"></p><p>服务在系统引导时启动或停止</p><p>开机自启动：systemctl enable httpd</p><p>取消服务开机自启动：systemctl disable httpd</p><p>启动服务且开机自启服务：systemctl enable httpd –now</p><h1 id="SSH服务"><a href="#SSH服务" class="headerlink" title="SSH服务"></a>SSH服务</h1><p>识别远程用户：w命令</p><p><img src="/../../../../images/clip_image030.jpg" alt="img"></p><p>SSH远程：ssh 用户名@IP或主机名 </p><p>SSH远程操作：ssh 用户名@IP或主机名 命令</p><p>SSH主机密钥</p><p>SSH 通过公钥加密的⽅式保持通信安全。在该客戶端登录之前，服务器会向其发送公钥副本。 ⽤于设置通信渠道 的安全加密，并验证客戶端服务器</p><p>⽤⼾连接服务器时，会检查客⼾机本地 &#x2F;etc&#x2F;ssh&#x2F;ssh_known_hosts 或 ~&#x2F;.ssh&#x2F;known_hosts 中是否含有服务器公钥，并与从服务器获得公钥进⾏匹配，以验证服务器的⾝份（防⽌服务器 被假冒，或者需要编辑此⽂件替换新的 服务器秘钥）</p><p>特定⽤戶的 ~&#x2F;.ssh&#x2F;config 或系统范围的&#x2F;etc&#x2F;ssh&#x2F;ssh_config 中，将 StrictHostKeyChecking 参数设为yes，使 得 ssh 命令在公钥不匹配时始终中断 SSH 链接</p><p>服务器的公钥存放在：&#x2F;etc&#x2F;ssh&#x2F;*key.pub 中</p><p>第⼀次连接服务器时，会尝试保存从服务器获得的公钥，并要求⽤⼾确认，确认后，公钥副本 保存到： ~&#x2F;.ssh&#x2F;known_hosts</p><p><img src="/../../../../images/clip_image032.jpg" alt="img"></p><p>其中第⼀个字段是共享该公钥的主机名和 IP 地址的列表。第⼆个字段是公钥的加密算法。</p><p>最后一个字段是公钥本身</p><p>如果由于硬盘驱动器故障⽽导致公钥丢失或由于某些正当理由⽽导致公钥被更换，并由此更改了服务器的公钥， 必须编辑已知主机⽂件以将旧公钥条⽬替换为新公钥条目</p><p>生成SSH密钥</p><p>ssh-keygen 命令创建⽤⼾的公钥和私钥，默认保存在 ~&#x2F;.ssh&#x2F;id_rsa 和 ~&#x2F;.ssh&#x2F;id_rsa.pub文件中</p><p><img src="/../../../../images/clip_image034.jpg" alt="img"></p><p>私钥还可以以密码加以保护，登录时，需要输⼊私钥保护密码</p><p>私钥只能由所有者读取，为 600 权限。公钥则可被任何⼈读取，通常设置为 644 权限</p><p>共享公钥</p><p>ssh-copy-id 命令可以将⽤⼾的 SSH 公钥（默认为&#x2F;home&#x2F;user&#x2F;.ssh&#x2F;id_rsa.pub）复制到⽬标 系统中</p><p><img src="/../../../../images/clip_image036.jpg" alt="img"></p><p><img src="/../../../../images/clip_image038.jpg" alt="img"></p><p>免密是针对与⽤⼾的，不是主机</p><p>SSH连接基本故障排除</p><p>ssh 命令通过 - v、-vv 和 -vvv 选项提供三个详细程度级别，提供越来越多的调试信息</p><p><img src="/../../../../images/clip_image040.jpg" alt="img"></p><p>⾃定义 OpenSSH 配置</p><p>OpenSSH 的守护进程名为 sshd，主配置⽂件为&#x2F;etc&#x2F;ssh&#x2F;sshd_config</p><p>推荐禁⽤ root ⽤⼾远程登录和基于密码的⾝份验证（⽽使⽤公私钥验证⽅式替代）</p><p><img src="/../../../../images/clip_image042.jpg" alt="img"> <img src="/../../../../images/clip_image044.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yum-dnf-文件系统-查找</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/yum-dnf-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E6%89%BE/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/yum-dnf-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h1><h2 id="软件包"><a href="#软件包" class="headerlink" title="软件包"></a>软件包</h2><p>linux：他的可执⾏程序的elf格式的⽂件，程序运⾏时的依赖动态链接库⽂件的动态链接库文件.dll格式的文件</p><p>linux：他的可执⾏程序的elf格式的⽂件，程序运⾏时的依赖动态链接库⽂件的格式 时.so⽂件。</p><h2 id="红帽提供了⼀种安装⽅式rpm"><a href="#红帽提供了⼀种安装⽅式rpm" class="headerlink" title="红帽提供了⼀种安装⽅式rpm"></a>红帽提供了⼀种安装⽅式rpm</h2><p>提供了⼀个⼯具rpm，他可以⽀持安装，升级，卸载，查询已经编译封装好的⼆进制软件 包.rpm，他的功能更多的⽤于查询，其他的功能具备但是不推荐使⽤，因为rpm这个⼯具不能 解决软件安装时的依赖关系</p><p>#使用rpm安装软件</p><p><img src="/../../../../images/clip_image002-17172990452351.jpg" alt="img"></p><p>htop： 软件的名称。</p><p>2.2.0： 软件的版本号。</p><p>3.el8： 软件的发布号，以及支持的 Red Hat 发行版的版本号（在这个例子中是 EL8，代表 Red Hat Enterprise Linux 8）。</p><p>x86_64： 软件支持的体系结构。</p><p>#更新软件</p><p><img src="/../../../../images/clip_image004-17172990452352.jpg" alt="img"></p><p>#卸载软件</p><p><img src="/../../../../images/clip_image005.png" alt="img"></p><p>#查询功能，查看软件包是否安装</p><p><img src="/../../../../images/clip_image006.png" alt="img"></p><p>#查询软件安装后在系统里面生成哪些文件</p><p><img src="/../../../../images/clip_image008-17172990452353.jpg" alt="img"></p><p>#查看软件的配置文件</p><p><img src="/../../../../images/clip_image009.png" alt="img"></p><p>#查看软件的帮助文档保存在哪里</p><p><img src="/../../../../images/clip_image010.png" alt="img"></p><p>#查看软件安装时运行了哪些检测脚本</p><p><img src="/../../../../images/clip_image012-17172990452364.jpg" alt="img"></p><p>#查看软件相关信息</p><p><img src="/../../../../images/clip_image014-17172990452365.jpg" alt="img"></p><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p>因为rpm不能够⾃动解决依赖关系，所以为了解决这个问题，使得安装程序更加的智能，自动化，使得yum工具作为rpm全段，他会记录软件仓库内软件的依赖关系。</p><p>安装的软件的时 候，他会先查询依赖关系，然后再软件仓库内下载对应版本的依赖软件，然后安装软件。</p><p>yum是dnf的链接⽂件，但是yum使⽤的命令和dnf除了命令 的名字不⼀样以外，其他的选项参数都是⼀样的。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><img src="/../../../../images/clip_image016-17172990452367.jpg" alt="img"></p><h3 id="配置⽂件的选项"><a href="#配置⽂件的选项" class="headerlink" title="配置⽂件的选项"></a>配置⽂件的选项</h3><p><img src="/../../../../images/clip_image018-17172990452366.jpg" alt="img"></p><p>注意：建议不要源不要超过3个，name不可以重复，名字可以随便取</p><p>baseurl可以是本地的仓库，http，ftp，但是必须可以正常访问</p><h2 id="dnf工具的使用"><a href="#dnf工具的使用" class="headerlink" title="dnf工具的使用"></a>dnf工具的使用</h2><p>#验证仓库的配置文件是否正确</p><p><img src="/../../../../images/clip_image020-17172990452368.jpg" alt="img"></p><p><img src="/../../../../images/clip_image022-17172990452369.jpg" alt="img"></p><p>#清除本地的依赖关系缓存</p><p><img src="/../../../../images/clip_image024-171729904523610.jpg" alt="img"></p><p>#安装软件、更新软件、卸载软件、搜索软件是否存在与软件仓库内、查看软件的详细信息、通过命令字查询软件包的名字</p><p>dnf install &#x2F; dnf update &#x2F; dnf remove &#x2F; dnf search &#x2F; dnf info &#x2F; dnf provides </p><p>查看一个文件属于哪个软件包</p><p><img src="/../../../../images/clip_image026-171729904523611.jpg" alt="img"></p><h3 id="组安装"><a href="#组安装" class="headerlink" title="组安装"></a>组安装</h3><p>将实现某个功能(虚拟主机、图形化服务器)所需要的所有的软件包困在⼀起安装</p><p>#组安装：dnf groupinstall -y “Virtualization Host”</p><p>注意：如果有特殊符号或空格就要+双引号</p><p>#卸载包组：dnf groupremove -y “Virtualization Host”</p><h3 id="Baseos-和-Appstream"><a href="#Baseos-和-Appstream" class="headerlink" title="Baseos 和 Appstream"></a>Baseos 和 Appstream</h3><p>他们都是软件仓库组件，主要用于分离操作系统和应用程序流</p><p>Baserul：是一个包含操作系统的基本组件的软件仓库。这个仓库包括核心的系统库、命令行工具、核心服务等。</p><p>Appstream：是包含应用程序和附加软件的软件仓库。这个仓库中包含了各种应用程序、库和附加工具，为用户提供更广泛的软件选择。</p><p>AppStream 使用了模块化(module)的方法，允许用户选择不同版本的软件（例如，不同版本的数据库、编程语言等）。</p><p>区别：</p><p>Baseurl不能下载指定的软件，而Appstream可以下载指定版本的软件。</p><p>baseos 关注于提供操作系统的核心部分，而 appstream 则关注于提供用户和应用程序所需的各种软件。</p><p>#在module中查看自己的软件</p><p><img src="/../../../../images/clip_image028-171729904523613.jpg" alt="img"></p><p>nginx module 有4个stream(对应4个版本），默认安装的是1.14，1.14这个stream只有一个profile “common”, 它也是默认安装的profile </p><p>[d]efault, [e]nabled, [x]disabled, [i]nstalled</p><p>#安装module：dnf module install -y module_name:version</p><p>#卸载module：dnf module remove -y module_name:version</p><p>#重置module：dnf module reset module_name</p><p>#启动module：dnf module enable module</p><h1 id="查询文件"><a href="#查询文件" class="headerlink" title="查询文件"></a>查询文件</h1><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p>Ext4 (Fourth Extended Filesystem)：</p><p>特点： 是 Ext 文件系统家族的最新版本。支持大容量、大文件和快速恢复。</p><p>适用场景： 适合大多数普通用途的文件系统，广泛用于桌面和服务器系统。</p><p>XFS (XFS File System)：</p><p>特点： 针对大容量文件系统的性能进行了优化，支持高性能的读写操作，特别适用于大型文件和高性能要求的工作负载。</p><p>适用场景： 适合大型数据集和高性能存储需求的系统，如数据库服务器</p><p>在企业服务器集 群中，共享磁盘使⽤ GFS2⽂件系统来管理并发多节点访问</p><h2 id="文件系统和挂载点"><a href="#文件系统和挂载点" class="headerlink" title="文件系统和挂载点"></a>文件系统和挂载点</h2><p>挂载点</p><p><img src="/../../../../images/clip_image030-171729904523612.jpg" alt="img"></p><p>挂载⽀持⼿动挂载(使⽤mount命令挂载)和⾃动挂载（编辑&#x2F;etc&#x2F;fstab⽂件）</p><p><img src="/../../../../images/clip_image032-171729904523614.jpg" alt="img"></p><p><device>：要挂载的设备或分区的设备文件路径（如 &#x2F;dev&#x2F;sda1）或 UUID。</device></p><p><mount_point>：挂载点，文件系统将被挂载到这个目录。</mount_point></p><p><fs_type>：文件系统类型，例如 ext4、ntfs、xfs 等。</fs_type></p><p><options>：挂载选项，包括读写权限、挂载时的行为等。</options></p><p><dump>：用于备份工具的标志，通常设置为 0 表示不备份。</dump></p><p><pass>：用于 fsck 工具的标志，通常设置为 1 表示在系统引导时检查。</pass></p><h2 id="⽂件系统、存储和块设备"><a href="#⽂件系统、存储和块设备" class="headerlink" title="⽂件系统、存储和块设备"></a>⽂件系统、存储和块设备</h2><p>Linux 中，对存储设备的低级别访问是访问 block device ⽂件</p><p>在挂载这些 block device 前，必须先使⽤⽂件系统对其进⾏格式化 block device 存储在 &#x2F;dev ⽬录中</p><p>块设备是不能格式化，只有分区才能格式化</p><p>在 RHEL 中，第⼀个 SATA&#x2F;PATA、SAS、SCSI 或 USB 设备称为 &#x2F;dev&#x2F;sda， 第⼆个 被称为 &#x2F;dev&#x2F;sdb，以此类推(lsblk命令查看)</p><p>块设备命名：</p><p><img src="/../../../../images/clip_image034-171729904523615.jpg" alt="img"></p><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><p>存储设备通常划分为更⼩的区块，称为分区</p><p>不同分区可以通过不同的⽂件系统进⾏格式化或⽤于不同的⽤途</p><p>分区本⾝就是块设备。例如，第⼀磁盘上的第⼀个分区是&#x2F;dev&#x2F;sda1。第⼆磁盘上的 第三个分区是 &#x2F;dev&#x2F;sdb3，vda 分区类似</p><p>NVMe SSD 命名略有不同。第⼀磁盘上的第⼀个分区是&#x2F;dev&#x2F;nvme0p1。 第⼆磁盘上 的第三个分区是 &#x2F;dev&#x2F;nvme1p3，SD 或 MMC 存储卡分区类似</p><p><img src="/../../../../images/clip_image036-171729904523616.jpg" alt="img"></p><h2 id="逻辑卷"><a href="#逻辑卷" class="headerlink" title="逻辑卷"></a>逻辑卷</h2><p>逻辑卷管理（LVM）可⽤于整理磁盘和分区。</p><p>⼀个或多个块设备可以汇集为⼀个存储 池，称为卷组。卷组中的磁盘空间被分配到⼀个或多个逻辑卷，它们的功能等同于物理磁 盘上的分区</p><p>LVM 的⽬录结构类似：&#x2F;dev&#x2F;myvg&#x2F;mylv，其中 myvg 为volume group，mylv 为 logicalvolume（注：&#x2F;dev&#x2F;mapper&#x2F;myvg_mylv 是另⼀种命名⽅式）</p><h2 id="检查文件系统"><a href="#检查文件系统" class="headerlink" title="检查文件系统"></a>检查文件系统</h2><p>df 命令可以查看⽂件系统的空间状况</p><p><img src="/../../../../images/clip_image038-171729904523617.jpg" alt="img"></p><p>du 命令可以查看特定⽬录使⽤空间状况，同样可以使⽤ -h 和 -H选项</p><p>-h：显示的文件大小以更易读的方式呈现</p><p>-H：仅在计算目录大小时，将符号链接视为目录而非文件</p><p><img src="/../../../../images/clip_image039.png" alt="img"></p><p>卸载⽂件系统：umount 命令可以⼿动协助⽂件系统</p><p>查看分区的UUID：blkid &#x2F;dev&#x2F;sda1</p><h2 id="完整的创建分区，格式化，挂载的操作"><a href="#完整的创建分区，格式化，挂载的操作" class="headerlink" title="完整的创建分区，格式化，挂载的操作"></a>完整的创建分区，格式化，挂载的操作</h2><p>#创建分区</p><p>1、    选择你要分区的磁盘(查看 lsblk)</p><p>2、    创建分区(fdisk) 例如：fdisk &#x2F;dev&#x2F;vdb</p><p>3、    选择创建主分区(n)</p><p>4、    选择分区ID(1-4)</p><p>5、    选择分区开始大小(建议选择默认)，选择分区结束大小(+nG)</p><p>6、    可查看自己的划分情况(p)</p><p>7、    保存退出(w)</p><p><img src="/../../../../images/clip_image041-171729904523619.jpg" alt="img"></p><p>#格式化分区</p><p><img src="/../../../../images/clip_image043-171729904523618.jpg" alt="img"></p><p>#编辑自动挂载</p><p><img src="/../../../../images/clip_image045-171729904523621.jpg" alt="img"></p><p>mount -a：尝试挂载&#x2F;etc&#x2F;fstab文件中列出的所有文件系统，如果配置错误会报错，也可以用于检测配置文件。</p><p>#查看分区的UUID</p><p><img src="/../../../../images/clip_image047-171729904523620.jpg" alt="img"></p><h1 id="在系统中搜索文件"><a href="#在系统中搜索文件" class="headerlink" title="在系统中搜索文件"></a>在系统中搜索文件</h1><p>locate 命令搜索预⽣成索引中的⽂件名或⽂件路径，并即时返回结果(维护了⼀个数据库，可能因为数据库更新的不及时⽽导致查询结果不准确，可以使⽤updatedb手动更新数据库，-i 选项执⾏不区分⼤⼩写的搜索，-n 选项限制 locate 命令返回的搜 索结果数量) </p><p>find 命令通过遍历整个⽂件系统来实时搜索⽂件（可能会⽐较慢）</p><p>#文件名称搜索</p><p><img src="/../../../../images/clip_image048.png" alt="img"></p><p>#通过用户名搜索文件</p><p><img src="/../../../../images/clip_image050.jpg" alt="img"></p><p>#通过用户组的名称搜索文件</p><p><img src="/../../../../images/clip_image051.png" alt="img"></p><p>#通过UID搜素文件</p><p><img src="/../../../../images/clip_image053-171729904523622.jpg" alt="img"></p><p>#通过权限搜索文件</p><p><img src="/../../../../images/clip_image055-171729904523623.jpg" alt="img"></p><p><img src="/../../../../images/clip_image057-171729904523624.jpg" alt="img"></p><p>#指定匹配的文件类型 f文件 d目录 l链接</p><p><img src="/../../../../images/clip_image059-171729904523625.jpg" alt="img"></p><p>#指定文件大小进行查找</p><p><img src="/../../../../images/clip_image061-171729904523626.jpg" alt="img"></p><p><img src="/../../../../images/clip_image063-171729904523627.jpg" alt="img"></p><p>#表示排除的方法</p><p><img src="/../../../../images/clip_image065-171729904523628.jpg" alt="img"></p><h1 id="web版的系统管理平台"><a href="#web版的系统管理平台" class="headerlink" title="web版的系统管理平台"></a>web版的系统管理平台</h1><p><img src="/../../../../images/clip_image067-171729904523629.jpg" alt="img"></p><p><img src="/../../../../images/clip_image069.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="系统的启动过程"><a href="#系统的启动过程" class="headerlink" title="系统的启动过程"></a>系统的启动过程</h1><h2 id="target的切换⽅式"><a href="#target的切换⽅式" class="headerlink" title="target的切换⽅式"></a>target的切换⽅式</h2><p><img src="/../../../../images/clip_image002-17172993022871.jpg" alt="img"><img src="/../../../../images/clip_image004-17172993022874.jpg" alt="img"><img src="/../../../../images/clip_image006-17172993022872.jpg" alt="img"></p><h2 id="重置root密码"><a href="#重置root密码" class="headerlink" title="重置root密码"></a>重置root密码</h2><p><img src="/../../../../images/clip_image008-17172993022873.jpg" alt="img"></p><p><img src="/../../../../images/clip_image010-17172993022875.jpg" alt="img"></p><p><img src="/../../../../images/clip_image012-17172993022887.jpg" alt="img"></p><p>上图的第四⾏从后⾯开始删除，⼀直到ro,改成rw 加上rd.break， 按下ctrl + x 强制系统进⼊ 单⽤⼾模式。</p><p><img src="/../../../../images/clip_image014-17172993022876.jpg" alt="img"></p><p>1、切换⽂件系统 2、修改root⽤⼾密码（不需要原始密码） </p><p>3、重新打selinux标签 4、退出单⽤⼾模式 5、退出</p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件-目录-变量-引号</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95-%E5%8F%98%E9%87%8F-%E5%BC%95%E5%8F%B7/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95-%E5%8F%98%E9%87%8F-%E5%BC%95%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>创建目录</p><p>mkdir 创建一个或多个目录或子目录</p><p>例： mkdir dir1 dir2</p><p>mkdir -p 创建目录树，即创建多级目录</p><p><img src="/../../../../images/clip_image002-17172980934841.gif" alt="img"></p><p>创建(touch)</p><p>①文件不存在，他会创建文件，记录文件的创建时间 </p><p>②文件存在，他会修改文件的时间戳</p><p><img src="/../../../../images/clip_image004-17172980934842.gif" alt="img"></p><p>复制文件和目录</p><p>cp 将一个或多个文件复制到某一目录中，如果目标已存在，cp可覆盖该文件</p><p><img src="/../../../../images/clip_image006-17172980934846.gif" alt="img"></p><p>cp -r 递归，可复制目录以及其子目录</p><p>移动文件和目录</p><p>mv 可将文件从一个位置移动到另一个位置，如果位置相同，则重命名</p><p>-f 强制覆盖 -i 交互移动(会询问用户) -n 如果目标文件已存在，不移动</p><p>应用：可边移动边重命名</p><p><img src="/../../../../images/clip_image008-17172980934843.gif" alt="img"></p><p>删除目录</p><p>rmdir  只能删除空目录</p><p>rm -rf 能够删除文件、目录</p><p><img src="/../../../../images/clip_image010-17172980934844.gif" alt="img">删除(rm)</p><p><img src="/../../../../images/clip_image012-17172980934845.gif" alt="img"></p><p>rm file1 文件时需要询问对方，原因是rm的别名是“rm -i”</p><p>文件的链接类型</p><p>现象描述</p><p>当把原文件删除之后，通过软链接是无法访问，通过硬链接是可以访问的</p><p>软链接(类似windows的快捷方式)</p><p>作用：专门指向某一个文件,删除了这个软链接文件，等于断开这个链接，原文件不会受到影响，但如果原始文件被删除，软链接文件就不能打开</p><p>软链接会建立inode</p><p>硬链接</p><p>新的硬链接和原始文件的一切属性和内容完全相同，同步更新</p><p>硬链接不会建立inode，删除硬链接时，系统会检查这个文件的inode，如果大于等于1，inode不会被回收，自然文件的内容不会被删除</p><p>软链接可以跨文件系统，硬链接不可以；</p><p>软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,硬链接不可以（其文件必须存在，inode必须存在）；</p><p>软链接可以对目录进行连接，硬链接不可以。</p><p>两种链接都可以通过命令 ln 来创建。ln 默认创建的是硬链接。</p><p>使用 -s 开关可以创建软链接</p><p>硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块</p><p>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径</p><p>ln 默认选项是硬链接， -s 软链接</p><p>硬链接</p><p><img src="/../../../../images/clip_image014-17172980934857.gif" alt="img"></p><p>这两个文件如同一个文件，inode值相同，都指向同一个区块。</p><p>只有存在至少一个硬链接时，尽管原文件被删除，该文件的内容依然可以用。</p><p>软链接</p><p>软链接的inode和原文件的inode不一样，且有了一个1的flag</p><p><img src="/../../../../images/clip_image016-17172980934858.gif" alt="img"></p><p>大括号{}扩展：</p><p><img src="/../../../../images/clip_image018-171729809348510.gif" alt="img"></p><p>变量扩展</p><p>变量：把字符或命令的执行结果等赋值给变量</p><p>$：读取变量的值</p><p>$()或者·反引号·</p><p><img src="/../../../../images/clip_image020-17172980934859.gif" alt="img"></p><p>以下是临时变量，加{}是为了避免其他shell扩展而引起的错误</p><p><img src="/../../../../images/clip_image022-171729809348511.gif" alt="img"></p><p>反斜杠()是转义字符，可防止紧随其后的字符被扩展</p><p>单引号、双引号、反引号在变量的区别</p><p>单引号：只会解析字面量的形式显示引号内的内容</p><p>双引号：会解析变量，但是不会解释命令</p><p>反引号：它会同时解析命令和变量</p><p><img src="/../../../../images/clip_image024-171729809348512.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志-时间-网络</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E6%97%A5%E5%BF%97-%E6%97%B6%E9%97%B4-%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E6%97%A5%E5%BF%97-%E6%97%B6%E9%97%B4-%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>日志用途：就是当系统出现故障的时候，有⼀个能够提供故障排除的参考依据的功能，⽇志 会记录系统内发⽣的时间，以及故障的产⽣原因等，还有如果发⽣了⼀些安全时间，⽇志能够 提供事件朔源的依据。</p><p>rhel9系统中有两个日志相关的服务：rsyslog和systemd-journal</p><p>systemd-journe：会记录系统内核启动过程的⽇志，记录的⽇志更加详细，不过他默认不会持久保存，当 系统重启后，重启前的⽇志会被删除，所以如果需要持久保存，需要做相应的配置实现</p><p>rsyslog服务：可以⾃定义⽇志的⽬的地，并且形成可以使⽤vim 、cat等⼯具查看的⽂本类型的 ⽇志。系统⼿机⽇志基于syslog协议。</p><p>1.1     rsyslog服务</p><p><img src="/../../../../images/clip_image002-17172988468811.jpg" alt="img"></p><p>服务的配置文件：</p><p><img src="/../../../../images/clip_image004-17172988468822.jpg" alt="img"></p><p>解析rsyslog服务的配置文件(&#x2F;etc&#x2F;rsyslog.conf)</p><p><img src="/../../../../images/clip_image006-17172988468824.jpg" alt="img"></p><p><img src="/../../../../images/clip_image008-17172988468823.jpg" alt="img"><img src="/../../../../images/clip_image010-17172988468825.jpg" alt="img"><img src="/../../../../images/clip_image012-17172988468826.jpg" alt="img"><img src="/../../../../images/clip_image014-17172988468827.jpg" alt="img"><img src="/../../../../images/clip_image016-17172988468828.jpg" alt="img"><img src="/../../../../images/clip_image018-17172988468829.jpg" alt="img"><img src="/../../../../images/clip_image020-171729884688210.jpg" alt="img"></p><p>日志的设备类型：</p><p><img src="/../../../../images/clip_image022-171729884688211.jpg" alt="img"><img src="/../../../../images/clip_image024-171729884688212.jpg" alt="img"></p><p>日志的级别：</p><p><img src="/../../../../images/clip_image026-171729884688214.jpg" alt="img"></p><p>注意：none，表示除外</p><p>常用的日志文件：</p><p><img src="/../../../../images/clip_image028-171729884688213.jpg" alt="img"></p><p>rsyslog日志服务的日志格式：</p><p><img src="/../../../../images/clip_image030-171729884688215.jpg" alt="img"></p><p>第一列：⽇志发⽣时间戳</p><p>第二列：发送信息的主机</p><p>第三列：发送信息的程序名和PID编号</p><p>第四列：具体的⽇志事件</p><p>日志的监控：</p><p>tail -f 可以动态的监控⽂件内容的变化，他同样可以⽤来调试系统的时候监控⽇志⽂件</p><p>⼿动发送 Syslog 消息（调试⽇志服务的配置）</p><p>logger 命令可将消息发送到 rsyslog 服务。默认情况下，它将优先级为 notice 的消息发 送给 user 类型的设备 (user.notice)，除⾮通过 -p 选项另有指定</p><p>若要向 rsyslog 服务发送消息并记录在 &#x2F;var&#x2F;log&#x2F;boot.log ⽇志⽂件中</p><p><img src="/../../../../images/clip_image031.png" alt="img"><img src="/../../../../images/clip_image033.jpg" alt="img"></p><p>rsyslog服务配置⽂件修改后要重启服务，⽇志的⽂件不要⼿⼯修改，否则可能会导致rsyslog 服务不会往⽇志⽂件⾥⾯再保存消息。</p><p>日志文件轮转</p><p>为什么需要日志轮转？</p><p>因为rsyslog服务会将系统⽇志记录在指定的⽂件⾥⾯，使⽤的时间⽐较久的话，会导致⽇志的 体积越来越⼤，会占⽤系统的磁盘空间，所以有⼀套机制，通过指定⽇志⽂件的⼤⼩，或者写 ⼊⽇志的时间，将⽇志的保存⽂件尽⼼分割，将分割保存的⽇志，按照默认的时间会删除时间 ⽐较久远的旧⽇志，这样就能够控制⽇志的磁盘占⽤。</p><p>logrotate ⼯具轮转⽇志⽂件，防⽌ &#x2F;var&#x2F;log 空间被占满</p><p>轮转时，重命名⽇志⽂件（添加时间戳），并创建新的⽇志⽂件</p><p>轮转若⼲次（默认4次（周）），丢弃最旧的⽇志⽂件，释放磁盘空间</p><p>每天都会计划运⾏ logrotate 程序，轮转频率依据配置⽂件定义</p><p><img src="/../../../../images/clip_image035.jpg" alt="img"></p><p>systemd-journal</p><p>配置文件</p><p><img src="/../../../../images/clip_image037.jpg" alt="img"></p><p><img src="/../../../../images/clip_image039.jpg" alt="img"></p><p>存储模式有三种：</p><p>\1.  persistent：永久保存在&#x2F;var&#x2F;log&#x2F;journal ⽬录中</p><p>\2.  voltile：临时保存在 &#x2F;run&#x2F;log&#x2F;journal ⽬录中</p><p>\3.  auto（默认）：如果有 &#x2F;var&#x2F;log&#x2F;journal ⽬录存在，则永久保存，如果没有则临时保存</p><p>在rhel9系统⾥⾯，systemd-jounal服务创建持久保存⽬录&#x2F;var&#x2F;log&#x2F;journal，需要重启系统使其配置⽣效</p><p>systemd-journal服务的⽇志，他是二进制的文件</p><p>systemd-journal提供了⼀个专⽤⼯具，⽤来查看systemd-journal的⽇志，journalctl</p><p>在系统⽇志中查找事件</p><p>systemd-journald 将⽇志存放在带索引的结构化⼆进制 journal⽂件中，默认存放在 &#x2F;run&#x2F;log ⽬录中</p><p>journalctl 命令可⽤于检索⽇志信息，建议以 root ⽤⼾执⾏</p><p>journalctl -p debug、info、notice、warning、err、crit、alert 和 emerg显⽰该级别及其之上的⽇志</p><p><img src="/../../../../images/clip_image041.jpg" alt="img"></p><p>journalctl -n 指定显⽰最后10条⽇志，也可以指定条⽬数量</p><p><img src="/../../../../images/clip_image043.jpg" alt="img"></p><p>journalctl -f 刷新⽇志(动态)，Ctrl+C 退出 </p><p><img src="/../../../../images/clip_image045.jpg" alt="img"></p><p>journalctl -u 显⽰ systemd unit 的信息</p><p><img src="/../../../../images/clip_image047.jpg" alt="img"></p><p>journalctl –since –until “YYYY-MM-DDhhmm:ss” yesterday、today和tomorrow可以指定⽇志时间段</p><p><img src="/../../../../images/clip_image049.jpg" alt="img"><img src="/../../../../images/clip_image051.jpg" alt="img"></p><p>journalctl -o verbose 显⽰更加详细的⽇志信息</p><p><img src="/../../../../images/clip_image053.jpg" alt="img"></p><p>journalctl 配合以下字段，可以搜索特定内容的⽇志 </p><p>可参考: man 7 systemd.journal-filelds</p><p>_COMM 是命令的名称</p><p>_EXE 是进程的可执⾏⽂件的路径</p><p>_PID 是进程的 PID </p><p>_UID 是运⾏该进程的⽤戶的 UID</p><p>_SYSTEMD_UNIT 是启动该进程的 systemd 单元</p><p><img src="/../../../../images/clip_image055.jpg" alt="img"><img src="/../../../../images/clip_image057.jpg" alt="img"></p><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><p>时间对服务的运行起着至关重要，服务的时间与系统时间误差较大，可能会导致服务起不来。</p><p>rhel9系统提供了⼀个专⽤的⼯具timedatectl命令⽤来管理系统的时间、始终服务等操作</p><p>timedatectl</p><p><img src="/../../../../images/clip_image059.jpg" alt="img"></p><p>查看系统当前的时间设置</p><p><img src="/../../../../images/clip_image061.jpg" alt="img"></p><p>列出时区：timedatectl list-timezones</p><p><img src="/../../../../images/clip_image063.jpg" alt="img"></p><p>tzselect：⽤来辅助查看系统的时区</p><p><img src="/../../../../images/clip_image065.jpg" alt="img"></p><p>通过选择你所在需要的时区，然后会给出一个具体市区位置</p><p><img src="/../../../../images/clip_image067.jpg" alt="img"></p><p>修改时区</p><p><img src="/../../../../images/clip_image068.png" alt="img"></p><p>修改时间</p><p><img src="/../../../../images/clip_image070.jpg" alt="img"></p><p>重置&#x2F;同步时间</p><p>1、chronyd -q</p><p><img src="/../../../../images/clip_image072.jpg" alt="img"></p><p>2、ntpdate time.nist.gov</p><p>注意：以上需要连接网络</p><p>chronyd</p><p>rhel9的系统⾥⾯，使⽤chrony服务作为ntp服务</p><p><img src="/../../../../images/clip_image073.png" alt="img"></p><p>配置文件目录:</p><p><img src="/../../../../images/clip_image075.jpg" alt="img"><img src="/../../../../images/clip_image077.jpg" alt="img"></p><p>重启chronyd服务，使得时间⽣效</p><p><img src="/../../../../images/clip_image078.png" alt="img"></p><p>验证ntp服务是否⽣效</p><p><img src="/../../../../images/clip_image080.jpg" alt="img"></p><p>如果配置的时间服务器是不存在的，则不会显示 * IP&#x2F;域名</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>旧版红帽企业 Linux 将 eth0、eth1 和 eth2 等名称⽤于各个⽹络接⼝</p><p>当设备添加和移除，命名的机制可能会导致命名变化。⽽且 PCIe标准⽆法保证在启动 时检测 PCIe 设备的顺序</p><p>RHEL 7 起开始采⽤新的命名体系，基于固件信息、PCI 总线拓扑和⽹络设备类型，⽽且不会更改</p><p>开头为接⼝类型：以太⽹接⼝ en，WLAN 接⼝ wl</p><p>紧接为固件信息或 PCI 设备位置信息</p><p>oN 为板载设备，例如 eno1为板载以太⽹设备 1</p><p>sN 为 PCI 热插拔设备，例如 ens3 表⽰ PCI 热插拔插槽 3 中的以太⽹卡</p><p>注意：板载设备是指板载网卡、板载声卡等直接嵌入主板上，不需要用户单独购买或插入</p><p>pMsN 为位于插槽 N 中总线 M 上的 PCI 设备，例如 enp0s1f0接⼝是插槽 1 中总 线 0 上的以太⽹卡的功能 0。可能还有⼀个名为enp0s1f1 的接⼝，它代表了同⼀设备的 功能 1，wlp4s0 表⽰插槽 0中 PCI 总线 4 上的 WLAN 卡</p><p>主机名和IP地址</p><p>Linux 有多种机制可以将主机名映射到 IP 地址，统称为名称解析 </p><p>静态设置：&#x2F;etc&#x2F;hosts 中⼿动更新 </p><p>DNS 动态获取：由 dhcp 或 &#x2F;etc&#x2F;resolve.conf 中配置的 dns 服务器来获取</p><p>查看主机名信息：</p><p><img src="/../../../../images/clip_image082.jpg" alt="img"></p><p><img src="/../../../../images/clip_image083.png" alt="img"></p><p>查看网络接口信息</p><p>ifconfig、ip、ip link</p><p>ifconfig少用，因为越来越少人维护了</p><p><img src="/../../../../images/clip_image085.jpg" alt="img"><img src="/../../../../images/clip_image087.jpg" alt="img"></p><p>ip link 命令列出系统上所有可⽤⽹络接⼝的名称和 MAC 地址</p><p><img src="/../../../../images/clip_image089.jpg" alt="img"></p><p>p -s link show 命令可以查看⽹络性能统计信息，包括收到 (RX)和传出 (TX) 的数据包 数、数据包错误数，以及丢 弃的数据包数</p><p><img src="/../../../../images/clip_image091.jpg" alt="img"></p><p>ip route 命令显⽰路由信息</p><p><img src="/../../../../images/clip_image093.jpg" alt="img"></p><p>traceroute 或 tracepath 追踪⽹络流量通过多个路由器到达远程主机⽽采⽤的路径</p><p><img src="/../../../../images/clip_image095.jpg" alt="img"></p><p>使⽤ ss 或 netstat 显⽰⽹络连接信息，ss ⽤以替换 netstat（不⼀定安装 net-tools 软件包）</p><p><img src="/../../../../images/clip_image097.jpg" alt="img"></p><p>使⽤命令⾏配置⽹络</p><p>网络管理的服务:  NetworkManager.service</p><p><img src="/../../../../images/clip_image099.jpg" alt="img"></p><p>RHEL9 中使⽤ NetworkManager 监控和管理⽹络，nmcli 命令配置⽹络，配置默认 以 INI 格式保存 在&#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F; ⽬录中</p><p>8版本的网络配置文件&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</p><p><img src="/../../../../images/clip_image101.png" alt="img"></p><p>9版本的网络配置文件&#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F;</p><p><img src="/../../../../images/clip_image103.jpg" alt="img"></p><p>9版本还存在8版本的网络配置文件用于兼容早期版本，&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F; ⽬录和 ifcfg 格式配置⽂件已被弃⽤，但为 了与较早版本兼 容，&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F; ⽬录中的 ifcfg 格式连接仍可识别 和加载</p><p>root ⽤⼾才能修改⽹络配置</p><p>device 指⽹络接⼝；connection 是针对 device 的配置集合</p><p>针对任⼀device，同⼀时间只有⼀个 connection 处于活动状态</p><p>每个 connection 具有⼀个名称或 ID</p><p><img src="/../../../../images/clip_image105.jpg" alt="img"><img src="/../../../../images/clip_image107.jpg" alt="img"></p><p>NetworkManage服务提供2个操作⽹络的命令：nmcli(命令⾏⼯具) nmtui（图形化的⼯具）</p><p>nmcli</p><p>查看联网信息</p><p><img src="/../../../../images/clip_image109.jpg" alt="img"></p><p><img src="/../../../../images/clip_image111.jpg" alt="img"></p><p>添加网络连接</p><p>查看nmcli帮助文档</p><p><img src="/../../../../images/clip_image113.jpg" alt="img"></p><p>为⽹络接⼝设置⼀个DHCP⽅式获取地址的⽹络链接</p><p><img src="/../../../../images/clip_image115.jpg" alt="img"></p><p><img src="/../../../../images/clip_image117.jpg" alt="img"></p><p>使⽤静态的⽅式配置⼀个⽹络链接</p><p><img src="/../../../../images/clip_image119.jpg" alt="img"><img src="/../../../../images/clip_image121.jpg" alt="img"></p><p>删除网络连接</p><p>nmcli con del name 命令删除连接，同时删除 connection 配置⽂件</p><p><img src="/../../../../images/clip_image123.jpg" alt="img"></p><p>编辑⽹络配置⽂件</p><p>默认情况下，通过 nmcli con mod name 进⾏的更改会⾃动保存到 &#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F; 中</p><p>⽀持⼿动编辑此⽂件（但不推荐，怕写错配置内容），然后运⾏ nmcli con reload 以便NetworkManager 读取配置更改</p><p>以前存储在 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F; 的 ifcfg 格式配置将继续有效</p><p>下图为 NetworkManager 设置和 INI ⽂件格式⽂件的⽐较</p><p><img src="/../../../../images/clip_image125.jpg" alt="img"><img src="/../../../../images/clip_image127.jpg" alt="img"></p><p>修改网络配置</p><p>&#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F;持久</p><p>&#x2F;run&#x2F;NetworkManager&#x2F;system-connections临时</p><p>&#x2F;usr&#x2F;lib&#x2F;NetworkManager&#x2F;system-connections&#x2F;待定  </p><p>&#x2F;usr&#x2F;lib&#x2F;NetworkManager&#x2F;system-connections&#x2F; 系统安装时就生效，用于确保系统在初始启动时能够自动连接到网络，无需用户干涉</p><p>修改完配置后，使⽤ nmcli con reload 读取配置更改，同时还需要将接⼝重启启动</p><p><img src="/../../../../images/clip_image129.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管道符</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E7%AE%A1%E9%81%93%E7%AC%A6/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E7%AE%A1%E9%81%93%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>管道符 |</p><p>“|”作用：将前一个命令的输出作为后一个命令的输入</p><p><img src="/../../../../images/clip_image001.png" alt="img"></p><p>tee</p><p>作用：⾸先将命令的执⾏结果让他正常显⽰在控制台，同时我们需要让他能够备份到其他的⽂件⾥⾯去</p><p>缺点：1、是覆盖，而不能叠加到同一文件。2、只接受正确的输出，错误的输出不接受</p><p><img src="/../../../../images/clip_image002.png" alt="img"></p><p>vim常用操作</p><pre><code class="perl">命令模式gg  跳转到文件的首行G   跳转到文件的尾部yy  复制    p   粘贴nyy 复制光标以下n行u   撤销上一步操作dd  删除光标所在的行ndd    删除光标所在行以下的n行x       删除光标所在位置的单个字符:n      输入：n可以将光标跳转到 第n行:set nu  给文件内的行添加编号，nu=number   :1s/test1/test2/g      将文件内第一行到最后一行的test1内容替换成test2:1,3s/test1/test2/g     将文件内第一行到第三行的test1内容替换成test2/test    向下搜索test关键字?test    向上搜索test关键字v   进入视图模式，上下键选择文本块，能够快速操作(dd , yy等)</code></pre><p>vim的配置文件：&#x2F;etc&#x2F;vimrc 全局的</p><p>环境变量</p><p>1、只能包含数字字母_三种字符做变量名，且不能以数字开头</p><p>2、变量赋值的&#x3D;两边不能有空格，否则shell会认为变量的值是参数</p><p>设置自定义变量：name&#x3D;tom</p><p>输出自定义变量：echo $name</p><p>取消变量的值：  unset name</p><p>把普通变量变为环境变量：export name&#x3D;tom</p><p>env | grep name  能查看环境变量，看不了普通变量</p><p>注意：设置了环境变量或普通变量，重启后就失效。</p><p>如果不想失效，则在以下文件添加变量：</p><p>&#x2F;etc&#x2F;profile、&#x2F;etc&#x2F;bashrc 、~&#x2F;.bash_profile 和 ~&#x2F;.bashrc</p><p>配置变量自动生效</p><p><img src="/../../../../images/clip_image004.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户-sudo-传输</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E7%94%A8%E6%88%B7-sudo-%E4%BC%A0%E8%BE%93/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E7%94%A8%E6%88%B7-sudo-%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h1 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h1><p> 切换用户</p><p>1.1切换用户：su 和 su –</p><p><img src="/../../../../images/clip_image002-17172988853081.jpg" alt="img"></p><p>建议使用登录的方式：su -</p><p><img src="/../../../../images/clip_image004-17172988853092.jpg" alt="img"></p><p>区别：</p><p>su  不改变环境，保持当前用户环境</p><p>su - 启动新的shell，切换到目标用户的环境 </p><p>1.2 sudo赋权</p><p>sudo是linux系统管理指令，是允许系统管理员让普通⽤⼾执⾏⼀些或者全部的root命令 的⼀个⼯具，如halt，reboot，su等等。这样不仅减少了root⽤⼾的登录 和管理时间， 同样也提⾼了安全性。sudo不是对shell的⼀个代替，它是⾯向每个命令的。</p><p>配置文件</p><p>&#x2F;etc&#x2F;sudoers，主配置文件，是配置文件的模板，尽量不要写在这个文件</p><p>&#x2F;etc&#x2F;sudoers.d&#x2F;，其目录下创建sudo文件效果一样，可以实现sudo赋权</p><p>注：sudo配置只能在root⽤⼾下做操作，普通⽤⼾看不到这个配置⽂件⾥⾯的相应内容</p><p><img src="/../../../../images/clip_image006-17172988853093.jpg" alt="img"></p><p><img src="/../../../../images/clip_image008-17172988853094.jpg" alt="img"></p><p>规则的通用语法：</p><pre><code class="perl">user   host=(runas)  commanduser：      指定的用户host：     指定的主机/IP。可以使用ALL表示任何主机runas：     指定要切换到的用户身份。通常使用ALL表示任何用户command： 指定允许执行的命令。可以使用ALL表示任何命令注意：”NOPASSWD”是选项，它允许用户在执行sudo命令时不需要输入密码。</code></pre><p>例如: </p><p>developer 192.168.1.10&#x3D;(ALL) &#x2F;bin&#x2F;ls  </p><p>这表示developer用户只能在IP地址为192.168.1.10 的主机上执行&#x2F;bin&#x2F;ls命令</p><p>developer ALL&#x3D;(root) &#x2F;bin&#x2F;ls </p><p>这表示 developer 用户只能以 root 用户的身份执行 &#x2F;bin&#x2F;ls 命令。</p><p>developer ALL&#x3D;(admin:wheel) &#x2F;bin&#x2F;ls</p><p>这表示 developer 用户只能以admin或wheel用户组的成员身份执行&#x2F;bin&#x2F;ls命令。</p><p>配置sudo文件建议使用visudo工具，具有语法检测功能</p><p><img src="/../../../../images/clip_image010-17172988853095.jpg" alt="img"> <img src="/../../../../images/clip_image012-17172988853098.jpg" alt="img"> </p><p>sudo赋权的⽤⼾别名和命令的别名</p><p><img src="/../../../../images/clip_image014-17172988853097.jpg" alt="img"></p><p><img src="/../../../../images/clip_image016-17172988853096.jpg" alt="img"></p><p><img src="/../../../../images/clip_image018-17172988853099.jpg" alt="img"></p><p>如果出现用户别名和用户名相同，不会报错，是执行变量</p><p>例如：</p><p>User_Alias USER&#x3D;USER,TEST</p><p>USER   ALL&#x3D;(ALL)   ALL</p><p>用户USER,TEST都拥有sudo赋权</p><h1 id="文件归档"><a href="#文件归档" class="headerlink" title="文件归档"></a>文件归档</h1><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p>创建备份和通过⽹络传输数据时，归档和压缩⽂件⾮常有⽤，最常⽤命令时 tar tar ⽀持⽂件归档和 gzip、bzip2 或 xz 的加解压缩</p><p><img src="/../../../../images/clip_image020-171729888530910.jpg" alt="img"></p><pre><code class="perl">tar命令的选项使⽤ -c 或 --create 选项来创建存档 使⽤ -t 或 --list 选项来列出存档的内容 使⽤ -x 或 --extract 选项来提取存档 使⽤ -f 或 --file= 选项加上⽂件名，作为要运⾏的存档的参数 使⽤ -v 或 --verbose 选项⽤于查看添加到存档中或从中提取的⽂件有哪些</code></pre><h3 id="归档文件和目录"><a href="#归档文件和目录" class="headerlink" title="归档文件和目录"></a>归档文件和目录</h3><p>在linux系统里面文件的后缀名没有意义，不能通过文件的后缀名来判断文件的属性，需 要借助file命令去根据文件头部的魔法数字判断文件的实际类型</p><p><img src="/../../../../images/clip_image022-171729888530911.jpg" alt="img"></p><p>归档&#x2F;tmp目录下的文件，起名为tmp.bak和tmp.zip</p><p><img src="/../../../../images/clip_image024-171729888530912.jpg" alt="img"></p><p><img src="/../../../../images/clip_image026-171729888530913.jpg" alt="img"></p><h3 id="列出存档的内容"><a href="#列出存档的内容" class="headerlink" title="列出存档的内容"></a>列出存档的内容</h3><p><img src="/../../../../images/clip_image028-171729888530914.jpg" alt="img"></p><h3 id="从存档中提取文件"><a href="#从存档中提取文件" class="headerlink" title="从存档中提取文件"></a>从存档中提取文件</h3><p>默认情况是解压到执行解包命令的目录下</p><p><img src="/../../../../images/clip_image030-171729888530915.jpg" alt="img"></p><p>指定解包的路径</p><p><img src="/../../../../images/clip_image032-171729888530916.jpg" alt="img"></p><h3 id="创建压缩存档"><a href="#创建压缩存档" class="headerlink" title="创建压缩存档"></a>创建压缩存档</h3><pre><code class="perl">gzip优点：压缩速度相对较快。压缩比较高效，适合压缩文本文件。常用于网络传输和日志文件的压缩。区别：压缩比相对较低，不如 xz 和 bzip2。适合对大量小文件进行压缩。xz提供了更高的压缩比，通常比 gzip 和 bzip2 更好。压缩比例最高，适合压缩大文件。区别：压缩和解压缩速度相对较慢，特别是对于大型文件占用更多的系统资源。bzip2优点：提供了相对较高的压缩比。压缩和解压缩速度较快，通常优于 xz。压缩效果较好，适合压缩文本文件。区别：压缩比相对较低于 xz。对于大型文件，可能不如 xz 那么高效。</code></pre><p>使⽤下列选项之⼀来创建压缩的 tar 存档:</p><p>-z 或 –gzip 进⾏ gzip 压缩(filename.tar.gz 或 filename.tgz)</p><p>-j 或 –bzip2 进⾏ bzip2 压缩 (filename.tar.bz2)</p><p>-J 或 -xz 进⾏ xz 压缩 (filename.tar.xz)</p><p><img src="/../../../../images/clip_image034-171729888530917.jpg" alt="img"></p><p>属于不同文件属性</p><p><img src="/../../../../images/clip_image036-171729888530918.jpg" alt="img"></p><h3 id="提取压缩的存档"><a href="#提取压缩的存档" class="headerlink" title="提取压缩的存档"></a>提取压缩的存档</h3><p><img src="/../../../../images/clip_image038-171729888530920.jpg" alt="img"></p><p>如果解压两次，内容会覆盖，第一次解压test1，在第二次解压前，对第一次解压文件进行修改或增加，第二次解压，会覆盖其内容</p><p>要申明压缩的压缩格式，才能正确解压归档包，文件名不代表文件格式</p><h2 id="在系统之间安全的传输文件"><a href="#在系统之间安全的传输文件" class="headerlink" title="在系统之间安全的传输文件"></a>在系统之间安全的传输文件</h2><p>注意：如果传输出现报错，可查看两边的目录的权限，还有用户权限</p><p>如果root不行，就需要去sshd配置文件修改参数，rhel9默认不允许直接登录root</p><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>从本地传输⽂件到远程</p><p><img src="/../../../../images/clip_image040-171729888530919.jpg" alt="img"></p><p>从远程把⽂件下载到本地</p><p><img src="/../../../../images/clip_image042-171729888530921.jpg" alt="img"></p><h3 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h3><p><img src="/../../../../images/clip_image044-171729888530922.jpg" alt="img"></p><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><p>rsync 命令是在系统之间安全复制⽂件的另⼀种⽅式,此⼯具采⽤的算法可通过仅同</p><p>步已更改的⽂件部分来将复制的数据量最⼩化</p><p>rsync 将仅复制⽂件系统间的差异部分，⽽ scp 复制所有内容</p><p>rsync 的 -n 选项，为模拟运⾏，显⽰需要同步的⽂件清单，⽽不真正同步</p><p>rsync 另外两个重要选项为：-v （–verbose）和 -a（–archive）</p><p>rsync -a 开启的选项如下</p><p><img src="/../../../../images/clip_image046.jpg" alt="img"></p><p>#同步本地文件到远程 </p><p>rsync -av &#x2F;etc&#x2F; root@serverb:&#x2F;opt </p><p>#同步远程文件到本地 </p><p>rsync -av root@serverb:&#x2F;etc &#x2F;opt</p><p>-a：这是一个组合选项，包含了很多常用的同步选项，包括递归复制子目录、保留文件属性（权限、所有者等）、保留符号链接等。</p><p>-v：显示操作过程</p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E6%9D%83%E9%99%90/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p> 用户权限</p><p><strong>用户：⽤⼾账⼾为不同⼈员和运⾏的程序之间提供安全边界</strong></p><p><strong>用户账户有三种主要类型：</strong></p><p><strong>超级用户(root)、系统用户(由系统分配,不可交互登录)、普通用户(superuser、system user、regular user)</strong></p><p><strong>superser    就是 root ⽤⼾，UID&#x3D;0，具有系统的最⾼权限</strong></p><p><strong>system user  ⽤于系统管理，例如运⾏服务，不需要⽤于系统登录</strong></p><p><strong>regular user  供⽤⼾进⾏⽇常系统管理，通常具有权限限制</strong></p><p><strong>用户的ID和组ID，密码有效期相关配置的信息</strong></p><p><strong><img src="/../../../../images/clip_image001-17172997028481.png" alt="img"></strong></p><p><img src="/../../../../images/clip_image003-17172997028492.png" alt="img"><img src="/../../../../images/clip_image005-17172997028493.png" alt="img"><img src="/../../../../images/clip_image007.png" alt="img"></p><p><strong>id****：查看当前登录的用户或某用户的信息</strong></p><p><strong><img src="/../../../../images/clip_image008.png" alt="img"></strong></p><p><strong>创建用户：useradd</strong></p><pre><code>**-d  --home-dir HOME_DIR home directory of the new****//默认情况下，创建用户会自动在/home目录下创建一个与用户名相同的目 录，作为用户的家目录，-d选项可以指定用户的家目录****-M, --no-create-home   do not create the user&#39;s home directory** **//不自动创建/home目录下的用户家目录，结合-d指定用户家目录****-g, --gid GROUP  name or ID of the primary group of the new account****//****不自动按照系统给的GID，自定义GID****-G, --groups  GROUPS list of supplementary groups of the new account** **//指定用户的附属组。****-u, --uid UID user ID of the new account****//**默认 情况下用户的uid会用1000开始以此类推指定uid编号，但是可以使用-u选项直接指定 uid编号，但是要注意不要重复** **-s, --shell SHELL login shell of the new account** **//****指定用户的shell类型（/bin/bash可交互式的shell,/sbin/nologin非交互式的 shell）**</code></pre><p><strong>创建user2并将其添加到root组里面</strong></p><p><strong><img src="/../../../../images/clip_image010-17172997028494.png" alt="img"></strong></p><p><strong>指定用户user3的shell类型</strong></p><p><strong><img src="/../../../../images/clip_image012.png" alt="img"></strong></p><p><strong>解释&#x2F;etc&#x2F;passdw的字段</strong></p><p><strong>root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</strong></p><p><strong>admin:x:972:972::&#x2F;home&#x2F;admin:&#x2F;sbin&#x2F;nologin</strong></p><p><strong>以” : ”分割成为7段，用户名：密码：所有者：所属组：标识：家目录：shell类型</strong></p><p><strong>注意：字段值的标识为”::”表示没用标识</strong></p><p><strong>解释&#x2F;etc&#x2F;shadow****的字段</strong></p><p><strong>记录的内容分别是：用户名：加过盐的密码：密码账号有效期相关的信息</strong></p><p><strong>root:$6$sjbF09qE46pvPo.i$7RjUqdRls8aYE&#x2F;vePXYKbckixBVtrrlogpXQnmo&#x2F;ZSU2dvvMo8mRXpjy6Q2WYV8.V.YTAr7uJwPFbhEnXVhlb1::0:99999:7:::</strong></p><p>用户的密码文件的记录内容：以：分割成为9段</p><p>密码部分使用“ $ ”将其分割成为3个部分</p><p>分$6这个是加密算法6（sha512算法）</p><p><strong>$sjbF09qE46pvPo.i</strong>盐，系统生成的随机数，用来防止密码冲突</p><p><strong>$7RjUqdRls8aYE&#x2F;vePXYKbckixBVtrrlogpXQnmo&#x2F;ZSU2dvvMo8mRXpjy6Q2WYV8.V.YTAr7uJwPFbhEnXVhlb1，</strong>就是用户的密码+盐通过算法计算后的用户密码(具有不可逆性)</p><p><strong>修改用户(usermod)</strong></p><pre><code>**-g, --gid GROUP force use GROUP as new primary group//修改GID****-G, --groups GROUPS new list of supplementary GROUPS // 修改附属组****-u, --uid UID new UID for the user account//修改uid** **-s, --shell SHELL new login shell for the user account //修改shell类型** **-L, --lock lock the user account //锁定用户****-U, --unlock unlock the user account //解锁用户**</code></pre><p><strong><img src="/../../../../images/clip_image014.png" alt="img"></strong></p><p><strong>删除用户(userdel)</strong></p><p><strong>-r, –remove remove home directory and mail spool</strong> </p><p>**&#x2F;&#x2F;**<strong>删除用户同时也删除他的家目录</strong></p><p><strong><img src="/../../../../images/clip_image016.png" alt="img"></strong></p><p><strong>注意：假如user3(1002)在没有被删除前，创建了一个文件(file1)，所属者user3(1002),用户user3被删除后，file1的所属者是1002，如果再创建一个用户user4,其UID是1002，那么该file1的所属者是user4</strong></p><p><strong>给用户添加密码(passwd)</strong></p><p><strong>#passwd</strong> <strong>交互式</strong></p><p><strong><img src="/../../../../images/clip_image018.png" alt="img"></strong></p><p><strong>#passwd</strong> <strong>非交互式</strong></p><p><strong><img src="/../../../../images/clip_image019-17172997028495.png" alt="img"></strong></p><p><strong>创建用户组(groupadd)</strong></p><p><strong><img src="/../../../../images/clip_image020.png" alt="img"></strong></p><p><strong>-g, –gid GID         use GID for the new group</strong></p><p><strong>解释&#x2F;etc&#x2F;group的字段</strong></p><p><strong>root:x:0:</strong></p><p><strong>以” : ”分割成为4段，组名：密码：组id:保留</strong></p><p><strong>修改用户组groupmod</strong></p><pre><code>**-g, --gid GID         change the group ID to GID  //****修改Gid****-n, --new-name NEW_GROUP   change the name to NEW_GROUP //****修改组名****-U, --users USERS list of user members of this group //****在用户组添加用户**</code></pre><p><strong>删除用户组groupdel</strong></p><pre><code>**配置密码生命周期chage****-d, --lastday LAST_DAY set date of last password change to LAST_DAY** **//修改最后登录时间****-I(i), --inactive INACTIVE set password inactive after expiration to INACTIVE** **//不可用周期(宽限期)****-l, --list show account aging information //查看用户密码信息****-m, --mindays MIN_DAYS set minimum number of days before password change to MIN_DAYS**  **//最小生命周期,离下一次的修改的密码的时间间隔，在最小时间内，是不能够修改密码****-M, --maxdays MAX_DAYS set maximum number of days before password change to MAX_DAYS   //最大生命周期，有max时间是有效****-W, --warndays WARN_DAYS set expiration warning days to WARN_DAYS**  </code></pre><p><strong>&#x2F;&#x2F;警告周期</strong></p><p><strong><img src="/../../../../images/clip_image022.png" alt="img"></strong></p><h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><p><strong>解释Linux文件系统权限</strong></p><p><strong>文件权限类别：读取(r，4)，写入(w，2)，执行(x，1)</strong></p><p><img src="/../../../../images/clip_image024.png" alt="img"></p><p><strong>-rw-r–r–</strong></p><p><strong>第一位文件类型: -</strong></p><p><strong>普通文件，d目录，l软链接，b块设备，</strong></p><p><strong>c****字符设备，p管道，s  socket</strong></p><p><strong>剩下九位表示文件权限:</strong></p><p><strong>分三组(所属用户(u),所属组(g),其他用户(o))  u-user，g-group，o-other</strong></p><p><strong>每组三个字符代表权限</strong></p><p><strong>修改文件的的身份</strong></p><p><strong>修改文件所属者：chown</strong></p><p><img src="/../../../../images/clip_image026-17172997028496.jpg" alt="img"></p><p><strong>修改文件所属组：chown 或者 chgrp</strong></p><p><img src="/../../../../images/clip_image028-17172997028498.jpg" alt="img"></p><p><strong>修改⽂件权限的⽅法</strong></p><p>u所有者 g所属组 o其他人，a所有人</p><p>读(read)：r，4   写(write)：w，2  执行：x，1</p><p>设置文件权限</p><p><img src="/../../../../images/clip_image030-17172997028497.jpg" alt="img"></p><p><strong>减少文件权限</strong></p><p><img src="/../../../../images/clip_image032-17172997028499.jpg" alt="img"></p><p><strong>给所有的身份添加&#x2F;去除权限</strong></p><p><img src="/../../../../images/clip_image034-171729970284910.jpg" alt="img"></p><p><strong>数字表示法：r(4) w(2) x(1)</strong></p><p><img src="/../../../../images/clip_image035.png" alt="img"></p><p><strong>特殊权限</strong></p><p>SUID（4 他只对⼆进制⽂件有效）、SGID（2 针对⽬录）、STICKY（1 针对⽬录）</p><p><img src="/../../../../images/clip_image037-171729970285011.jpg" alt="img"></p><p><strong>注意：对root无效</strong></p><p><strong>SUID</strong></p><p><strong>只对二进制文件有效</strong></p><p><strong>效果：能够使得所有人能够以文件的用户身份执行</strong></p><p><strong>例如:&#x2F;etc&#x2F;shadow,只能root能够cat打开,如果给cat的执行文件添加s权限，那么所有用户，可以利用cat打开shadow文件，但其他命令不能,例如tail、head等</strong></p><p><strong>注意：如果文件自身没有可执行权限，那么suid就是大写的，但效果一样</strong></p><p><img src="/../../../../images/clip_image039-171729970285012.jpg" alt="img"><img src="/../../../../images/clip_image041-171729970285013.jpg" alt="img"></p><p><img src="/../../../../images/clip_image043-171729970285015.jpg" alt="img"><img src="/../../../../images/clip_image045-171729970285014.jpg" alt="img"> </p><p><strong>s权限借的是所有者的身份，sudo获取的是root的特权</strong></p><p><strong>sgid(g+s)</strong></p><p><strong>所属组自动设置为上级目录的所属组</strong></p><p><strong>效果：设置g+s后，t1目录的所属组是test1，root用户在t1里面创建文件，其文件的所属者和所属组分别是：root:test1</strong></p><p><strong><img src="/../../../../images/clip_image047.png" alt="img"></strong> <strong><img src="/../../../../images/clip_image049-171729970285016.png" alt="img"></strong></p><p><strong>sticky****权限(o+t)</strong></p><p><strong>作用：在这个目录下，不能删除其他用户拥有的文件或目录，也无法强制强制保持其他用户所拥有的文件(包括其他用户拥有的目录下创建文件)</strong></p><p><strong>注意：sticky控制的是所有者，尽管该文件属组是t1，而用户t1的组是t1，也无法进行删除等操作</strong></p><p><strong><img src="/../../../../images/clip_image051-171729970285017.png" alt="img"></strong><img src="/../../../../images/clip_image053-171729970285018.jpg" alt="img"></p><p>**<br>**</p><p><strong>attr****权限</strong></p><p><strong>常用参数：</strong></p><p>**+I,**<strong>文件不可删除，不可追加，不可写入</strong></p><p><strong>+a, 文件变成只可追加写入，不可删除，不可覆盖写入</strong></p><p><strong>作用：添加若干特殊权限，包括root也受限。</strong></p><p><strong>一般适应范围：用于保护日志等文件不被破坏</strong></p><p><img src="/../../../../images/clip_image055-171729970285019.jpg" alt="img"></p><p><strong>文件默认权限</strong></p><p><strong>文件的默认满权限：666，目录的满权限：777</strong></p><p><strong>默认情况下：</strong></p><p>**umask(UID&gt;199)**<strong>：002</strong></p><p>**umask(UID&lt;199)**<strong>：022</strong></p><p><strong>可以修改默认umask，vim &#x2F;etc&#x2F;bashrc</strong></p><p><img src="/../../../../images/clip_image057-171729970285020.jpg" alt="img"></p><p><strong>&#x2F;etc&#x2F;profile****、&#x2F;etc&#x2F;bashrc    系统级，是系统全局环境变量设定</strong></p><p><strong><del>&#x2F;.profile****、</del>&#x2F;.bashrc       用户级，当前目录下的私有环境变量设定</strong></p><p><strong>当登录系统时候会获得一个shell进程时，其读取环境设定档，以下流程：</strong></p><p><strong><img src="/../../../../images/clip_image059-171729970285021.png" alt="img"></strong></p><p><strong><del>&#x2F;.profile****与</del>&#x2F;.bashrc的区别</strong></p><p><strong>~&#x2F;.profile****可以设定本用户专有路径,环境变量等，它只能登入的时候执行一次</strong></p><p><strong>~&#x2F;.bashrc****也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次，bashrc文件智慧对指定的shell类型起作用，bashrc值会被bash shell调用</strong></p><p>bashrc文件就像是一个个性化的“设置清单”，它存储了用户特定的配置信息，比如用户经常使用的命令、别名、函数等。这些信息是在用户登录后会被加载并应用的，让用户能够更方便地使用计算机。比如，用户可以在.bashrc文件中定义一些自定义的命令别名，这样就可以用更简短的命令来完成复杂的操作。</p><p>而.profile文件则像是系统的“环境配置文件”，它在用户登录时被读取和执行，用来设置系统范围内的环境变量和执行一些初始化命令。这些环境变量和初始化命令会影响所有登录到系统的用户。比如，在.profile文件中可以设置系统的PATH环境变量，这样用户在任何地方都能够使用系统中的命令。</p><p><strong>ACL</strong></p><p><strong>这个与⽂件系统有关系,xfs的⽂件系统默认⽀持，他可以针对⽤⼾个⽤⼾组进⾏赋权，但是不会影响到原始⽂件的权限</strong></p><p><strong>setfacl -m u:student:rwx &#x2F;root &#x2F;给student用户添 加&#x2F;root目录的读写进入权限</strong></p><p><strong>getfacl  查看目录权限</strong></p><p><strong>setfacl -b &#x2F;root 删除该&#x2F;root目录的全部acl参数</strong></p><p><img src="/../../../../images/clip_image061-171729970285022.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统目录-语法</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95-%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95-%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Linux–&gt;原名：GNU&#x2F;Linux</p><p>Fedora—社区版的Linux系统，每六个月更新一次，不适合企业，稳定性不够</p><p>EPEL是Fedora的一个软件仓库源</p><p>Linux系统是基于Core(内核)，而使用者不能直接操作内核，必须要通过一个”中间层”而间接操作内核，这个中间层叫做”Shell(命令解释器)”</p><p>Linux命令行由Shell程序提供的</p><p>redhat9默认Shell类型：Bash</p><p>总而言之，我们所学的命令，其实是学习Shell的语法</p><p>-—————————————————–</p><p>[用户名@主机名 所在路径]  </p><p>$-普通用户，#-超级用户(root)</p><p>ctrl+alt+F1-F6进行console切换(tty1-tty6)，切换虚拟终端</p><p>在redhat9，在有图形环境，将在tty1中运行</p><p>远程访问方式：</p><p>①ssh <a href="mailto:root@192.168.66.66">root@192.168.66.66</a>  &#x2F;&#x2F;用户+IP地址</p><p>②ssh <a href="mailto:root@www.test.com">root@www.test.com</a>  &#x2F;&#x2F;用户+域名</p><p>关机&#x2F;重启</p><p>poweroff&#x2F;reboot  init 0&#x2F;init 6</p><p>一行执行多条命令用”;(分号)”隔开</p><p>例如：touch file1; vim file1</p><p>&amp;&amp;  第一个命令执行成功，后面的命令才能执行</p><p><img src="/../../../../images/clip_image002.gif" alt="img"></p><p>|| 第一个命令执行失败，后面的命令才能执行</p><p><img src="/../../../../images/clip_image004.gif" alt="img"></p><p>date显示时间类型</p><p><img src="/../../../../images/clip_image006.gif" alt="img"></p><p>file 显示文件类型</p><p><img src="/../../../../images/clip_image008.gif" alt="img"></p><p>注意：Linux中，文件的后缀名无法表述文件类型的归属，例如exe,py.excel等等</p><p>常用查看文件内容</p><p>cat、head、tail、less</p><p>cat：查看一个或多个文件内容，还可以将内容重定向到新文件</p><p>less：一次只显示一页内容，可滚动</p><p>head 和 tail：显示文件首或尾10行，-n 选项可以指定显示的行数</p><p><img src="/../../../../images/clip_image010.gif" alt="img"></p><p>注意：tail -f 实现实时监控文件</p><p>wc </p><p>计算文件中行,字数,字符数,具有-l,-w,-c选项,分别显示行数,字数,字符数</p><p><img src="/../../../../images/clip_image012.gif" alt="img"></p><p>如果系统中，Tab补全失败，则该安装bash-completion</p><p><img src="/../../../../images/clip_image014.gif" alt="img"></p><p>在多行上编写长命令：</p><p>命令太长，为提高可读性，可用‘\’命令多行显示</p><p><img src="/../../../../images/clip_image016.gif" alt="img"></p><p>history 显示之前执行命令的列表，带有编号</p><p>!number 执行指定编号的命令</p><p><img src="/../../../../images/clip_image018.gif" alt="img"></p><p>如果shell终端关闭，系统会记录一些文件(.bash_history)</p><p><img src="/../../../../images/clip_image020.gif" alt="img"></p><p>命令行的快捷键</p><p>Ctrl+A   跳到命令行的开头</p><p>Ctrl+E   跳到命令行的末尾</p><p>Ctrl+U   将光标到命令行开头的内容清除</p><p>Ctrl+K   将光标到命令行末尾的内容清除</p><p>Linux重要目录</p><pre><code class="perl">/boot   开始启动过程所需要的文件/dev    供系统用于访问硬件的特殊设备文件/etc    特定于系统的配置文件/home   普通用户的家目录/root   root的主目录/lib64   保存系统的64位动态库文件/lib    系统的32位库/mnt    临时挂载点/proc   系统开机后运行的服务进程会映射到这个目录里面(目录名是数字，代表进程)/run    内存的一些映射关系/tmp    临时文件的存储/var    日志、计划任务等相关文件/sbin   只有root能够执行的命令/bin    命令的二进制文件/dev    设备文件的保存位置/media   媒体设备/挂载点/opt    第三方应用安装的目录/sys    驱动文件的保存/usr    安装的软件、共享的库等文件pwd  查看当前目录</code></pre><p>cd 切换目录</p><p>cd - 回到之前一个目录</p><p>cd .. 进入父目录(上一级目录)</p><p>cd ~  进入家目录</p><p>ls -l（⻓列出格式）、-a（显示隐藏文件）、-R（递归方式，包含所 有子目录的内容）</p><p><img src="/../../../../images/clip_image022.gif" alt="img"></p><p>注意：文件名的第一个带”.” 代表隐藏文件 ，ls -a才能显示出来</p><p>文件格式：</p><p>文件类型-文件权限-链接数-文件的所有者-文件的所属组-文件的大小–文件的创建&#x2F;修改时间-文件名</p><p>文件类型：</p><p>-  文件  d  目录  s  套接字文件进程间通信  p  管道文件</p><p>c  字符设备io   c  字符设备    b  块设备文件磁盘</p><p><img src="/../../../../images/clip_image024.gif" alt="img"></p><p>文件的权限：</p><p>r  读   4</p><p>w  写   2</p><p>x  执行  1</p><p><img src="/../../../../images/clip_image026.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脚本-三剑客</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%84%9A%E6%9C%AC-%E4%B8%89%E5%89%91%E5%AE%A2/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%84%9A%E6%9C%AC-%E4%B8%89%E5%89%91%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><h2 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h2><p>vi&#x2F;vim等⽂本编辑器，创建打开⼀个⽂件。这个⽂件的命名没有强制要求，但是建议 以.sh结尾，⽤来提⽰⼀下这是个脚本⽂件。</p><p>在⽂件内部需要以#!&#x2F;bin&#x2F;bash，#！⽤来指定脚本的解释器的作⽤，也可以调⽤shell的 内置命令，这样的话才能保证它是⼀个脚本，⽽不是⼀堆命令的集合。</p><p>shell脚本⽂件#后⾯的内容不会被解释器解析，会以注释的⽅式⽤作提⽰作⽤</p><p>#一个简单的脚本</p><p><img src="/../../../../images/clip_image002-17172991055811.jpg" alt="img"></p><h2 id="脚本的执行方式"><a href="#脚本的执行方式" class="headerlink" title="脚本的执行方式"></a>脚本的执行方式</h2><p>bash 或者 sh + 脚本的方式执行，把脚本当作参数,交给bash或者解释器执行</p><p><img src="/../../../../images/clip_image003.png" alt="img"></p><p>. 或者 source +脚本的方式执行，把脚本交给.</p><p><img src="/../../../../images/clip_image004-17172991055812.png" alt="img"></p><p>. hello.sh没有x权限也可以。 . 代表当前shell终端，它只把程序交给 当前shell进程，shell进程创建一个子进程，然后把test.sh作为参数传给进程里面去执行</p><p>脚本赋予可执⾏权限后再去执⾏(推荐使⽤这种⽅式，运⾏shell脚本)</p><p><img src="/../../../../images/clip_image006-17172991055813.jpg" alt="img"></p><h2 id="shell脚本中的变量"><a href="#shell脚本中的变量" class="headerlink" title="shell脚本中的变量"></a>shell脚本中的变量</h2><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>变量名的规则：只能包含数字，字⺟、_，并且不能以数字开头</p><p>变量的赋值通过变量名&#x3D;变量值的⽅式进⾏操作，&#x3D;两边不能有空格的存在，否则他会把值或者变量名识别成为命令， 导致出现command not found错误。$+变量名可以解析读取变量的值。</p><p><img src="/../../../../images/clip_image008-17172991055824.jpg" alt="img"></p><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p><img src="/../../../../images/clip_image010-17172991055825.jpg" alt="img"></p><p>$* 和 $@区别</p><p>$*， 它会把所有的命令行参数当作一个整体对待，无论参数中是否有空格或引号，都会被连接成一个字符串</p><p>$@，它会把每个命令行参数都当作独立的单词，保留空格和引号</p><p>运行脚本时输入了 .&#x2F;script.sh arg1 “arg 2” arg3</p><p>使用 $* 会得到一个字符串：”arg1 arg 2 arg3”</p><p>使用 $@ 会得到三个独立的单词：”arg1”，”arg 2”，和 “arg3”。</p><p><img src="/../../../../images/clip_image012-17172991055826.jpg" alt="img"></p><p><img src="/../../../../images/clip_image014-17172991055827.jpg" alt="img"></p><p>$?存在两种情况，0(代表前面的命令执行成功了)或者非0（代表前面的命令执行失败）</p><p><img src="/../../../../images/clip_image016-17172991055828.jpg" alt="img"></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>用户的某种特殊属性，它的有效范围是全局范围有效，环境变量⼀般使⽤⼤写字⺟命名，可以使⽤env或者printenv命令读取出所有的环境变量</p><p><img src="/../../../../images/clip_image018-17172991055829.jpg" alt="img"></p><h3 id="系统环境变量的配置文件"><a href="#系统环境变量的配置文件" class="headerlink" title="系统环境变量的配置文件"></a>系统环境变量的配置文件</h3><p><img src="/../../../../images/clip_image020-171729910558210.jpg" alt="img"></p><h3 id="export将普通变量提升为环境变量"><a href="#export将普通变量提升为环境变量" class="headerlink" title="export将普通变量提升为环境变量"></a>export将普通变量提升为环境变量</h3><p><img src="/../../../../images/clip_image022-171729910558211.jpg" alt="img"></p><h3 id="shell脚本⾥⾯的⼀些特殊的符号"><a href="#shell脚本⾥⾯的⼀些特殊的符号" class="headerlink" title="shell脚本⾥⾯的⼀些特殊的符号"></a>shell脚本⾥⾯的⼀些特殊的符号</h3><p>‘’(单引号)、””(双引号)、&#96;&#96;(反引号)、(反斜杠)、|(管道)、1&gt;&gt;、2&gt;&gt;、1&gt;、2&gt;</p><p><img src="/../../../../images/clip_image024-171729910558212.jpg" alt="img"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>test命令或者[ ]，可以⽤来进⾏条件判断，[]这个需要在中括号和条件表达式之间都存在⼀个空格</p><p>⽂档类型的测试</p><p><img src="/../../../../images/clip_image026-171729910558213.jpg" alt="img"></p><p><img src="/../../../../images/clip_image028-171729910558214.jpg" alt="img"></p><h3 id="测试⽂件的权限"><a href="#测试⽂件的权限" class="headerlink" title="测试⽂件的权限"></a>测试⽂件的权限</h3><p><img src="/../../../../images/clip_image030-171729910558215.jpg" alt="img"></p><p><img src="/../../../../images/clip_image031-171729910558216.png" alt="img"></p><h3 id="测试字符串-随便看看"><a href="#测试字符串-随便看看" class="headerlink" title="测试字符串(随便看看)"></a>测试字符串(随便看看)</h3><p><img src="/../../../../images/clip_image033-171729910558217.jpg" alt="img"></p><p>使⽤test命令对字符串的操作只有判断测试的字符串是否为空以及字符串是否是某个值。 对于n 选项来说，都是判断字符串是否为空，如果字符串为空，那么test命令就会返回逻辑假的 值。 如果字符串不为空，就返回逻辑真的值。⽽对于选项-z来说，返回的结果和-n选项正好相 反。 对于相同符号“&#x3D;”和不相同符号“！&#x3D;”来说，只要是符号左右两边的字符串相同（或不 同），那么就返回逻辑真（假）的结果。</p><h3 id="测试数值"><a href="#测试数值" class="headerlink" title="测试数值"></a>测试数值</h3><p><img src="/../../../../images/clip_image035-171729910558218.jpg" alt="img"><img src="/../../../../images/clip_image037-171729910558219.jpg" alt="img"></p><p><img src="/../../../../images/clip_image039-171729910558220.jpg" alt="img"></p><h3 id="复合测试条件"><a href="#复合测试条件" class="headerlink" title="复合测试条件"></a>复合测试条件</h3><p><img src="/../../../../images/clip_image041-171729910558221.jpg" alt="img"></p><p><img src="/../../../../images/clip_image043-171729910558222.jpg" alt="img"></p><h3 id="单分支-if-then结构"><a href="#单分支-if-then结构" class="headerlink" title="单分支(if-then结构)"></a>单分支(if-then结构)</h3><p>#结构：&#x2F;&#x2F;这个结构要完整，有开始有结束，否则会报语法错误</p><p><img src="/../../../../images/clip_image044.png" alt="img"></p><h3 id="多分⽀（if-then-else）"><a href="#多分⽀（if-then-else）" class="headerlink" title="多分⽀（if-then-else）"></a>多分⽀（if-then-else）</h3><p><img src="/../../../../images/clip_image046-171729910558223.jpg" alt="img"></p><h3 id="case结构基础（选择菜单）"><a href="#case结构基础（选择菜单）" class="headerlink" title="case结构基础（选择菜单）"></a>case结构基础（选择菜单）</h3><p><img src="/../../../../images/clip_image048.jpg" alt="img"></p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><img src="/../../../../images/clip_image049.png" alt="img"></p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><img src="/../../../../images/clip_image051-171729910558224.jpg" alt="img"></p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>跳出符合条件的循环以及后续的循环</p><p><img src="/../../../../images/clip_image053-171729910558225.jpg" alt="img"></p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>符合条件的退出，继续执⾏剩下的循环</p><p><img src="/../../../../images/clip_image054.png" alt="img"></p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="正则表达式的含义："><a href="#正则表达式的含义：" class="headerlink" title="正则表达式的含义："></a>正则表达式的含义：</h2><p>正则表达式（Regular Expression）就是使⽤简单的字符按照预先设定的规则来完成复杂的功能。</p><p>正则表达式⼀般是由普通字符以及特殊字符组成的字符串。</p><p>正则表达式的组成可以是单个的字符、字符集合、字符范围、字符 间的选择 或者是这些字符之间的任意组合。</p><h2 id="正则表达式分类："><a href="#正则表达式分类：" class="headerlink" title="正则表达式分类："></a>正则表达式分类：</h2><p>posix⻛格的正则表达式  pcre⻛格的正则表达式</p><p>基本正则表达式 扩展正则表达式</p><p>注：不同类型的正则表达式，能够兼容的⽂本处理⼯具也会有差异，正则表达式，由普通的⽂ 本字符（a-zA-Z0-9）和具有特殊功能的字符（元字符）</p><h2 id="部分元字符的功能"><a href="#部分元字符的功能" class="headerlink" title="部分元字符的功能"></a>部分元字符的功能</h2><p>点（.），含义是表示有且只有一个任意字符</p><p><img src="/../../../../images/clip_image056.jpg" alt="img"></p><p>#[ ] 含义是：一个中括号只表示一个字符，中括号里面的内容表示其中一个字符</p><p><img src="/../../../../images/clip_image058.jpg" alt="img"></p><p>^含义是： 排除^后面的字符，就符合匹配规则</p><p><img src="/../../../../images/clip_image059.png" alt="img"></p><h2 id="次数匹配"><a href="#次数匹配" class="headerlink" title="次数匹配"></a>次数匹配</h2><p>?表示？号前面的字符只有一个或零个</p><p><img src="/../../../../images/clip_image061-171729910558226.jpg" alt="img"></p><p>*表示匹配它前面的字符0次或者若干次</p><p><img src="/../../../../images/clip_image063-171729910558227.jpg" alt="img"></p><p>+含义是匹配前面的字符至少1次</p><p><img src="/../../../../images/clip_image064.png" alt="img"></p><p>{ } 表示前面的字符重复的次数</p><p><img src="/../../../../images/clip_image066.jpg" alt="img"></p><h2 id="位置锚定"><a href="#位置锚定" class="headerlink" title="位置锚定"></a>位置锚定</h2><p>^表示以后面的字符开头</p><p><img src="/../../../../images/clip_image067.png" alt="img"></p><p>$表示结尾</p><p><img src="/../../../../images/clip_image068-171729910558228.png" alt="img"></p><p>&lt; 或 \b 匹配一个单词的首部</p><p><img src="/../../../../images/clip_image069.png" alt="img"></p><p>&gt; 或 \b 定位的是一个单词的尾部</p><p><img src="/../../../../images/clip_image070.png" alt="img"></p><p>匹配文件里面的空行</p><p><img src="/../../../../images/clip_image071.png" alt="img"></p><h2 id="分组（）"><a href="#分组（）" class="headerlink" title="分组（）"></a>分组（）</h2><p>会将括号内的部分作为⼀个整体进⾏匹配，⽽不是单个字符进⾏匹配</p><p><img src="/../../../../images/clip_image073.jpg" alt="img"></p><h2 id="分⽀-表⽰或的关系"><a href="#分⽀-表⽰或的关系" class="headerlink" title="分⽀ | 表⽰或的关系"></a>分⽀ | 表⽰或的关系</h2><p><img src="/../../../../images/clip_image075-171729910558329.jpg" alt="img"></p><h2 id="贪婪匹配和懒惰匹配"><a href="#贪婪匹配和懒惰匹配" class="headerlink" title="贪婪匹配和懒惰匹配"></a>贪婪匹配和懒惰匹配</h2><p>默认，正则表达式和扩展正则表达式，是贪婪的，最⻓匹配。 PERL正则表达式，可在量 词后⾯直接加上⼀个问号（?），实现懒惰匹配，最短匹配 （？实现懒惰匹配，只适合 PCRE，不适合POSIX标准正则表达式）</p><p>贪婪模式（尽可能多的匹配）</p><p><img src="/../../../../images/clip_image077-171729910558330.jpg" alt="img"></p><p>懒惰模式（尽可能少的匹 配）</p><p><img src="/../../../../images/clip_image078-171729910558332.png" alt="img"></p><h1 id="⽂本处理的⼀些常⽤⼯具"><a href="#⽂本处理的⼀些常⽤⼯具" class="headerlink" title="⽂本处理的⼀些常⽤⼯具"></a>⽂本处理的⼀些常⽤⼯具</h1><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>⾏⽂本匹配⼯具，以⾏为单位，查找匹配的内容</p><p><img src="/../../../../images/clip_image080-171729910558331.jpg" alt="img"></p><p><img src="/../../../../images/clip_image082-171729910558333.jpg" alt="img"></p><p><img src="/../../../../images/clip_image084.jpg" alt="img"><img src="/../../../../images/clip_image086.jpg" alt="img"></p><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>可以查找和编辑⽂件的内容，它时按照流的⽅式，以⾏为单位进⾏匹配，取⼀⾏内容到sed缓 存⾥⾯，处理完毕后显⽰处理结果，并将下⼀⾏内容读取到缓存⾥⾯，以此⼀直到将整个⽂件 的所有⾏全部处理完毕，相⽐较vim这样的⼯具他的执⾏效率更⾼⼀些。</p><h3 id="处理流程："><a href="#处理流程：" class="headerlink" title="处理流程："></a>处理流程：</h3><p><img src="/../../../../images/clip_image088.jpg" alt="img"></p><p>它默认情况下不会直接修改原⽂件，修改的只是缓存⾥⾯的内容，要想直接修改原⽂件，需要 加选项-i</p><h3 id="sed常用的命令"><a href="#sed常用的命令" class="headerlink" title="sed常用的命令"></a>sed常用的命令</h3><p><img src="/../../../../images/clip_image090.jpg" alt="img"></p><h3 id="常用的选项"><a href="#常用的选项" class="headerlink" title="常用的选项"></a>常用的选项</h3><p><img src="/../../../../images/clip_image092.jpg" alt="img"></p><p>打印第二行，第三行</p><p><img src="/../../../../images/clip_image094.jpg" alt="img"></p><p>#如果不想让他显示未被匹配的内容可以使用-n选项</p><p><img src="/../../../../images/clip_image095.png" alt="img"></p><p>#打印This 开头的行</p><p><img src="/../../../../images/clip_image096.png" alt="img"></p><p>##打印除前四行以外的其他行，不知道一共有多少行，可以用 ！反选</p><p><img src="/../../../../images/clip_image097.png" alt="img"></p><p>#打印第一行到匹配到 third 的行</p><p><img src="/../../../../images/clip_image099-171729910558334.jpg" alt="img"></p><p>#插入：a 命令和 i 命令 a 命令和 i 命令的使用方法相同，不同的是 a 命令是在行之后添加内容，i 命令是在行之前插入内容。</p><p>#添加add one 到第一行下面、#添加add two到第一行的上面</p><p><img src="/../../../../images/clip_image101.jpg" alt="img"></p><p>#在第一行之前加 start，在最后一行之后加 end，对单个文件进行多个操作可以用 -e</p><p><img src="/../../../../images/clip_image103-171729910558335.jpg" alt="img"></p><p>#删除二到三行</p><p><img src="/../../../../images/clip_image104.png" alt="img"></p><p>#将第一行替换为“hahahaha”</p><p><img src="/../../../../images/clip_image105.png" alt="img"></p><p>#将全文的 line 替换为 text，不加 g 只替换每一行的第一个 line</p><p><img src="/../../../../images/clip_image107-171729910558336.jpg" alt="img"></p><p>#修改源文件</p><p><img src="/../../../../images/clip_image108.png" alt="img"></p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>是⼀种处理⽂本⽂件的语⾔，是⼀个强⼤的⽂本分析⼯具。 之所以叫 AWK 是因为其取了三位 创始⼈ Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的⾸字符 linux 中有三剑客之称： 三剑客之⾸就是 AWK。</p><h3 id="awk⼯具⼯作的过程"><a href="#awk⼯具⼯作的过程" class="headerlink" title="awk⼯具⼯作的过程"></a>awk⼯具⼯作的过程</h3><p>类似于sed⼯具，都是在⽂件⾥⾯取⼀⾏处理⼀⾏，⼀直到所有的内容处理完毕。</p><p>grep,sed和awk都是读一行处理一行，直到处理完成。 接收一行作为输入 把刚刚读入进来得到文本进行分解 使用处理规则处理文本 输入一行，赋值给$0，直至处理完成 把处理完成之后的所有数据交给END{}来再次处理</p><h3 id="awk⾃⼰的内置变量"><a href="#awk⾃⼰的内置变量" class="headerlink" title="awk⾃⼰的内置变量"></a>awk⾃⼰的内置变量</h3><p>#$0 表示当前行，相当于文档的所有内容, -F是分割，：作为分割符</p><p><img src="/../../../../images/clip_image110.jpg" alt="img"></p><p>#$1表示:分隔的第一个列</p><p><img src="/../../../../images/clip_image112.jpg" alt="img"></p><p>#$2表示:分隔的第二列，以此类推</p><p>#NF: 表示字段数，每一行的字段,例如 root：x：0 字段数为3</p><p>#NR 表示是行号</p><p>#FS : 指定文本内容分隔符(默认是空格) $NF最后一列，$1第一列类似于F选项</p><p><img src="/../../../../images/clip_image114.jpg" alt="img"></p><p>#OFS : 指定打印分隔符(默认空格)</p><p><img src="/../../../../images/clip_image116.jpg" alt="img"></p><h3 id="awk中的定位"><a href="#awk中的定位" class="headerlink" title="awk中的定位"></a>awk中的定位</h3><p>#(awk中匹配有root内容的行)</p><p><img src="/../../../../images/clip_image118.jpg" alt="img"></p><h3 id="⽐较表达式-匹配⽂本之内的内容"><a href="#⽐较表达式-匹配⽂本之内的内容" class="headerlink" title="⽐较表达式(匹配⽂本之内的内容)"></a>⽐较表达式(匹配⽂本之内的内容)</h3><p>&gt; : ⼩于 &lt; : ⼤于 &gt;&#x3D; : ⼤于等于 &lt;&#x3D; : ⼩于等于</p><p>~ : 正则匹配(包含)  !~ : 正则匹配(不包含)</p><p>#要求打印属组ID大于属主ID的行</p><p><img src="/../../../../images/clip_image120.jpg" alt="img"></p><p>#打印结尾包含bash</p><p><img src="/../../../../images/clip_image122.jpg" alt="img"></p><h3 id="条件表达式-⽂本之外的内容"><a href="#条件表达式-⽂本之外的内容" class="headerlink" title="条件表达式(⽂本之外的内容)"></a>条件表达式(⽂本之外的内容)</h3><p>&#x3D;&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D;</p><p>#要求打印第三行</p><p><img src="/../../../../images/clip_image123.png" alt="img"></p><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>&amp;&amp; : 逻辑与  || : 逻辑或 ！ : 逻辑非</p><p>#找到$3+$4 &gt; 2000 且 $3*$4 &gt; 2000</p><p><img src="/../../../../images/clip_image125-171729910558337.jpg" alt="img"></p><p>#找到$3+$4 &gt; 2000 或者 $3*$4 &gt; 2000</p><p><img src="/../../../../images/clip_image127-171729910558338.jpg" alt="img"></p><p>#查找$3 + $4 不大于2000</p><p><img src="/../../../../images/clip_image129-171729910558339.jpg" alt="img"></p><h3 id="算数表达式"><a href="#算数表达式" class="headerlink" title="算数表达式"></a>算数表达式</h3><p>+ :加 - ：减 * ：乘 &#x2F; ：除 % ：求余</p><p>#for每一行打印10次</p><p><img src="/../../../../images/clip_image131.jpg" alt="img"></p><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>分割列，同样是以⼀⾏为单位，⼀次处理⼀⾏，可以指定这个⾏当中的分隔符号，然后输 出⼀ ⾏当中可以被分成的列</p><p>#查看第一字段</p><p><img src="/../../../../images/clip_image132.png" alt="img"></p><p>#先抓取root行，然后通过cut，输出本行以冒号为分隔符的第一列</p><p><img src="/../../../../images/clip_image134.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计划-调优-selinux-磁盘的管理</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%AE%A1%E5%88%92-%E8%B0%83%E4%BC%98-selinux-%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%AE%A1%E5%88%92-%E8%B0%83%E4%BC%98-selinux-%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h1><h2 id="一次性的计划任务"><a href="#一次性的计划任务" class="headerlink" title="一次性的计划任务"></a>一次性的计划任务</h2><p>它只⽣效⼀次，任务执⾏完毕后这个任务会⾃动删除。</p><p>由atd服务提供此功能</p><p><img src="/../../../../images/clip_image002-17173002220683.jpg" alt="img"></p><p>#设置一个at计划任务，任务要求从现在1分钟以后，执行echo 123 &gt; &#x2F;tmp&#x2F;at.txt</p><p><img src="/../../../../images/clip_image004-17173002220681.jpg" alt="img"></p><p>#at计划任务会保存在一下位置</p><p><img src="/../../../../images/clip_image006-17173002220682.jpg" alt="img"></p><p>#查看当前存在的at计划任务</p><p><img src="/../../../../images/clip_image007-17173002220684.png" alt="img"></p><p>#通过命令查看当前存在的某个at计划任务的详情</p><p><img src="/../../../../images/clip_image009.jpg" alt="img"></p><p>#删除at计划任务</p><p><img src="/../../../../images/clip_image011.jpg" alt="img"></p><h2 id="周期性的计划任务"><a href="#周期性的计划任务" class="headerlink" title="周期性的计划任务"></a>周期性的计划任务</h2><p><img src="/../../../../images/clip_image013.jpg" alt="img"></p><h3 id="服务的配置文件"><a href="#服务的配置文件" class="headerlink" title="服务的配置文件"></a>服务的配置文件</h3><p><img src="/../../../../images/clip_image015.jpg" alt="img"></p><p><img src="/../../../../images/clip_image017.jpg" alt="img"></p><p>使⽤*&#x2F;数字，描述的时”每”的含义。例如：*&#x2F;2 * * * *表示每小时的每两分钟</p><p>使⽤x-y替代*,表⽰的是⼀个时间段。例如：* 9-14 * * *表示每天的9点到14点</p><p>使⽤，分割不连续的时间。例如：* * 1，4，12 * *表示每个月的1,4,12号</p><p>注意，02 * * * *表示每小时的02分，不是每隔两分钟</p><p><img src="/../../../../images/clip_image019.jpg" alt="img"></p><p>root⽤⼾可以为普通⽤⼾设置周期计划任务，普通⽤⼾只能给⾃⼰设置周期计划任务</p><h3 id="使⽤命令⾏设置周期性计划任务"><a href="#使⽤命令⾏设置周期性计划任务" class="headerlink" title="使⽤命令⾏设置周期性计划任务"></a>使⽤命令⾏设置周期性计划任务</h3><p><img src="/../../../../images/clip_image021-17173002220695.jpg" alt="img"></p><p>#设置计划任务给student，执行每分钟往&#x2F;tmp&#x2F;cron.txt文件追加写入hello任务</p><p><img src="/../../../../images/clip_image023-17173002220696.jpg" alt="img"></p><h3 id="使⽤配置文件设置周期性计划任务"><a href="#使⽤配置文件设置周期性计划任务" class="headerlink" title="使⽤配置文件设置周期性计划任务"></a>使⽤配置文件设置周期性计划任务</h3><p>&#x2F;etc&#x2F;crontab和&#x2F;etc&#x2F;cron.d中是系统级别的cron任务，可能需要root用户权限</p><p><img src="/../../../../images/clip_image025-17173002220697.jpg" alt="img"></p><p><img src="/../../../../images/clip_image027-17173002220698.jpg" alt="img"></p><p>&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.hourly、 &#x2F;etc&#x2F;cron.monthly、&#x2F;etc&#x2F;cron.weekly</p><p>分别代表每天、每小时、每月、每周的计划任务，可以根据需要执行脚本，注意权限问题，如果在计划任务执行脚本，需要添加+x权限等等</p><p><img src="/../../../../images/clip_image029-17173002220699.jpg" alt="img"></p><h3 id="删除计划任务"><a href="#删除计划任务" class="headerlink" title="删除计划任务"></a>删除计划任务</h3><p><img src="/../../../../images/clip_image031-171730022206910.jpg" alt="img"></p><h2 id="systemd的计划任务"><a href="#systemd的计划任务" class="headerlink" title="systemd的计划任务"></a>systemd的计划任务</h2><p><img src="/../../../../images/clip_image033-171730022206911.jpg" alt="img"></p><p><img src="/../../../../images/clip_image035-171730022206912.jpg" alt="img"></p><p><img src="/../../../../images/clip_image037-171730022206913.jpg" alt="img"></p><h1 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h1><p><img src="/../../../../images/clip_image039-171730022206914.jpg" alt="img"></p><p><img src="/../../../../images/clip_image041-171730022206915.jpg" alt="img"></p><p>tuned-adm提供了一系列的调优模板</p><p><img src="/../../../../images/clip_image043-171730022206916.jpg" alt="img"></p><p>常⽤选项</p><p>active show active profile &#x2F;&#x2F;查看当前激活的调优模板名 profile switch to a given profile, or list available &#x2F;&#x2F;⽤来设置调优模板</p><p>recommend，recommend profile &#x2F;&#x2F;根据系统的情况，tuned服务推荐的调优模板</p><h3 id="查看系统内的所有可⽤的调优模板"><a href="#查看系统内的所有可⽤的调优模板" class="headerlink" title="查看系统内的所有可⽤的调优模板"></a>查看系统内的所有可⽤的调优模板</h3><p><img src="/../../../../images/clip_image045-171730022206918.jpg" alt="img"></p><p>其所有可用的调优模板对应的用途</p><p><img src="/../../../../images/clip_image047-171730022206917.jpg" alt="img"></p><p><img src="/../../../../images/clip_image049-171730022206919.jpg" alt="img"></p><p>配置文件目录：&#x2F;etc&#x2F;tuned&#x2F;</p><h1 id="selinux"><a href="#selinux" class="headerlink" title="selinux"></a>selinux</h1><p>加强版本的安全linux,就是在传统的linux权限的基础之上，⼜添加了⼀个安全的权限验证层， 进程访问系统内的⽂件，⾸先进⾏传统权限的验证，通过之后，还需要通过selinux安全系统的 附加验证，同时通过才能正常访问，否则会被拒绝访问，selinx是内核功能，默认是安装好 的，它本⾝是⼀些策略，为了简化使⽤，它提供了⼀些⼯具来操作selinux的权限。</p><h2 id="配置⽂件："><a href="#配置⽂件：" class="headerlink" title="配置⽂件："></a>配置⽂件：</h2><p><img src="/../../../../images/clip_image051-171730022206920.jpg" alt="img"></p><h2 id="查看selinux的标签"><a href="#查看selinux的标签" class="headerlink" title="查看selinux的标签"></a>查看selinux的标签</h2><p>系统会根据进程层面的selinux标签(httpd)，就能够访问带有httpd标签的相关文件</p><p>系统会根据进程的selinux标签进行匹配，进程访问目录或文件会根据自己的selinux标签与目录的selinux的标签，如果能够匹配，就能够访问，如果不能匹配 ，就不能够访问，即使是root用户也不能够访问</p><p>#查看文件的selinux标签</p><p><img src="/../../../../images/clip_image053.png" alt="img"></p><p>#查看目录的selinux标签</p><p><img src="/../../../../images/clip_image055.png" alt="img"></p><p>#查看进程的selinux标签</p><p><img src="/../../../../images/clip_image057.png" alt="img"></p><p>能够访问&#x2F;var&#x2F;www&#x2F;html目录，其目录下。index1和2都能访问，index3不能访问 ，其标签导致不能访问。</p><p>#selinux将系统内的所有资源文件、目录、端口等都打上selinux的标签，进程访问文 件，目录的时候会进行标签匹配，通过允许访问，不通过拒绝访问。要在selinux的状态 是enforcing的状态</p><h2 id="命令⾏设置selinux的状态"><a href="#命令⾏设置selinux的状态" class="headerlink" title="命令⾏设置selinux的状态"></a>命令⾏设置selinux的状态</h2><p><img src="/../../../../images/clip_image059-171730022206921.jpg" alt="img"></p><h2 id="修改selinux的标签"><a href="#修改selinux的标签" class="headerlink" title="修改selinux的标签"></a>修改selinux的标签</h2><p><img src="/../../../../images/clip_image061-171730022206922.jpg" alt="img"></p><h2 id="修改selinux标签规则库-推荐"><a href="#修改selinux标签规则库-推荐" class="headerlink" title="修改selinux标签规则库(推荐)"></a>修改selinux标签规则库(推荐)</h2><p><img src="/../../../../images/clip_image063-171730022206923.jpg" alt="img"></p><p>port       Manage network port type definitions</p><p>fcontext    Manage file context mapping definitions</p><p>#添加selinux标签的规则</p><p><img src="/../../../../images/clip_image065-171730022207024.jpg" alt="img"></p><p>#根据seliunx标签库的规则给文件添加标签</p><p><img src="/../../../../images/clip_image067-171730022207026.jpg" alt="img"></p><p>-R：是递归操作。  -v是显示过程</p><h2 id="修改端⼝的selinux标签"><a href="#修改端⼝的selinux标签" class="headerlink" title="修改端⼝的selinux标签"></a>修改端⼝的selinux标签</h2><p><img src="/../../../../images/clip_image069-171730022207025.jpg" alt="img"></p><p>查看服务对应的端口</p><p>lsof -i:端口        lsof -i -P -n |grep 服务名  </p><h2 id="selinux的布尔值"><a href="#selinux的布尔值" class="headerlink" title="selinux的布尔值"></a>selinux的布尔值</h2><p>#查看服务的bool</p><p><img src="/../../../../images/clip_image071.jpg" alt="img"></p><p>#修改服务的selinux bool</p><p><img src="/../../../../images/clip_image073-171730022207028.jpg" alt="img"></p><p>#永久修改selinux bool，查看是否为永久BOOL</p><p><img src="/../../../../images/clip_image075-171730022207029.jpg" alt="img"></p><h2 id="通过cockpit使⽤web界⾯管理selinux"><a href="#通过cockpit使⽤web界⾯管理selinux" class="headerlink" title="通过cockpit使⽤web界⾯管理selinux"></a>通过cockpit使⽤web界⾯管理selinux</h2><h1 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h1><h2 id="对磁盘进⾏分区"><a href="#对磁盘进⾏分区" class="headerlink" title="对磁盘进⾏分区"></a>对磁盘进⾏分区</h2><p>磁盘分区将硬盘驱动器划分为多个逻辑存储单元，这些单元称为分区 系统管理员可以使⽤不同的分区执⾏不同功能</p><h2 id="分区的类型"><a href="#分区的类型" class="headerlink" title="分区的类型"></a>分区的类型</h2><p>MBR:(计较古⽼)</p><p><img src="/../../../../images/clip_image077-171730022207027.jpg" alt="img"></p><p>最多⽀持4个主分区，可以牺牲⼀个主分区，形成15个扩展分区。 MBR类型的任务格式最多⽀持2T的磁盘容量的管理。</p><p>GPT：（⽐较新的分区⽅案）</p><p><img src="/../../../../images/clip_image079.jpg" alt="img"></p><p>最多可以有128个分区 它突破了2T磁盘空间管理的限制</p><h2 id="分区的操作"><a href="#分区的操作" class="headerlink" title="分区的操作"></a>分区的操作</h2><h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk:"></a>fdisk:</h3><p>⽐较久远的⼀个⼯具，优点是他会⾃动计算分区的起始位置，然后操作的过程是在内存⾥⾯， 最后操作完毕，需要保存，否则他的设置不会落盘。</p><p><img src="/../../../../images/clip_image081.jpg" alt="img"></p><h3 id="parted："><a href="#parted：" class="headerlink" title="parted："></a>parted：</h3><p>#显示磁盘的信息</p><p><img src="/../../../../images/clip_image083.jpg" alt="img"></p><p>默认情况下，</p><p>parted 单位是10进制（KB、MB、GB） 10的1， 10的2， 10的3次⽅这样计算的 </p><p>2进制的⽅式（KiB、MiB、GiB） 2的1，2的2，2的3次⽅这样的⽅式计算 </p><p>s 是磁盘的单位叫”扇区” 一般2048s&#x3D;2kb    B表示字节</p><p>#设置磁盘的分区表类型</p><p><img src="/../../../../images/clip_image085-171730022207031.jpg" alt="img"></p><p>#创建一个分区(直接落盘，谨慎操作)</p><p><img src="/../../../../images/clip_image087-171730022207030.jpg" alt="img"></p><p>#删除分区</p><p><img src="/../../../../images/clip_image089-171730022207032.jpg" alt="img"></p><p>#非交互式的磁盘分区操作</p><p><img src="/../../../../images/clip_image091-171730022207033.jpg" alt="img"></p><h2 id="格式化操作："><a href="#格式化操作：" class="headerlink" title="格式化操作："></a>格式化操作：</h2><p><img src="/../../../../images/clip_image093-171730022207034.jpg" alt="img"></p><h2 id="挂载："><a href="#挂载：" class="headerlink" title="挂载："></a>挂载：</h2><h3 id="手动挂载："><a href="#手动挂载：" class="headerlink" title="手动挂载："></a>手动挂载：</h3><p><img src="/../../../../images/clip_image095-171730022207035.jpg" alt="img"></p><h3 id="自动挂载："><a href="#自动挂载：" class="headerlink" title="自动挂载："></a>自动挂载：</h3><p><img src="/../../../../images/clip_image097-171730022207036.jpg" alt="img"></p><h2 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h2><p>虚拟内存，当物理内存不⾜的时候，他会将内存中不常⽤的数据，临死存放在交换分区⾥⾯， 当需要这些数据的时候，会直接读取，⼀定程度上缓解，内存不⾜的问题，但是要彻底解决问题，添加物理内存。</p><p>如果程序启动的内存大于物理内存，那交换分区是起不了作用</p><h3 id="交换分区的推荐⼤⼩"><a href="#交换分区的推荐⼤⼩" class="headerlink" title="交换分区的推荐⼤⼩"></a>交换分区的推荐⼤⼩</h3><p><img src="/../../../../images/clip_image099-171730022207037.jpg" alt="img"></p><p>修改分区类型</p><p><img src="/../../../../images/clip_image101-171730022207038.jpg" alt="img"></p><p>格式化为swap，并进行挂载</p><p><img src="/../../../../images/clip_image103-171730022207039.jpg" alt="img"></p><h3 id="设置-SWAP-分区优先级"><a href="#设置-SWAP-分区优先级" class="headerlink" title="设置 SWAP 分区优先级"></a>设置 SWAP 分区优先级</h3><p>系统默认会按顺序使⽤ swap，即内核先使⽤第⼀个已激活swap，直⾄其空间已满， 然后开始使⽤第⼆个 swap 可以为每个 swap 定义⼀个优先级，从⽽强制按该顺序使⽤swap 可以在 &#x2F;etc&#x2F;fstab 中使⽤ pri 选项，默认优先级是 -2，值越⾼，优先级越⾼ swapon –show 可以显⽰ swap 分区优先级 当 swap 分区具有相同的优先级时，内核会以轮循⽅式向其中写⼊。</p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程工具参数</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%82%E6%95%B0/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>PS</strong>：列出当前进程</p><p><strong>特点：只是查看某一个时刻的状态，不具有实时性</strong></p><p><strong>三种风格：UNIX、BSD、GNU</strong></p><p><img src="/../../../../images/clip_image002-17172994745881.jpg" alt="img"></p><p>UNIX风格参数：</p><pre><code class="perl">-A 显示所有进程-e 显示所有进程-l 显示长列表-f 显示完整格式的输出-o 自定义输出 例如: ps -o uid.pid.time.time</code></pre><p><img src="/../../../../images/clip_image004-17172994745892.jpg" alt="img"></p><p>名词解释：</p><pre><code class="perl">F:   指内核分配给进程的系统标记。S: 指进程状态(O是正在运行。S是休眠。R是可运行，正等待运行。Z是僵化，进程已结束但父进程已不存在,T是停止)。UID: 指启动这些进程的用户。PID: 是指进程ID。 PPID: 是指：父进程ID（该进程是由另一个进程启动的）。C:  是指进程生命周期中的CUP利用率。 STIME:是指进程启动时的系统时间。TTY: 是指进程启动时的终端设备。TIME: 是指运行进程需要的累计CPU时间。CMD: 是指启动的程序名称。PRT: 是指进程的优先级（越大数字表越低的优先级）。 NT:  是指谦让度值，用来参与决定优先级。 ADDR: 是指进程的内存地址。 SZ:  是指假如进程被换出，所需的交换空间在大致大小。 WCHAN:是指进程休眠的内核函数的地址。</code></pre><p>BSD风格</p><p>r  只显示运行中的进程</p><p>a  显示与任意终点关联的所有进程</p><p>l  采用长模式</p><p><img src="/../../../../images/clip_image006-17172994745894.jpg" alt="img"></p><p>VSZ: 指进程再内存中的大小，单位kb</p><p>RSS: 指进程在未换出时占用的物理内存</p><p>STAT:代表当前进程状态的双字符状态码</p><p>pstree：以树形的结构列出系统内的进程</p><p>top 动态、实时查看系统内的进程状态</p><p><img src="/../../../../images/clip_image008-17172994745893.jpg" alt="img"></p><p><img src="/../../../../images/clip_image010-17172994745895.jpg" alt="img"></p><p>系统的启动时间 系统的状态up 登录系统的⽤⼾数，负载状态（1分钟 5分钟 15分钟）</p><p><img src="/../../../../images/clip_image012-17172994745898.jpg" alt="img"></p><p>任务的总数，运⾏中的任务，休眠中的任务，停⽌状态的任务 僵停状态的任务数</p><p><img src="/../../../../images/clip_image014-17172994745896.jpg" alt="img"></p><p>cpu的使⽤率 ⽤⼾空间的cpu使⽤率 内核空间的cpu使⽤率 nice值 id系统的繁忙状态 IO相关属性</p><p>ni：表示允许低优先级进程的CPU时间比例,负值表示高优先级，正值则相反</p><p><img src="/../../../../images/clip_image016-17172994745897.jpg" alt="img"></p><p>物理内存空间相关的信息 总数 空闲 使⽤数 缓存</p><p><img src="/../../../../images/clip_image018-17172994745899.jpg" alt="img"></p><p>虚拟内存相关的统计数 总数 空闲 使⽤ 可⽤的</p><p><img src="/../../../../images/clip_image020-171729947458910.jpg" alt="img"></p><p>进程的ID ⽤⼾ 优先级 nice 虚拟内存 物理内存 进程的状态 cpu的占⽤率 内存的占⽤率 使⽤的 CPU的时间 进程启动命令名称</p><p>进程状态包括： D &#x3D; 不可中断睡眠 R &#x3D; 运行中或可运行  S &#x3D; 睡眠中</p><p>​             T &#x3D; 已停止或已跟踪   Z &#x3D; 僵停</p><p>P：根据CPU的使用率，降序排列</p><p>M：根据内存的使用率，降序排列</p><p>-d 每n秒查看一次</p><p>-n 最大执行次数</p><p>-p 进程号</p><p><img src="/../../../../images/clip_image022-171729947458912.jpg" alt="img"></p><p>uptime</p><p>查看系统的负载情况，以及系统时间</p><p><img src="/../../../../images/clip_image024-171729947458911.jpg" alt="img"></p><p>vmstat</p><p>查看系统性能的即时系统信息</p><p><img src="/../../../../images/clip_image026-171729947458913.jpg" alt="img"></p><p>free</p><p>查看系统内存使用情况</p><p><img src="/../../../../images/clip_image028-171729947458914.jpg" alt="img"></p><p>默认显示单位:Kb, -m 是Mib，-h是Gid</p><p>作业和会话(job and session)</p><pre><code class="perl">1、job control 是 shell 的⼀种功能，允许单个 shell 实例运⾏和管理多个命令2、⼀个终端同⼀时间只能对⼀个作业发送信号和读取信息，这个作业进程成为前台进程3、可以将作业进程放⼊后台，可以运⾏也可以暂停4、每个 terminal 就是⼀个会话，⾥⾯可能含有⼀个前台进程和任意数量的后台进程。⼀个 作业只能属于⼀个会话5、ps 输出中有些进程由系统启动，不是由 shell 提⽰符启动。这种进程没有 terminal，⽆ 法切换到前台，在 ps 中显⽰为 ？</code></pre><p>后台运行作业</p><p>后台工作：命令 + &amp;</p><p>查看后台作业的ID：jobs</p><p><img src="/../../../../images/clip_image030-171729947458916.jpg" alt="img"></p><p>fg %job id 可将后台作业转⾄前台</p><p><img src="/../../../../images/clip_image031-171729947458915.png" alt="img"></p><p>ctrl+z 可将前台进程放到后台，并暂停运⾏</p><p><img src="/../../../../images/clip_image032-171729947458917.png" alt="img"></p><p>bg %jobid 可以在后台继续运⾏作业</p><p><img src="/../../../../images/clip_image033-171729947458918.png" alt="img"></p><p>nohup</p><p>作用：在后台运行，不受终端挂断的影响</p><p>例如：主机的虚拟主机serverA执行：nohup ping baidu.com &gt; &#x2F;dev&#x2F;null &amp; 如果退出终端，换另一个serverB，serverA的那个任务也不会被影响</p><p>控制进程调度</p><p>1、 通过使⽤称为 time-slicing 或 multitasking 的技术，Linux 和其他操作系统可运⾏超出</p><p>其处理单元数的进程</p><p>2、 操作系统进程调度程序在单个核⼼上的进程之间快速切换，从⽽给⼈⼀种有多个进程 在同时运⾏的印象</p><p>进度优先级：</p><p>可以设置针对不同的进程，采⽤不同的调度策略</p><p>系统上运⾏的⼤多数进程所使⽤的调度策略称为SCHED_OTHER</p><p>(也称为 SCHED_NORMAL), 是Linux默认的调度策略， 其目标是安装进程的优先级和运行</p><p>时间的比例来分配CPU时间，以确保公平性</p><p>可为采⽤ SCHED_NORMAL 策略运⾏的进程指定相对优先级，优先级称为 nice 值</p><p><img src="/../../../../images/clip_image035-171729947458919.jpg" alt="img"></p><p>nice值范围：-20(max)~19(min)</p><p>默认情况下：进程将继承其父进程的nice值，通常为0</p><p>nice 值越⾼，表⽰优先级越低（该进程容易将其 CPU 使⽤量让给其他进程）；nice 值越低，</p><p>表⽰优先级越⾼ （该进程更加不倾向于让出 CPU）</p><p>如果不存在资源争⽤（例如，当活动进程数少于可⽤ CPU 核⼼数时），即使 nice 值 ⾼的</p><p>进程也将仍使⽤尽可能 多 CPU 资源</p><p>设置nice值和权限</p><p>只有root用户可以降低进程的nice值，普通用户的权限仅限于提高自己进程</p><p>的nice值，不能降低自己进程的nice值</p><p><img src="/../../../../images/clip_image037-171729947459022.jpg" alt="img"></p><p>更改现有进程的NICE级别</p><p>1、    renice命令</p><p>2、    top命令，在交互式界面中，按r键访问renice命令,输入pid，nice值</p><p>中断进程(kill)</p><p>使用signals来控制进程</p><p>signals 指的是发给进程的软件中断</p><p>signals 向执⾏中的程序报告事件</p><p>⽣成 signals 的事件可以是错误或者外部事件</p><pre><code class="perl">一些常见的signals：1 HUP 挂起：常⽤来重新加载配置，不是终⽌，与19有区别 2 INT 键盘中断：导致程序终⽌，通过键⼊ ctrl-c发送 3 QUIT 键盘退出：与2类似，在终⽌是发⽣进程转储。输⼊ quit或者 ctrl-\ 发送 9 KILL 中断：⽆法拦截 导致⽴即终⽌进程，最致命 15 TERM 终⽌：（默认） 正常关闭 18 CONT 继续：恢复进程 19 STOP 暂时停⽌：⽆法拦截 20 TSTP 键盘停⽌：通过 ctrl-z 发送，可以被拦截、忽略或处理</code></pre><p>kill(杀死进程)</p><p>kill -l   查看可以发生的signals</p><p>格式：kill -signal PID</p><pre><code class="perl">killall(运行通过进程名字结束进程, 而不是通过PID)格式： killall [选项] 进程名  注意：选项是可选的-i：交互式确认-u：仅终止属于指定用户的进程-e：要求进程名与指定的名称完全匹配，而不是部分匹配例如：killall -u jack httpd  终止所有名为httpd，且用户”jack”的进程</code></pre><p>pkill -SIGKILL -u username 强制中断某⼀⽤⼾的所有进程（注：pkill -9 -u username 也可）</p><p><img src="/../../../../images/clip_image039-171729947458920.jpg" alt="img"></p><p>以管理员⾝份注销⽤⼾</p><p>w命令：显⽰当前登录系统的⽤⼾</p><p><img src="/../../../../images/clip_image041-171729947459021.jpg" alt="img"></p><pre><code class="perl">TTY列：显示用户的位置，pts/N表示图形化终端, ttyN表示文字界面终端FROM列：显示用户来自，:0表示本机JCPU：表示后台程序使用CPU时间PCPU：表示前台程序使用CPU时间所有用户登录会话都与某个终端设备(TTY)相关联。如果设备名称为 pts/N，说明这是一个与图形终端窗口或远程登录会话相关联的伪终端。如果为 ttyN，则说明用户位于一个系统控制台、替代控制台或其他直接连接的终端设备上</code></pre><p>查看终端的名称：tty</p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p> 进程</p><p><strong>定义：是指正在运行的程序，包括：</strong></p><p><strong>分配的内存地址空间、安全属性、包括所有权和特权、⼀个或多个线程、进程状态</strong></p><p><strong>进程的环境包括：本地和全局变量、当前调度上下****⽂、分配的系统资源，如⽂件和⽹络端⼝</strong></p><p><strong>是当前进程（parent）复制⾃⼰的地址空间 (fork) 来创建⼀个新的（⼦）进程结构，每个进程具PID。</strong></p><p><strong>例子：主机A利用SSH登录，相当于启动了一个进程，这个终端相当于一个父进程(Shell)，</strong></p><p><strong>所有操作都是在这个Shell里面操作，Shell里面执行任务(命令)的过程，首先接触新的任务，然后Shell拷贝一个自己的环境，来接收新的指令，替换到子进程来执行，当子进程执行过程时，父进程处于锁定状态(等待子进程资源的释放。)</strong></p><p><strong>进程状态：</strong></p><pre><code class="perl">运行：R，在运行或者等待运行。睡眠：1、S，等待一个条件的成立(例如passwd，当输入两次密码之间，sleep状态)2、D，不响应信号，相当于windows的死机3、K，允许等待中的任务响应中断(不完全卡死，能够热重启)4、I，接受致命信号(能够强制退出)僵停1、Z，除了进程身份的ID，其他资源已经释放。2、X，已经彻底释放，但是游离存在进程</code></pre><p><strong>注意：</strong>在单 CPU 系统上，⼀次只能运⾏⼀个进程。可以看到多个状态为R 的进程。但是，并⾮ 所有进程都在连续运 ⾏，其中⼀些处于等待状态</p><p>**PS(**<strong>静态查看系统的进程)</strong></p><p><strong>PS命令的三种风格：</strong></p><p><strong><img src="/../../../../images/clip_image002-17172985895591.png" alt="img"></strong></p><p><strong>dash表示：-</strong></p><p><strong>PS****命令列出当前进程，包括：</strong></p><p><strong>运行进程的⽤⼾ UID、进程 PID、CPU 在其上运⾏时间、分配的内存量、进程的 stdout 位置，称为控制终端、当前进程状态</strong></p><p><strong>注意：ps -aux（UNIX 格式） 不等于 ps aux（BSD 格式）</strong></p><p><strong>ps 的常⽤选项是 aux、lax（⻓列表）、-ef，-o(定制ps的输出格式)</strong></p><p><strong><img src="/../../../../images/clip_image004-17172985895602.png" alt="img"></strong></p><p><strong>PPID表示：父进程</strong></p><p><strong>pstree(<strong>以树形的结构列出系统内的进程</strong>)</strong></p><p><img src="/../../../../images/clip_image006.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑卷-autofs</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E5%8D%B7-autofs/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E5%8D%B7-autofs/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑卷的管理"><a href="#逻辑卷的管理" class="headerlink" title="逻辑卷的管理"></a>逻辑卷的管理</h1><p>物理的存储设备、物理卷、卷组、逻辑卷</p><p>物理卷：是物理的存储设备映射到物理卷</p><p>卷组：多个物理卷的融合，卷组可以动态扩容</p><p>逻辑卷：是卷组中的部分&#x2F;全部。</p><p><img src="/../../../../images/clip_image002-17172992261091.jpg" alt="img"></p><h2 id="实施LVM工作流"><a href="#实施LVM工作流" class="headerlink" title="实施LVM工作流"></a>实施LVM工作流</h2><p>Block Device―&gt;PV―&gt;VG―&gt;LV―&gt;File System―&gt;mount</p><p>#创建物理卷（可以是整个磁盘，也可以是分区）</p><p><img src="/../../../../images/clip_image004-17172992261103.jpg" alt="img"></p><p>#创建卷组</p><p><img src="/../../../../images/clip_image006-17172992261104.jpg" alt="img"></p><p>#创建逻辑卷</p><p><img src="/../../../../images/clip_image008-17172992261102.jpg" alt="img"></p><p>#格式化逻辑卷</p><p><img src="/../../../../images/clip_image010-17172992261105.jpg" alt="img"></p><p>#查看UUID的方式</p><p><img src="/../../../../images/clip_image012-17172992261106.jpg" alt="img"> </p><p>#自动挂载</p><p><img src="/../../../../images/clip_image014-17172992261107.jpg" alt="img"></p><p>#查看逻辑卷、查看卷组</p><p><img src="/../../../../images/clip_image016-17172992261108.jpg" alt="img"></p><p>#删除逻辑卷</p><p><img src="/../../../../images/clip_image018-17172992261109.jpg" alt="img"></p><p>#删除卷组</p><p><img src="/../../../../images/clip_image019.png" alt="img"></p><p>#删除物理卷</p><p><img src="/../../../../images/clip_image021.jpg" alt="img"></p><p>#指定PE的大小</p><p><img src="/../../../../images/clip_image023.jpg" alt="img"></p><h2 id="扩容逻辑卷"><a href="#扩容逻辑卷" class="headerlink" title="扩容逻辑卷"></a>扩容逻辑卷</h2><p>ext4类型</p><p><img src="/../../../../images/clip_image025.jpg" alt="img"></p><p>xfs类型</p><p><img src="/../../../../images/clip_image027.jpg" alt="img"></p><p>lvextend和lvresize区别</p><p>lvextend：支持扩展逻辑卷，不支持缩小逻辑卷</p><p>lvresize：支持扩展和缩小逻辑卷</p><h2 id="管理分层存储"><a href="#管理分层存储" class="headerlink" title="管理分层存储"></a>管理分层存储</h2><p><img src="/../../../../images/clip_image029.jpg" alt="img"></p><p>特点：</p><p>1、    直接在磁盘里面创建两个没有大小的文件系统，可以创建不同类型的文件系统</p><p>2、    不划区域，直接使用</p><p>创建</p><p><img src="/../../../../images/clip_image031.jpg" alt="img"></p><h1 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a>nfs</h1><h2 id="配置⽂件："><a href="#配置⽂件：" class="headerlink" title="配置⽂件："></a>配置⽂件：</h2><p><img src="/../../../../images/clip_image033-171729922611110.jpg" alt="img"></p><p>#创建共享目录、配置nfs共享、启动nfs服务、验证nfs共享配置(关闭防火墙)</p><p><img src="/../../../../images/clip_image035-171729922611111.jpg" alt="img"></p><p>客户端验证nfs共享(实验环境关闭防火墙)、挂载nfs共享到本地</p><p><img src="/../../../../images/clip_image037-171729922611112.jpg" alt="img"></p><p>验证:</p><p><img src="/../../../../images/clip_image039-171729922611113.jpg" alt="img"></p><p><img src="/../../../../images/clip_image041-171729922611114.jpg" alt="img"></p><h2 id="autofs⾃动挂载"><a href="#autofs⾃动挂载" class="headerlink" title="autofs⾃动挂载"></a>autofs⾃动挂载</h2><p>我们在使用Linux时，如果要访问硬件资源，则需要使用mount命令进行挂载，将硬件资源与一个目录进行对应，然后才可以访问使用该存储介质。如果使用samba或者是NFS服务，也需要对远程存储设备进行挂载。mount挂载是使用外部存储介质或者文件系统所必须的一步操作，但是如果挂载的资源过多，则会给网络资源和服务器资源造成一定的负载，从而降低服务器性能。</p><p>为了解决这一问题，我们可以使用autofs服务，autofs是一种系统守护进程，我们可以把挂载信息写入其配置文件中，如果用户不访问其他存储介质的，则系统不会进行挂载，如果用户尝试访问该存储介质，则autofs会自动进行挂载操作，上述所有操作对用户而言是透明的，这样一来，autofs服务节省了服务器的网络和硬件资源</p><h3 id="安装autofs"><a href="#安装autofs" class="headerlink" title="安装autofs"></a>安装autofs</h3><p><img src="/../../../../images/clip_image043-171729922611115.jpg" alt="img"></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><img src="/../../../../images/clip_image045-171729922611116.jpg" alt="img"></p><p><img src="/../../../../images/clip_image047-171729922611117.jpg" alt="img"></p><p>客户端</p><p><img src="/../../../../images/clip_image049-171729922611118.jpg" alt="img"></p><p><img src="/../../../../images/clip_image051-171729922611119.jpg" alt="img"><img src="/../../../../images/clip_image052.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通配符</title>
      <link href="/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
      <url>/2024/06/02/%E7%AC%94%E8%AE%B0/Linux/%E5%9F%BA%E7%A1%80/%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>通配符</p><p><img src="/../../../../images/clip_image002-17172982471651.gif" alt="img"></p><p>* 匹配0次或任意多次字符</p><p>？匹配单一字符</p><p>[]括号内部的字符符合匹配规则，不在括号内的不符合匹配规则</p><p>[!abc]和[^abc] 排除中阔内部的字符，其余都符合匹配规则</p><p><img src="/../../../../images/clip_image004-17172982471664.gif" alt="img"></p><p><img src="/../../../../images/clip_image006-17172982471662.gif" alt="img"></p><p><img src="/../../../../images/clip_image008-17172982471665.gif" alt="img"></p><p>Man 命令 查看帮助信息</p><p><img src="/../../../../images/clip_image010-17172982471663.gif" alt="img"></p><p>可执行程序或 Shell 命令</p><p>系统调用（内核提供的函数）</p><p>库调用</p><p>特殊文件（通常位于 &#x2F;dev 目录）</p><p>文件格式和约定（比如 &#x2F;etc&#x2F;passwd）</p><p>游戏</p><p>杂项（包和一些约定）</p><p>系统管理命令通常是 root 用户执行的命令）</p><p>内核相关的文件</p><p>man帮助⽂档的快捷操作</p><p>上下键      翻页</p><p>Q         退出帮助文档</p><p>&#x2F; 向下搜索 搭配 n 键跳到下一个搜索到的位置<br> ? 向上搜索 搭配 n 键跳到下一个搜索到的位置</p><p><strong>注意：</strong>man是基于⼀个数据库进⾏帮助⽂档检索操作，有时候数据库没有同步是查不到结果的可以在root⽤⼾下执⾏以下命令同步数据库</p><p><strong>同步man的数据库：mandb</strong></p><p>通过关键字检索帮助文档的信息</p><p>例如：man -k passwd</p><p>man帮助⽂档包含以下的内容</p><p><img src="/../../../../images/clip_image012-17172982471667.gif" alt="img"></p><p>通过rpm软件包管理器这个命令进⾏帮助的查找</p><p>#查看软件是否安装</p><p>#查看软件安装过程都部署了哪些文件</p><p><img src="/../../../../images/clip_image014-17172982471666.gif" alt="img"></p><p>#查看软件的配置文件</p><p>rpm -qc openssh</p><p>#查看软件的帮助文档</p><p>rpm -qd openssh</p><p>#软件安装的时候都执行了那些操作</p><p>rpm -q –scripts openssh</p><p><img src="/../../../../images/clip_image016-17172982471668.gif" alt="img"></p><p>安全审计使用,当你拿到一个不确定的软件包，不确定里面的操作是否对你系统造成影响，可以使用该命令查看该软件包的命令</p><p>使用浏览器查找文档：firebox &#x2F;usr&#x2F;share&#x2F;doc</p><p>重定向</p><p><img src="/../../../../images/clip_image018-17172982471669.gif" alt="img"></p><p>“&gt;”的含义  </p><p>1、输出重定向，改变了命令的输出方向</p><p>2、覆盖输出重定向，他会覆盖文件的原始内容，如果你要修改配置文件的选项慎用</p><p>“&gt;&gt;”的含义</p><p>注意 &gt; 和 1&gt; 一样</p><p>追加输出重定向，他不会删除原始文件的内容,而是叠加原始文件的内容</p><p>“2&gt;”： 错误输出重定向，将错误的输出重定向到目标文件</p><p>”2&gt;&gt;”： 标准的错误追加输出重定向，将错误的输出重定向追加到目标文件</p><p>“&amp;&gt;”：正确和错误都输出</p><p>“&amp;&gt;&gt;”：正确和错误都追加输出</p><p>输出演示：</p><p><img src="/../../../../images/clip_image020-171729824716612.gif" alt="img"></p><p><img src="/../../../../images/clip_image022-171729824716610.gif" alt="img"> <img src="/../../../../images/clip_image024-171729824716611.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Linux - 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理层和数据链路层_通俗版</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E7%89%A9%E7%90%86%E5%B1%82%E5%92%8C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-%E9%80%9A%E4%BF%97%E7%89%88/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E7%89%A9%E7%90%86%E5%B1%82%E5%92%8C%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-%E9%80%9A%E4%BF%97%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h2 id="物理层的易懂理解"><a href="#物理层的易懂理解" class="headerlink" title="物理层的易懂理解"></a>物理层的易懂理解</h2><h3 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h3><pre><code>名词概念：数据(data)——运送消息的实体。信号(signal)——数据的电气或电磁表现。 “模拟的”——消息的参数的取值是连续的。 “数字的”(digital)——消息的参数的取值是离散的，比如0、1。 码元(code)——用波形表示数字信号时，代表不同离散数值的基本波形。如：0、1是两种码元。模拟数据和数字数据是什么？模拟数据就是连续变化的数据，比如，温度计的读数、音乐声音的波形、收音机接收到的无线电信号等都是模拟数据的例子。模拟数据在时间和值上都是连续的，它可以在一个范围内的任意值。通常用无限个可能的值来表示，因此需要无限的精度来准确地描述。举个例子：比如你的汽车速度表，它会在一个范围内（比如0到120 mph）连续变化。当你加速或减速时，速度指针会平滑地移动，而不是突然跳跃到一个新的速度值。数字数据是离散的，它是用一系列的离散值来表示的举例来说，计算机的文本、图像、音频文件，以及数字信号（如数字音频或数字电视信号）等都是数字数据。数字数据是通过离散的数值来表示的，这些数值被编码成二进制形式，只能是0和1。每个数字的值都与一组二进制位（0和1的序列）相对应。举个例子：当你看到计算机屏幕上的文本时，你实际上看到的是由许多小点（像素）组成的图案，每个点的颜色和位置决定了字母、数字或符号。这些颜色和位置的组合被编码成数字，以便计算机可以理解并在屏幕上显示。总结以下：--------------模拟数据常用于声音、视频、传感器信号等连续变化的场合，而数字数据则常用于计算机和数字设备中，用于表示文本、图像、音频等。--------------</code></pre><h4 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h4><p><img src="/../../../../images/image-20240601174334761.png" alt="image-20240601174334761"></p><h4 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a><strong>编码与调制</strong></h4><p>为什么需要编码和调制呢？</p><pre><code>一般情况，数字信号是在数字信道传输，模拟信号在模拟信道传输。如果需要在不同信道传输，就需要编码和调制，不然就会受到噪声和失真的影响。1、频谱效率和带宽利用编码和调制可以有效地利用信道的频谱资源。通过改变信号的特性，可以在有限的频谱范围内传输更多的数据，提高频谱效率和带宽利用率。2、不同设备之间的互联我们互联一般都是不同设备之间的，经常需要将信息传输到不同类型的设备之间，编码和调制可以使得不同设备之间的通信更加可靠和高效。3、噪声和失真的影响信号在传输过程中会受到噪声和失真的影响，这可能导致信号的质量下降。通过编码和调制可以增加信号的鲁棒性和抗干扰能力，减少数据传输中的错误。4、保护隐私和安全编码可以用于加密数据，保护通信中的隐私和安全。通过在传输前对数据进行编码，可以防止未经授权的访问者窃听或篡改数据。</code></pre><p><img src="/../../../../images/image-20240325211504778.png" alt="image-20240325211504778"></p><p>模拟—–&gt; 数字    &#x3D;&#x3D;&#x3D;&#x3D;编码</p><p>数字—–&gt; 模拟    &#x3D;&#x3D;&#x3D;&#x3D;调制</p><h4 id="数字数据用数字信号表示"><a href="#数字数据用数字信号表示" class="headerlink" title="数字数据用数字信号表示"></a><strong>数字数据用数字信号表示</strong></h4><p>不（非）归零编码</p><p>Ø用负电平表示逻辑“0”；</p><p>Ø用正电平表示逻辑“1”；</p><p>Ø也可以有其他表示方法。</p><p><img src="/../../../../images/image-20240325212100565.png" alt="image-20240325212100565"></p><p>归零编码</p><p>正脉冲代表1，负脉冲代表0</p><p>曼彻斯特编码</p><p>Ø每个比特的中间有一次电平跳变； </p><p>Ø“1”定义为由高电平到低电平的跳变；</p><p>Ø“0”定义为由低电平到高电平的跳变。</p><p><img src="/../../../../images/image-20240325212638505.png" alt="image-20240325212638505"></p><p>差（微）分曼彻斯特编码</p><p>Ø差分曼彻斯特编码是对曼彻斯特编码的改变。</p><p>Ø“0”和“1”是根据两比特之间有没有跳变来区分。</p><p>Ø如果下一个数是“0”，则在两比特中间有一次跳变；</p><p>Ø如果下一个数据是“1”，则在两比特中间没有电平跳变。</p><p><img src="/../../../../images/image-20240325212508577.png" alt="image-20240325212508577"></p><p><strong>数字数据常用编码方式（小结）</strong></p><p><img src="/../../../../images/image-20240325212721709.png" alt="image-20240325212721709"></p><h4 id="数字数据用模拟信号表示"><a href="#数字数据用模拟信号表示" class="headerlink" title="数字数据用模拟信号表示"></a><strong>数字数据用模拟信号表示</strong></h4><p><strong>基带信号****（基本频带信号）——</strong>矩形脉冲波形的数字信号。含较多的低频成分和直流成分。**</p><p><img src="/../../../../images/image-20240325212926587-17172319784612.png" alt="image-20240325212926587"></p><p><strong>带通信号</strong>——把基带信号经过载波调制后，<strong>将信号的频率范围搬移到较高的频段以便在模拟信道中传输。</strong></p><pre><code>最基本的调制方法有以下几种：调幅（AM）：载波的振幅随基带数字信号而变化。 调频（FM）：载波的频率随基带数字信号而变化。调相（PM）：载波的初始相位随基带数字信号而变化。  </code></pre><p><img src="/../../../../images/image-20240325213107645.png" alt="image-20240325213107645"></p><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>1、并行传输 与 串行传输</p><pre><code>并行传输，一次发送n个比特串行传输，一个比特一个比特依次发送。特点:并行 速率快，适合短距离，占用成本高串行 速率慢，适合长距离，占用成本低</code></pre><p><img src="/../../../../images/image-20240325131247261.png" alt="image-20240325131247261"></p><p>2、异步传输和同步传输</p><pre><code>同步思想：就是指收发双方在时间基准上保持一致的过程可分为：异步传输：以字节为单位，字节之间时间不固定。同步传输：以比特流的形式传输，字节之间无间隔。什么是同步传输？举例子，比如要传输3个文件，接收端第一个文件接收完，再传输第二个文件。</code></pre><p>3、单工、半双工、全双工通信</p><pre><code>单向（工）通信--只能一个方向  例如广播双向交替通信（半双工通信）--不能双方同时  例如对讲机双向同时通信（全双工通信）--双方同时   例如手机打电话</code></pre><h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><pre><code>什么是码元？码元是承载信息的基本信息单位，一个码元能够承载的信息量多少，是由码元信号所能表示的数据有效值状态个数决定的。为了提高信息的传输速率，有人肯定想&quot;在一定的时间内能够传输尽可能多的码元&quot;，这是对的嘛？这个想法是错误的。通俗地讲，一个&quot;行李箱&quot;肯定有承受重量的范围，你一直往&quot;行李箱&quot;一直塞，肯定&quot;行李箱&quot;承受不住，就会丢弃一些，使得“行李箱”能够保持它能够承受的范围。失真严重是什么？是指输出信号波形的形态，如图4</code></pre><p><img src="/../../../../images/image-20240325133324183.png" alt="image-20240325133324183"></p><pre><code>信道输出端的波形的失真影响因素有？1、码元信号承载的信息大多，码元传输速率太高。2、信号传输的距离太远3、噪声干扰大4、传输媒体质量差解释:①信号传输的距离太远,好比你跑步，越跑就越累，不可能全程无损耗②噪声干扰大什么是噪声是指该信道中不需要的电信号，通俗地说，就是除该信道自身要传输的数据外，其他数据在该通道传输通称为噪声。</code></pre><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><pre><code>码元的传输速率是有限的。则这个范围界限可推导：推导者：奈奎斯特公式：理想低通道信道的最高码元传输速率=2W(波特)W = 信道带宽，简称：带宽，单位为赫兹(Hz)波特(Baud)是码元传输速率的单位，1波特为每秒传送1一个码元什么是理想低通道？就是信号的所有低频分量，只要其频率不超过某一个上限值，都能够不失真地通过此通道。</code></pre><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><pre><code>香农公式指出： 信道的极限信息传输速率C是C = Wlog2^(1+S/N) (bit/s)w = 信道的带宽(Hz)S = 信道内所传信号的平均功率，也就是传输平均功率N = 信道内部的高斯噪声功率S/N = 信噪比，也就是信道/噪声，简称信噪比C = 光速(在理想条件下)香农公式表明：1、信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。2、只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。3、若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。4、实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少（因为在实际信道中，信号还要受到其他一些损伤，如各种脉冲干扰和在传输中产生的失真等等，这些因素在香农公式中并未考虑到）------------注意：对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率，即：用编码的方法让每一个码元携带更多比特的信息量。比如要传输101011000110111010…这个基带信号，如果直接传输则每个码元所携带的信息量是1bit，现在将信号进行编码，每3个比特编为1组，即101，011，000，110，111，010…3个比特共有8种不同组合，我们可以用不同的调制方法来表示这样的信号，例如用8种不同的振幅，或8种不同的频率，这样就能表示3个bit的8种组合，这样就能达到1个bit传输原来3个bit才能传输的信息。</code></pre><h3 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h3><pre><code>传输媒体是数据传输系统中在发送器和接收器之间的物理通路。分类为：</code></pre><p><img src="/../../../../images/image-20240325161703083.png" alt="image-20240325161703083"></p><p>非引导型：§短波通信(高频通信)：多径效应，通信质量差。蓝牙也是非引导型。</p><p>多路径效应是指可以直线传播也可以曲线传播。就比如你在教室讲话，为什么隔着墙外面的人也能听见。类似这样比喻。。。</p><h4 id="电磁波"><a href="#电磁波" class="headerlink" title="电磁波"></a>电磁波</h4><p>电磁波在传输媒体上的传输。电信领域使用的电磁波的频谱：</p><p><img src="/../../../../images/image-20240325162050101.png" alt="image-20240325162050101"></p><pre><code>电磁波的波长（λ）与频率（f）之间的关系可以通过以下公式来表示:公式：c=λ×f其中：c 是光速，即电磁波在真空中的传播速度，约为 3 x 10⁸ 米/秒（m/s）λ 是波长，单位通常是米（m）f 是频率，单位是赫兹（Hz）解释以及值大小的意义~~~公式中，c=λ×fc是固定的，光速是固定的，无法达到的(实际)然而，波长和频率成为互相&quot;平衡&quot;的状态！！！λ(波长)较长时，f(频率)就会较低。f(频率)较长时，λ(波长)就会较低。---------------------------------那问题来了，波长还是频率值的大小有什么含义呢？当波长较长时，频率就会较低。波长越长代表着波的周期性更大，也就意味着波动的振荡次数（频率）较低。通俗地说就是，图的描述就是，波浪本来是10次一个周期，现在波浪是小于10次一个周期。应用场景：波长较长（低频）：电磁波的波长越长，穿透力越强。这意味着长波长的信号可以更好地穿过障碍物，如建筑物、墙壁、树木等，因此在需要穿透障碍物的通信和雷达应用中更为实用。当频率较大时，波长较低。对于无线电通信和其他电磁波应用，频率的增加通常意味着更高的数据传输速率。例如，5G和4G哪个上网速度快；肯定是5G网速快，4G用的频率是2.4GHz,5G用的是5GHz，所以提供更大的带宽和更快的数据传输速度。但是5G穿透性比较差，因为波长较低。还有个场景，雷达和卫星通信，两个国家都有通信基站，为什么两个基站不直接通信，还需要用到雷达或卫星来转发？高频率信号在穿透障碍物（如墙壁或建筑物）时的能力会相对较低，因为它们更容易被障碍物吸收或反射。这可能会导致在某些环境中信号的覆盖范围减少，需要更多的信号中继器或增强器来保持连接的质量。有没有发现，基站到中转站是直线发送的，其实是有原因的高频率信号更容易聚焦，在雷达和通信系统中，高频率信号的波束更容易集中在特定方向上，从而提高了信号的定向性和精确度。</code></pre><p><img src="/../../../../images/image-20240325201642670.png" alt="image-20240325201642670"></p><h4 id="传输媒体-1"><a href="#传输媒体-1" class="headerlink" title="传输媒体"></a>传输媒体</h4><h5 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h5><p>分为：</p><p>无屏蔽双绞线 UTP</p><p>屏蔽双绞线 STP</p><p><img src="/.com//../../..%5Cimages%5Cimage-20240325202412942.png" alt="image-20240325202412942"></p><p><img src="/../../../../images/image-20240325202557813.png" alt="image-20240325202557813"></p><p>五类双绞线的最大传输距离为100m。加中继器最多加4个到500m</p><h5 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h5><p>主要用于居民小区的有线电视</p><p><img src="/../../../../images/image-20240325202412942.png" alt="image-20240325202730531"></p><h5 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h5><p>分为：单模光纤和多模光纤</p><p><img src="/../../../../images/image-20240325203055814.png" alt="image-20240325203055814"></p><pre><code>光纤特点：1)传输损耗小，中继距离长，对远距离传输特别经济.2)抗雷电和电磁干扰性能好.(3)无串音干扰，保密性好，也不易被窃听或截取数据。(4)体积小，重量轻。单模光纤特点：低损耗、传输远、成本高、窄的芯径和光束、单一的波长传输多模光纤特点：低成本、适合短距离、较大的芯径、多模波长传输------------------怎么理解 芯径和光束 以及 波长传输？？？窄的芯径和光束：单模光纤的光芯（core）非常细小，使得光信号在光纤中只沿着一个路径传播，而不是多个路径。较大的芯径：多模光纤的光芯比单模光纤要大，这意味着光信号在光纤中可以沿着多个路径传播（多个模式）。单一波长传输：单模光纤通常用于传输单一波长的激光光信号。多模波长传输：多模光纤通常使用 LED（发光二极管）或激光二极管作为光源，这些光源可以发出多个波长的光。因此，多模光纤可以支持多个波长的光信号传输。</code></pre><h5 id="集线器与交换机"><a href="#集线器与交换机" class="headerlink" title="集线器与交换机"></a>集线器与交换机</h5><pre><code>集线器共享宽带，交换机独享宽带怎么理解？？有100M宽带，4个人使用情景1，使用集线器当他们共同使用时，每个人只能享受25M情景2，使用交换机当她们共同使用时，每个人能独享100M，但不包括同一时间</code></pre>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
            <tag> 物理层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储与RAID</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E5%AD%98%E5%82%A8%E4%B8%8ERAID/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E5%AD%98%E5%82%A8%E4%B8%8ERAID/</url>
      
        <content type="html"><![CDATA[<h1 id="存储与RAID"><a href="#存储与RAID" class="headerlink" title="存储与RAID"></a>存储与RAID</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="存储系统层次结构"><a href="#存储系统层次结构" class="headerlink" title="存储系统层次结构"></a>存储系统层次结构</h3><p>存储体系结构：</p><p><strong>寄存器、告诉缓存存储器、主存储器、外存储器</strong></p><p><img src="/../../../../images/image-20240521094220951.png" alt="image-20240521094220951"></p><h3 id="存储介质选择"><a href="#存储介质选择" class="headerlink" title="存储介质选择"></a>存储介质选择</h3><p><img src="/../../../../images/image-20240521094508175.png" alt="image-20240521094508175"></p><h3 id="HHD机械硬盘与SSD固态硬盘"><a href="#HHD机械硬盘与SSD固态硬盘" class="headerlink" title="HHD机械硬盘与SSD固态硬盘"></a>HHD机械硬盘与SSD固态硬盘</h3><p>机械硬盘的连续读写性好，但随机读写性能很差。</p><p>G固态硬盘，读写性能好，但数据盘损坏，恢复极难。</p><p><img src="/../../../../images/image-20240521094841302.png" alt="image-20240521094841302"></p><p><strong>常见存储</strong></p><p>NVRAM：非易失存储器，用来保存启动配置文件。</p><p>Flash：闪存，用来保存华为VRP&#x2F;思科IOS系统软件。</p><p>ROM：只读，用来存储引导程序。</p><p>RAM：随机存储器，即内存，保存当前运行的配置程序，系统关闭或重启信息会丢失。</p><p><img src="/../../../../images/image-20240521095320924.png" alt="image-20240521095320924"></p><h2 id="传统RAID技术"><a href="#传统RAID技术" class="headerlink" title="传统RAID技术"></a>传统RAID技术</h2><p>RAID：<strong>独立磁盘冗余阵列。</strong></p><p><strong>RAID技术将多个单独的物理硬盘以不同的方式组合成一个逻辑硬盘，从而提高了硬盘的读写性能和数据安全性</strong></p><h3 id="RAID数据组织及存取方式"><a href="#RAID数据组织及存取方式" class="headerlink" title="RAID数据组织及存取方式"></a>RAID数据组织及存取方式</h3><p><img src="/../../../../images/image-20240521095631527.png" alt="image-20240521095631527"></p><p><img src="/../../../../images/image-20240521095622119.png" alt="image-20240521095622119"></p><h3 id="RAID热备和重构"><a href="#RAID热备和重构" class="headerlink" title="RAID热备和重构"></a>RAID热备和重构</h3><p><strong>热备(HotSpare)<strong>：当冗余的RAID组中某个硬盘失效时，在不影响当前RAID系统的正常使用的情况下，用RAID系统中的</strong>备用硬盘自动顶替失效硬盘</strong>，及时保证RAID系统的冗余性。</p><p>热备分为：</p><p>​全局式：备用硬盘为系统中所有的冗余RAID组共享</p><p>​专用式：备用硬盘为系统中某一组冗余RAID组专用</p><p><img src="/../../../../images/image-20240521100033049.png" alt="image-20240521100033049"></p><h3 id="RAID-逻辑卷-LUN"><a href="#RAID-逻辑卷-LUN" class="headerlink" title="RAID-逻辑卷(LUN)"></a>RAID-逻辑卷(LUN)</h3><p><img src="/../../../../images/image-20240521100110001.png" alt="image-20240521100110001"></p><h3 id="常用RAID技术"><a href="#常用RAID技术" class="headerlink" title="常用RAID技术"></a>常用RAID技术</h3><h4 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h4><p><img src="/../../../../images/image-20240521100236207.png" alt="image-20240521100236207"></p><p>利用率：100%，不允许坏硬盘，最少两块</p><h4 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h4><p><img src="/../../../../images/image-20240521100547815.png" alt="image-20240521100547815"></p><p>利用率：50%，最少两块，最多允许坏一半硬盘</p><h4 id="RAID-3和RAID-5"><a href="#RAID-3和RAID-5" class="headerlink" title="RAID 3和RAID 5"></a>RAID 3和RAID 5</h4><p><img src="/../../../../images/image-20240521100707070.png" alt="image-20240521100707070"></p><p>RAID 3利用率：N-1&#x2F;N，最少3块，允许坏1块硬盘</p><p>RAID 5利用率：N-1&#x2F;N，最少3块，允许坏1块硬盘</p><p>共同点：均采用奇偶校验</p><p>不同点：</p><p>RAID 3 有专用校验硬盘来存储校验数据</p><p>RAID 5 把数据块和对应的校验信息存放在不同的硬盘上。</p><h4 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h4><p><img src="/../../../../images/image-20240521101424972.png" alt="image-20240521101424972"></p><p>利用率：N-2&#x2F;N，最少4块硬盘，允许坏2块硬盘。</p><h4 id="RAID-10-和-RAID-50"><a href="#RAID-10-和-RAID-50" class="headerlink" title="RAID 10 和 RAID 50"></a>RAID 10 和 RAID 50</h4><p><img src="/../../../../images/image-20240521101611101.png" alt="image-20240521101611101"></p><h4 id="常用RAID技术对比"><a href="#常用RAID技术对比" class="headerlink" title="常用RAID技术对比"></a>常用RAID技术对比</h4><p><img src="/../../../../images/image-20240521101638781.png" alt="image-20240521101638781"></p><h2 id="RAID-2-0技术"><a href="#RAID-2-0技术" class="headerlink" title="RAID 2.0技术"></a>RAID 2.0技术</h2><h3 id="传统RAID和RAID-2-0区别"><a href="#传统RAID和RAID-2-0区别" class="headerlink" title="传统RAID和RAID 2.0区别"></a>传统RAID和RAID 2.0区别</h3><p><img src="/../../../../images/image-20240521110116844.png" alt="image-20240521110116844"></p><p><img src="/../../../../images/image-20240521110129724.png" alt="image-20240521110129724"></p><h3 id="RAID-2-0优势"><a href="#RAID-2-0优势" class="headerlink" title="RAID 2.0优势"></a>RAID 2.0优势</h3><p>1、快速重构</p><p>2、硬盘负载均衡</p><p>3、硬盘利用率高</p><p>4、存储管理效率</p><h2 id="网络存储体系DAS-NAS-SAN"><a href="#网络存储体系DAS-NAS-SAN" class="headerlink" title="网络存储体系DAS&#x2F;NAS&#x2F;SAN"></a>网络存储体系DAS&#x2F;NAS&#x2F;SAN</h2><p>存储发展过程</p><p><img src="/../../../../images/image-20240521110922822.png" alt="image-20240521110922822"></p><p>DAS起源</p><p><img src="/../../../../images/image-20240521111013816.png" alt="image-20240521111013816"></p><p>FC-SAN起源(DAS -&gt; FC SAN)</p><p><img src="/../../../../images/image-20240521111059476.png" alt="image-20240521111059476"></p><p>IP SAN起源(FC SAN -&gt; IP SAN)</p><p><img src="/../../../../images/image-20240521111218291.png" alt="image-20240521111218291"></p><p>NAS起源(网络数据共享与交换需求)</p><p><img src="/../../../../images/image-20240521111300963.png" alt="image-20240521111300963"></p><h3 id="几种存储对比"><a href="#几种存储对比" class="headerlink" title="几种存储对比"></a>几种存储对比</h3><p><img src="/../../../../images/image-20240521111410294.png" alt="image-20240521111410294"></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><img src="/../../../../images/image-20240521111556802.png" alt="image-20240521111556802"></p><p><img src="/../../../../images/image-20240521111606664.png" alt="image-20240521111606664"></p><p><img src="/../../../../images/image-20240521111615283.png" alt="image-20240521111615283"></p><h2 id="分布式存储-超融合"><a href="#分布式存储-超融合" class="headerlink" title="分布式存储&#x2F;超融合"></a>分布式存储&#x2F;超融合</h2><h3 id="分布式存储组成与特点："><a href="#分布式存储组成与特点：" class="headerlink" title="分布式存储组成与特点："></a>分布式存储组成与特点：</h3><p>分布式存储系统一般由3个部分组成:</p><p><strong>客户端、元数据节点和数据存储节点。</strong></p><p>元数据节点相当于目录数据存储节点采用<strong>多副本或纠删码技术</strong>实现数据冗余。</p><p>分布式存储有如下特点:</p><p><strong>(1)高性能。</strong>相比传统集中式存储，可以提供更高的IOPS和吞吐量，并且随着存储节点的增加而线性增长，可以满足高并发业务需求，比如12306购票业务。<br><strong>(2)高可靠。</strong>分布式存储系统中单台服务器可以部署RAID技术来提升可靠性，同时多台服务器组成的分布式存储系统可以采用多副本等技术保证数据冗余，单个节点出现故障能快速重建。<br><strong>(3)容量大。</strong>可以根据需要扩展服务器硬盘数量或服务器数量，提供海量存储资源池。<br><strong>(4)成本低。</strong>分布式存储系统的核心硬件是插有大量硬盘传统服务器，相对于传统集中式存储，成本更低。</p><h3 id="数据备份策略"><a href="#数据备份策略" class="headerlink" title="数据备份策略"></a>数据备份策略</h3><p>备份类型：完全备份、差量备份、增量备份</p><p><img src="/../../../../images/image-20240521112416923.png" alt="image-20240521112416923"></p><p><img src="/../../../../images/image-20240521112424066.png" alt="image-20240521112424066"></p><p>备份时间(快 -&gt; 慢)：增量备份 - 差量备份 - 完全备份</p><p>恢复时间(快 -&gt; 慢)：完全备份 - 差量备份 - 增量备份</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/../../../../images/image-20240521112551605.png" alt="image-20240521112551605"></p><p><img src="/../../../../images/image-20240521112635252.png" alt="image-20240521112635252"></p><h3 id="数据备份网络架构"><a href="#数据备份网络架构" class="headerlink" title="数据备份网络架构"></a>数据备份网络架构</h3><p><img src="/../../../../images/image-20240521112903212.png" alt="image-20240521112903212"></p><h3 id="数据备份网络架构：Server-Free"><a href="#数据备份网络架构：Server-Free" class="headerlink" title="数据备份网络架构：Server-Free"></a>数据备份网络架构：Server-Free</h3><p><img src="/../../../../images/image-20240521112949272.png" alt="image-20240521112949272"></p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p><img src="/../../../../images/image-20240521113051874.png" alt="image-20240521113051874"></p><p><img src="/../../../../images/image-20240521114009850.png" alt="image-20240521114009850"></p><p><img src="/../../../../images/image-20240521114015637.png" alt="image-20240521114015637"></p><p><img src="/../../../../images/image-20240521114024858.png" alt="image-20240521114024858"></p><p><img src="/../../../../images/image-20240521114034980.png" alt="image-20240521114034980"></p><p><img src="/../../../../images/image-20240521114041883.png" alt="image-20240521114041883"></p><p><img src="/../../../../images/image-20240521114117074.png" alt="image-20240521114117074"></p><p><img src="/../../../../images/image-20240521114127309.png" alt="image-20240521114127309"></p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP子网划分</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/IP%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/IP%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="IP子网划分"><a href="#IP子网划分" class="headerlink" title="IP子网划分"></a>IP子网划分</h1><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IPv4地址：32位，点分十进制方式表示</p><p>IP地址组成：网络位+主机位</p><p><img src="/../../../../images/image-20240510110624771.png" alt="image-20240510110624771"></p><p>例如：</p><p>192.168.0.1 - &gt; 11000000 10101000 00000000 00000001</p><p><img src="/../../../../images/image-20240510110719602.png" alt="image-20240510110719602"></p><h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p><img src="/../../../../images/image-20240510110833383.png" alt="image-20240510110833383"></p><p><img src="/../../../../images/image-20240510110840324.png" alt="image-20240510110840324"></p><h3 id="网络掩码"><a href="#网络掩码" class="headerlink" title="网络掩码"></a>网络掩码</h3><p>作用：用于描述IP地址中网络位和主机位的分界线</p><p>掩码两种表示方法:255.255.255.0&#x3D;&#x2F;24  255.255.255.128&#x3D;&#x2F;25</p><p><img src="/../../../../images/image-20240510111039229.png" alt="image-20240510111039229"></p><h3 id="三类地址"><a href="#三类地址" class="headerlink" title="三类地址"></a>三类地址</h3><p>**网络地址: **</p><p>指代网络的地址。在网络的IPv4 地址范围内，最小地址保留为网络地址。此地址的主机部分的每个主机位均为0。</p><p>**广播地址: **</p><p>用于向网络中的所有主机发送数据的特殊地址。广播地址使用该网络范围内的最大地址。<br>即主机部分的各比特位全部为1的地址。</p><p><strong>主机地址:</strong> </p><p>可分配给网络中终端设备的地址。</p><p><img src="/../../../../images/image-20240510111243336.png" alt="image-20240510111243336"></p><h2 id="VLSM和CIDR"><a href="#VLSM和CIDR" class="headerlink" title="VLSM和CIDR"></a>VLSM和CIDR</h2><p>VLSM(变长子网掩码，Variable Length Subnet Mask）</p><p>就是”子网掩码值”变大。</p><p>例如：172.16.10.0&#x2F;24  —VLSM —&gt; 172.16.10.0&#x2F;30</p><p>作用：有效利用IP地址，减小广播风暴。</p><p>CIDR(无类域间路由，超网 ClasslessInter-Domain Routing )</p><p>就是”IP地址聚合”</p><p>例如：</p><p>200.200.192.0&#x2F;24</p><p>200.200.193.0&#x2F;24</p><p>200.200.194.0&#x2F;24</p><p>200.200.195.0&#x2F;24</p><p>超网聚合：200.200.192.0&#x2F;22</p><p>作用：减小骨干路由器表项压力。</p><h2 id="子网划分-VLSM"><a href="#子网划分-VLSM" class="headerlink" title="子网划分 VLSM"></a>子网划分 VLSM</h2><p>为什么子网划分呢？</p><p>某公司有500台PC，分配一个标准C类网段(254个可用)，IP地址不够用，分配一个标准B类网IP又会产生大量的浪费(65534个可用，利用率不足1%)。标准ABC类地址存在如下问题:</p><p><strong>(1)标准主类网络划分，造成IP地址空间浪费。<br>(2)广播域中PC数量过多，广播风暴会消耗网络资源。</strong></p><p>IP子网划分和VLAN的关系：</p><p>1、都是隔离技术。</p><p>2、子网划分是针对IP(网络层)，VLAN是针对以太网(数据链路层)。</p><p>3、一般VLAN与子网对应，每个子网主机数量建议一个C类地址(254台)，最大不超4个C类地址(1016台)</p><p><img src="/../../../../images/image-20240510112541606.png" alt="image-20240510112541606"></p><h3 id="子网划分原理"><a href="#子网划分原理" class="headerlink" title="子网划分原理"></a>子网划分原理</h3><p>原理：网络位向主机位借位</p><p>网络位向主机位借位，即网络部分的位数加长，借用的位表示子网位。</p><p>如果借用1位，则可以划分为21&#x3D;2个子网，借用2位可以划分为22&#x3D;4个子网，借用3位，可以划分为23&#x3D;8个子网。</p><p><img src="/../../../../images/image-20240510113007143.png" alt="image-20240510113007143"></p><p><img src="/../../../../images/image-20240510113058784.png" alt="image-20240510113058784"></p><h3 id="类1：已知子网主机数量，进行子网划分"><a href="#类1：已知子网主机数量，进行子网划分" class="headerlink" title="类1：已知子网主机数量，进行子网划分"></a><strong>类1</strong>：已知子网主机数量，进行子网划分</h3><p>某公司有6个部门，给出IP地址段192.168.1.0&#x2F;24，如何进行子网划分?</p><p><img src="/../../../../images/image-20240510113305879.png" alt="image-20240510113305879"></p><p>扩展1:进行子网划分后，第一个子网广播地址是多少?</p><p><img src="/../../../../images/image-20240510113357127.png" alt="image-20240510113357127"></p><p>扩展2:192.168.1.159属于什么地址?</p><p><img src="/../../../../images/image-20240510113411005.png" alt="image-20240510113411005"></p><h3 id="类2：掩码转换"><a href="#类2：掩码转换" class="headerlink" title="类2：掩码转换"></a><strong>类2</strong>：掩码转换</h3><p>PC1的IP地址为192.168.5.16，PC2的IP地址为192.168.5.100，PC1和PC2在同一网段中，其子网掩<br>码可能是( D )。<br>A.255.255.255.240                                         B.255.255.255.224<br>C.255.255.255.192<br>D.255.255.255.128</p><p>【解析】100-16&#x3D;84，那么地址块需要大于84，只有D满足要求。A可以转换为&#x2F;28，地址块是232-28&#x3D;16，B可以转换为&#x2F;27，地址块是232-27&#x3D;32;C转换为126，地址块是232-26&#x3D;64;D可以转换为&#x2F;25地址块是232-25&#x3D;128。</p><p>某校园网的地址是202.115.192.0&#x2F;19，要把该网络分成30个子网，则子网掩码应该是( D )</p><p>A.255.255.200.0                                                     B.255.255.224.0<br>C.255.255.254.0<br>D.255.255.255.0</p><p>记住：128 64 32 16 8 4 2 1 0</p><p><img src="/../../../../images/image-20240510113927559.png" alt="image-20240510113927559"></p><p>对IPv4地址段192.168.10.0&#x2F;24进行子网划分，<br>要求每个子网至少50个可用IP地址其主机位数最少需要<br>(52)位，(53)属于所划分子网的网络号。</p><p>(52)A.7 B.5 C.8 D.6</p><p>(53 )                                                                     A.192.168.10.32<br>C.192.168.10.160<br>B.192.168.10.0<br>D.192.168.10.96</p><p>答案： D B</p><p>【解析】要满足每个子网50台主机，即主机位至少为6(2^6-2&#x3D;62)，网络号是&#x2F;26,地址块是2^(32-26)&#x3D;64，故子网地址肯定是64的倍数，即192.168.10.64n(n&#x3D;0,1,2,3…)。</p><h3 id="类3：掩码作用位置与地址块计算"><a href="#类3：掩码作用位置与地址块计算" class="headerlink" title="类3：掩码作用位置与地址块计算"></a>类3：掩码作用位置与地址块计算</h3><p>如下图所示，如果网络掩码是x，那么:</p><p>如果x范围是25-32，那么掩码作用于第四段，地址块&#x3D;2^(32-x),例如掩码是28，地址块&#x3D;2^(32-28)&#x3D;2^4&#x3D;16</p><p>如果x范围是17-24，那么掩码作用于第三段，地址块&#x3D;2^(24-x),例如掩码是22，地址块&#x3D;2^(24-22)&#x3D;2^2&#x3D;4</p><p>如果x范围是9-16,那么掩码作用于第二段，地址块&#x3D;2^(16-x),例如掩码是12，地址块&#x3D;2^(16-12)&#x3D;2^4&#x3D;16</p><p>如果x范围是0-8，那么掩码作用于第一段，地址块&#x3D;2^(8-x),例如掩码是7，地址块&#x3D;2^(8-7)&#x3D;2^1&#x3D;2</p><p><img src="/../../../../images/image-20240510114550154.png" alt="image-20240510114550154"></p><p>下面的IP地址中，不属于同一网络的是(52)。A.172.20.34.28&#x2F;21 B.172.20.39.100&#x2F;21  C.172.20.32.176&#x2F;21D.172.20.40.177&#x2F;21</p><p>【解析】求给出几个选项的网络地址。121掩码地址块都是224-21&#x3D;8，那么可以推出子网部分肯定是8的倍数，且作用于第三段。故172.20.32.0和172.20.40.0是网络地址，ABC都属于前者，只有D属于后者。</p><p>属于网络215.17.204.0&#x2F;22的地址是(51)。B      A.215.17.208.200<br>B.215.17.206.10<br>C.215.17.203.0<br>D.215.17.224.0</p><p>【summer解析】215.17.204.0&#x2F;22掩码是&#x2F;22，作用位在第三段，且地址块为224-22&#x3D;22&#x3D;4。可以写出所有子网地址:</p><p><img src="/../../../../images/image-20240510114734848.png" alt="image-20240510114734848"></p><p>有4个网络地址:192.168.224.1、192.168.223.255、192.168.232.25和192.168.216.5，如果子网掩码为 255.255.240.0，则这4个地址分别属于(54)个子网。下面列出的地址对中，属于同一个子网的是(55)。<br>(54)A.1B.2 C3 D.4<br>(55)                                                                      A.192.168.224.1和192.168.223.255<br>C.192.168.232.25 和192.168.216.5<br>B.192.168.223.255和192.168.232.25        D.192.168.223.255 和192.168.216.5</p><p>B D</p><p><img src="/../../../../images/image-20240510114906356.png" alt="image-20240510114906356"></p><h3 id="类4应用型子网划分"><a href="#类4应用型子网划分" class="headerlink" title="类4应用型子网划分"></a>类4应用型子网划分</h3><p>某公司为多个部门划分了不同的局域网，每个局域网中的主机数量如下表所示，计划使用地址段192.168.10.0&#x2F;24划分子网，以满足公司每个局域网的IP地址需求，请为各部门选择最经济的地址段或子网掩码长度。</p><p><img src="/../../../../images/image-20240510115630177.png" alt="image-20240510115630177"></p><p>答案： D A C</p><p>【summer解析】子网划分一般先满足主机量需求大的部门,题目中应先满足财务部需求，一共60台主机，而2^6-2&#x3D;62,刚好满足，那么主机位建议6位,地址块为2^6&#x3D;64。网络位32-6&#x3D;26，原来的网络位是24位，则相当于新增了2位子网位，可以分成4个子网，分别为:                                     192.168.10.0&#x2F;26、192.168.10.64&#x2F;26、192.168.10.128&#x2F;26、192.168.10.192&#x2F;26。<br>财务部使用这四个子网地址中的哪一个,直接看(53)题选项,只有A答案属于这四个子网，故(53)选A。接着计算营销部的掩码，由于20台主机需求，主机位为5位即可,那么子网掩码是&#x2F;27，选D。管理部主机数量为8，主机位至少为4为，掩码是&#x2F;28。计算完成后，最好带入题目进行检验，实际划分如下图所示:</p><p><img src="/../../../../images/image-20240510115716066.png" alt="image-20240510115716066"></p><p>分支机构有营销部、市场部、生产部、人事部四个部门，每个部门需要访问互联网主机数量如表所示，现计划对网段10.11.230.0&#x2F;24 进行子网划分，为以上四个部分规划IP 地址，请补充表中的空(1)-(4)。</p><p><img src="/../../../../images/image-20240510115733372.png" alt="image-20240510115733372"></p><p>[答案]     (1)10.11.230.0(2)255.255.255.192(3)10.11.230.224(4)255.255.255.240</p><p><img src="/../../../../images/image-20240510115827007.png" alt="image-20240510115827007"></p><p>该企业办公网络采用172.16.1.0&#x2F;24地址段，部门终端数量如表1-1所示，请将网络地址规划补充完整。</p><p><img src="/../../../../images/image-20240510115853079.png" alt="image-20240510115853079"></p><p>【参考答案】<br>(1)255.255.255.224<br>(3)172.16.1.33<del>172.16.1.62<br>(2)172.16.1.65</del>172.16.1.126<br>(4)255.255.255.128</p><p><img src="/../../../../images/image-20240510115926144.png" alt="image-20240510115926144"></p><p><img src="/../../../../images/image-20240510120021439.png" alt="image-20240510120021439"></p><p>(1)28<br>(2)172.16.1.17~172.16.1.30<br>(3)172.16.1.33 ~172.16.1.62<br>(4)26</p><p>假设某公司有8000台主机，采用CIDR方法进行划分，则至少给它分配(51)个C类网络。如果192.168.210.181是其中一台主机地址，则其网络地址为(52)<br>(51)A.8 B.10 C.16 D.32<br>(52)A.192.168.192.0&#x2F;19 B192.168.192.0&#x2F;20 C.192.168.208.0&#x2F;19 D.192.168.208.0&#x2F;20</p><p><a href="51">参考答案</a>D A<br>【解析】<br>(51)1个C类地址有254个可用地址，4个C即接近1000个，那么8000台PC，合计约32个C类地址</p><p>(52)8000台主机，那么主机位至少是13位，2^13-2&#x3D;8190，网络位最多32-13&#x3D;19，直接排除BD.&#x2F;19掩码作用于第3段，地址块是224-19&#x3D;25&#x3D;32，则子网必须是32的倍数。192132&#x3D;6,208&#x2F;32&#x3D;6.5<br>故排除C。</p><p>路由器收到一个数据报文，其目标地址为20.112.17.12，该地址属于(53)子网。<br>A.20.112.17.8&#x2F;30<br>C.20.96.0.0&#x2F;11<br>B.20.112.16.0&#x2F;24<br>D.20.112.18.0&#x2F;23</p><p>【参考答案】C<br>【解析】思路与上题第二问类似，A选项可用地址20.112.17.9-11，B选项可用地址是20.112.16.1-254。</p><p>C选项&#x2F;11作用于第2段，地址块是216-11&#x3D;25&#x3D;32，即可用地址区间是20.96.0.1-20.127.255.254</p><p>D选项&#x2F;23作用于第3段，地址块是224-23&#x3D;21&#x3D;2，即可用地址:20.112.18.1-20.112.19.254。</p><h2 id="无类域间路由CIDR"><a href="#无类域间路由CIDR" class="headerlink" title="无类域间路由CIDR"></a>无类域间路由CIDR</h2><p>计算过程：</p><p><img src="/../../../../images/image-20240510120319332.png" alt="image-20240510120319332"></p><p>某企业分配给产品部的IP地址块为192.168.31.192&#x2F;26，分配给市场部的IP地址块为192.168.31.160&#x2F;27，分配给财务部的IP地址块为192.168.31.128&#x2F;27，那么这三个地址块经过聚合后的地址为()。                                                 A.192.168.31.0&#x2F;25<br>B.192.168.31.0&#x2F;26<br>C.192.168.31.128&#x2F;25<br>D.192.168.31.128&#x2F;26</p><p><img src="/../../../../images/image-20240510120341224.png" alt="image-20240510120341224"></p><p>对下面4个网络:110.125.129.0&#x2F;24、110.125.130.0&#x2F;24、110.125.132.0&#x2F;24和110.125.133.0&#x2F;24进行路由汇聚，能覆盖这4个网络的地址是(26)。                                   A.110.125.128.0&#x2F;21<br>B.110.125.128.0&#x2F;22<br>C.110.125.130.0&#x2F;22<br>D.110.125.132.0&#x2F;23</p><p>【参考答案】 A<br>【解析】</p><p>110.125.10000  001.0</p><p>110.125.10000  010.0</p><p>110.125.10000  100.0</p><p>110.125.10000  101.0</p><p><strong>汇总后为110.125.128.0&#x2F;21</strong></p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由策略和流量控制</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E8%B7%AF%E7%94%B1%E7%AD%96%E7%95%A5%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="路由策略和流量控制"><a href="#路由策略和流量控制" class="headerlink" title="路由策略和流量控制"></a>路由策略和流量控制</h1><h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><p>可以通过路由策略(Route-Policy)实现。以下常用方式：</p><p>控制路由的发布:通过路由策略对发布的路由进行过滤，只发布满足条件的路由。</p><p>控制路由的接收:通过路由策略对接收的路由进行过滤，只接收满足条件的路由。</p><p>控制路由的引入:通过路由策略控制从其他路由协议引入的路由条目，只有满足条件的路由才会被引入。</p><h3 id="匹配工具1：访问控制列表"><a href="#匹配工具1：访问控制列表" class="headerlink" title="匹配工具1：访问控制列表"></a>匹配工具1：访问控制列表</h3><p>访问控制列表(Access Control List,ACL)是一个匹配工具，能够对报文及路由进行匹配和区分。</p><p><img src="/../../../../images/image-20240518084412880.png" alt="image-20240518084412880"></p><p><img src="/../../../../images/image-20240518084459974.png" alt="image-20240518084459974"></p><p>“ACL只能匹配路由的前缀，无法匹配路由的网络掩码。”是什么意思？</p><p>比如：</p><p>1.1.1.0&#x2F;24，1.1.2.0&#x2F;24，1.1.3.0&#x2F;24</p><p>acl 2000 permit source 1.1.2.0 0.0.0.255</p><p>能够匹配1.1.2.0&#x2F;24 ，匹配前缀以1.1.2开头的路由</p><p>1.1.2.8&#x2F;29，1.1.2.0&#x2F;30都能够匹配成功</p><h3 id="匹配工具2：IP前缀列表"><a href="#匹配工具2：IP前缀列表" class="headerlink" title="匹配工具2：IP前缀列表"></a>匹配工具2：IP前缀列表</h3><p>IP前缀列表(IP-Prefix List)是将路由条目的网络地址、掩码长度作为匹配条件的过滤器，可在各路由协议发布和接收路由时使用。<br><strong>不同于ACL，IP-Prefix List能够同时匹配IP地址前缀长度以及掩码长度，增强了匹配的精确度。</strong></p><p><img src="/../../../../images/image-20240518085138688.png" alt="image-20240518085138688"></p><p>1、ip-prefix-name:地址前缀列表名称</p><p>2、序号:本匹配项在地址前缀列表中的序号，匹配时根据序号从小到大进行顺序匹配</p><p>3、动作:permit&#x2F;deny，地址前缀列表的匹配模式为允许&#x2F;拒绝，表示匹配&#x2F;不匹配</p><p>4、IP网段与掩码:匹配路由的网络地址，以及限定网络地址的前多少位需严格匹配</p><p>5、掩码范围:匹配路由前缀长度，掩码长度的匹配范围 mask-length&lt;&#x3D;greater-equal-value&lt;&#x3D;less-equal-value&lt;&#x3D;32</p><p><strong>IP-Prefix的配置举例</strong></p><p><img src="/../../../../images/image-20240518085548219.png" alt="image-20240518085548219"></p><p><img src="/../../../../images/image-20240518085600222.png" alt="image-20240518085600222"></p><p><img src="/../../../../images/image-20240518085620385.png" alt="image-20240518085620385"></p><p><img src="/../../../../images/image-20240518085629918.png" alt="image-20240518085629918"></p><p><img src="/../../../../images/image-20240518085649289.png" alt="image-20240518085649289"></p><p><img src="/../../../../images/image-20240518085655946.png" alt="image-20240518085655946"></p><p>IP-Prefix一些特殊用法</p><p><img src="/../../../../images/image-20240518085731192.png" alt="image-20240518085731192"></p><h3 id="IP-Prefix和ACL的区别"><a href="#IP-Prefix和ACL的区别" class="headerlink" title="IP-Prefix和ACL的区别"></a>IP-Prefix和ACL的区别</h3><p><strong>(1)产生背景</strong><br>    ACL的产生最初目的是为了过滤数据包而诞生的。</p><p>​IP-Prefix的产生是用于精确匹配路由条目</p><p><strong>(2)实现功能</strong><br>    ACL既可以用来匹配路由，又可以用来过滤数据包。</p><p>​IP-Prefix只能用来匹配路由，不能用于过滤数据包</p><p><strong>(3)匹配路由精确度</strong><br>    ACL不能进行精确匹配路由，匹配路由时只能匹配路由的网络号但无法匹配掩码。</p><p>​地址前缀列表比ACL更灵活，可以精确匹配路由，对于前缀相同而掩码不同的路由可以精确匹配</p><h3 id="策略工具：Route-Policy"><a href="#策略工具：Route-Policy" class="headerlink" title="策略工具：Route-Policy"></a>策略工具：Route-Policy</h3><p>Route-Policy是一个策略工具，用于过滤路由信息，以及为过滤后的路由信息设置路由属性。</p><p>-个Route-Policy由一个或多个节点(Node)构成，每个节点都可以是一系列条件语句(匹配条件)以及执行语句(执行动作)的集合，这些集合按照编号从小到大的顺序排列。</p><p><img src="/../../../../images/image-20240518090624518.png" alt="image-20240518090624518"></p><h4 id="Route-Policy的组成"><a href="#Route-Policy的组成" class="headerlink" title="Route-Policy的组成"></a><strong>Route-Policy的组成</strong></h4><p>-个Route-Policy由一个或多个节点构成，每个节点包括多个if-match和apply子句。</p><p><img src="/../../../../images/image-20240518090731895.png" alt="image-20240518090731895"></p><p>路由策略使用不同的匹配条件和匹配模式选择路由和改变路由属性</p><p><img src="/../../../../images/image-20240518090823316.png" alt="image-20240518090823316"></p><h4 id="Route-Policy的基础命令"><a href="#Route-Policy的基础命令" class="headerlink" title="Route-Policy的基础命令"></a>Route-Policy的基础命令</h4><p><img src="/../../../../images/image-20240518091246301.png" alt="image-20240518091246301"></p><p><img src="/../../../../images/image-20240518091253264.png" alt="image-20240518091253264"></p><p><img src="/../../../../images/image-20240518091310301.png" alt="image-20240518091310301"></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="案例1：修改路由属性"><a href="#案例1：修改路由属性" class="headerlink" title="案例1：修改路由属性"></a>案例1：修改路由属性</h4><p><img src="/../../../../images/image-20240518091349398.png" alt="image-20240518091349398"></p><p>[R1] ip ip-prefix external index 10 permit 192.168.1.0 24</p><p>[R1]route-policy RP permit node 10<br>[R1-route-policy] if match ip prefix external<br>[R1-route-policy] apply cost-type type-1<br>[R1-route-policy] quit</p><p>[R1] ospf<br>[R1-ospf-1] import-route direct route-policy RP</p><ul><li><p><code>[R1]route-policy RP permit node 10</code>: 这条命令创建了一个名为“RP”的路由策略，节点标识为 10，该策略允许匹配此策略的路由。</p></li><li><p><code>[R1-route-policy] if match ip prefix external</code>: 在路由策略中，这行指定该策略将根据前面创建的名为“external”的 IP 前缀列表来匹配路由。</p></li><li><p><code>[R1-route-policy] apply cost-type type-1</code>: 这条命令为匹配策略的路由应用特定的 OSPF 成本类型（type-1）。</p></li><li><p><code>LK1] ospf</code>: 这条命令可能是进入设备的 OSPF 配置模式。</p></li><li><p><code>[R1-ospf-1]import-route direct route-policy RP</code>: 这条命令使用名为“RP”的路由策略将直连路由导入 OSPF 进程。这意味着只有匹配“RP”策略的路由才会被导入 OSPF。</p></li></ul><p><strong>回顾</strong></p><p>在 OSPF（开放最短路径优先）协议中，类型 1 和类型 2 的区别主要与外部路由（External Routes）的度量值（Metric Type）有关，这些度量值决定了路由的优先级和计算路径成本的方式。</p><ol><li><strong>类型 1 路由（Type 1 External Routes）：</strong><ul><li><strong>度量值累加（Metric Additive）：</strong> 类型 1 路由的总成本是外部路由的成本加上从当前路由器到达外部路由的内部 OSPF 路径成本。换句话说，OSPF 会把外部路径的成本和内部 OSPF 网络到达该路径的成本累加起来。</li><li><strong>应用场景：</strong> 适用于需要准确反映整个路径成本的场景，特别是在路径中不同链路的成本差异较大时。</li><li><strong>计算公式：</strong> 总成本 &#x3D; 内部路径成本 + 外部路径成本。</li></ul></li><li><strong>类型 2 路由（Type 2 External Routes）：</strong><ul><li><strong>度量值不累加（Metric Non-Additive）：</strong> 类型 2 路由的总成本仅为外部路由的成本，不包括从当前路由器到达外部路由的内部 OSPF 路径成本。OSPF 认为外部路径的成本已经足够高，因此不再增加内部 OSPF 路径的成本。</li><li><strong>应用场景：</strong> 适用于外部路径成本已经很高，并且可以忽略内部 OSPF 网络成本的场景，比如当外部路径的带宽或延迟远高于内部路径时。</li><li><strong>计算公式：</strong> 总成本 &#x3D; 外部路径成本。</li></ul></li></ol><p><strong>如何选择使用类型 1 或类型 2 路由</strong></p><p>选择使用类型 1 还是类型 2 取决于网络的设计和管理需求：</p><ul><li><strong>类型 1</strong>：适合需要精细控制路由选择的场景，特别是当你希望 OSPF 考虑到所有链路的成本（包括内部和外部）时。</li><li><strong>类型 2</strong>：适合简单和快速的路由选择场景，尤其是当外部路由的成本已经很高，内部网络的成本相对可以忽略不计时。</li></ul><h4 id="案例2：解决次优路径问题"><a href="#案例2：解决次优路径问题" class="headerlink" title="案例2：解决次优路径问题"></a>案例2：解决次优路径问题</h4><p><img src="/../../../../images/image-20240518092405179.png" alt="image-20240518092405179"></p><p>当10.1.1.0&#x2F;24引入OSPF里面，R2学到，R3,R4又学到；</p><p>1.10.1.0&#x2F;24是外部引入的，OSPF的AES是优先级是150，而IS-IS的优先级为15，当流量进来时，R3会选择R3-R4-R2-R1这条路由，而不是选择R4-R1，这样路由不是最优的。</p><p>解决方案:R3通过ACL匹配10,1.1.0&#x2F;24路由，在Route-Policy中调用该条ACL，将匹配这条ACL的路由的优先级设置为14(优于IS-IS)。在OSPF视图下使用preference ase命令调用Route-Policy修改外部路由的优先级。</p><p>在R3上执行以下操作:<br>[R3]acl 2000</p><p>[R3-acl-basic-2000] rule permit source 10.1.1.0 0</p><p>[R3-acl-basic-2000]quit</p><p>[R3]route-policy hcip permit node 10</p><p>[R3-route-policy]if-match acl 2000</p><p>[R3-route-policy] apply preference 14</p><p>[R3-route-policy] quit</p><p>[R3] ospf 1</p><p>[R3]ospf 1R3-ospf-1] preference ase route-policy hcip</p><h2 id="策略路由"><a href="#策略路由" class="headerlink" title="策略路由"></a>策略路由</h2><h3 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h3><p>现在有流量要去192.168.1.0&#x2F;24，根据路由表是走RTB这条链路，但是我又有特殊业务要求，先需要一部分流量走RTC这条链路，这时候需要PBR来做策略路由，使得一部分流量走RTC这条链路</p><p><img src="/../../../../images/image-20240518094819322.png" alt="image-20240518094819322"></p><p>PBR(Policy-Based Routing，策略路由):PBR使得网络设备不仅能够基于报文的目的IP地址进行数据转发，更能基于其他元素进行数据转发，例如源IP地址、源MAC地址、目的MAC地址、源端口号、目的端口号、VLAN-ID等等。</p><p>用户还可以使用ACL匹配特定的报文，然后针对该ACL进行PBR部署。<br>若设备部署了PBR，则被匹配的报文优先根据PBR的策略进行转发，即PBR策略的优先级高于传统路由表。</p><h4 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h4><p><img src="/../../../../images/image-20240518095208976.png" alt="image-20240518095208976"></p><h4 id="PBR的分类"><a href="#PBR的分类" class="headerlink" title="PBR的分类"></a>PBR的分类</h4><p>接口路由</p><p><img src="/../../../../images/image-20240518095349074.png" alt="image-20240518095349074"></p><p>本地PBR</p><p><img src="/../../../../images/image-20240518095405790.png" alt="image-20240518095405790"></p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p><img src="/../../../../images/image-20240518095645329.png" alt="image-20240518095645329"></p><p><img src="/../../../../images/image-20240518095652136.png" alt="image-20240518095652136"></p><p><strong>1. 创建 ACL 以匹配流量</strong></p><p><strong>ACL 3000：匹配网段 10.1.1.0&#x2F;24</strong></p><pre><code>plaintext复制代码[RTA] acl number 3000[RTA-acl-adv-3000] rule 10 permit ip source 10.1.1.0 0.0.0.255[RTA-acl-adv-3000] quit</code></pre><p><strong>ACL 3001：匹配网段 10.1.2.0&#x2F;24</strong></p><pre><code>plaintext复制代码[RTA] acl number 3001[RTA-acl-adv-3001] rule 10 permit ip source 10.1.2.0 0.0.0.255[RTA-acl-adv-3001] quit</code></pre><p><strong>2. 创建 PBR 策略</strong></p><p><strong>为网段1配置 PBR（ISP1：202.1.2.3）</strong></p><pre><code>plaintext复制代码[RTA] policy-based-route hcip permit node 10[RTA-policy-based-route-hcip-10] if-match acl 3000[RTA-policy-based-route-hcip-10] apply ip address next-hop 202.1.2.3[RTA-policy-based-route-hcip-10] quit</code></pre><p><strong>为网段2配置 PBR（ISP2：154.1.2.3）</strong></p><pre><code>plaintext复制代码[RTA] policy-based-route hcip permit node 20[RTA-policy-based-route-hcip-20] if-match acl 3001[RTA-policy-based-route-hcip-20] apply ip address next-hop 154.1.2.3[RTA-policy-based-route-hcip-20] quit</code></pre><p><strong>3. 在接口 GE0&#x2F;1&#x2F;0 上应用 PBR</strong></p><pre><code>plaintext复制代码[RTA] interface GigabitEthernet 0/1/0[RTA-GigabitEthernet0/1/0] ip policy-based-route hcip[RTA-GigabitEthernet0/1/0] quit</code></pre><h3 id="MQC"><a href="#MQC" class="headerlink" title="MQC"></a>MQC</h3><p>MQC(Modular QoS Command-Line Interface，模块化QoS命令行)是指通过将具有某类共同特征的数据流划分为一类，并为同一类数据流提供相同的服务，也可以对不同类的数据流提供不同的服务。</p><p>MQC包含三个要素:流分类(traffic classifier)、流行为(traffic behavior)和流策略(traffic policy)。</p><p>MQC的流行为支持重定向报文，因此可以使用MQC实现IP单播策略路由。</p><p><img src="/../../../../images/image-20240518101329608.png" alt="image-20240518101329608"></p><p><strong>流策略</strong></p><p>流策略:将流分类和流行为绑定，对分类后的报文执行对应流行为中定义的动作。<br>一个流策略可以绑定多个流分类和流行为。</p><p><img src="/../../../../images/image-20240518101425009.png" alt="image-20240518101425009"></p><p><strong>流分类</strong></p><p>流分类:定义一组流量匹配规则，以对报文进行分类。流分类支持的匹配项如下所示。</p><p><img src="/../../../../images/image-20240518101530560.png" alt="image-20240518101530560"></p><p><strong>流策略</strong></p><p>流策略:流策略支持在接口上调用。</p><p>流策略存在方向(inbound、outbound)的概念，策略中的流行为匹配入、出方向的报文对匹配中的报文执行相应的流动作。</p><p><img src="/../../../../images/image-20240518101950375.png" alt="image-20240518101950375"></p><h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><p>1、创建流分类<br>[Huawei] traffic classifier classifer-name [ operator { and | or } ]<br>缺省情况下，流分类中各规则之间的关系为“或”(or)。流分类中的匹配规则配置可查阅产品手册</p><p>2、创建流行为<br>[Huawei] traffic behavior behavior-name<br>根据实际情况定义流行为中的动作，只要各动作不冲突，都可以在同一流行为中配置。流行为具体配置可查阅产品手册。</p><p>3、创建流策略，并绑定流分类与流行为3.<br>[Huawei] traffic policy policy-name </p><p>[Huawei-trafficpolicy-policyname] classifier classifier-name behavior behavior-name</p><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><h4 id="案例1：MQC实现策略路由"><a href="#案例1：MQC实现策略路由" class="headerlink" title="案例1：MQC实现策略路由"></a>案例1：MQC实现策略路由</h4><p><img src="/../../../../images/image-20240518102630070.png" alt="image-20240518102630070"></p><p><img src="/../../../../images/image-20240518102635280.png" alt="image-20240518102635280"></p><p><img src="/../../../../images/image-20240518102651643.png" alt="image-20240518102651643"></p><p><img src="/../../../../images/image-20240518102705707.png" alt="image-20240518102705707"></p><h4 id="案例2：MQC过滤流量"><a href="#案例2：MQC过滤流量" class="headerlink" title="案例2：MQC过滤流量"></a>案例2：MQC过滤流量</h4><p><img src="/../../../../images/image-20240518103010306.png" alt="image-20240518103010306"></p><p><img src="/../../../../images/image-20240518103024548.png" alt="image-20240518103024548"></p><p><img src="/../../../../images/image-20240518103037066.png" alt="image-20240518103037066"></p><p>为充分利用两个运营商的带宽，请提供至少4种多出口链路负载策略。</p><p><img src="/../../../../images/image-20240518103204465.png" alt="image-20240518103204465"></p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为设备登录配置</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E5%8D%8E%E4%B8%BA%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E5%8D%8E%E4%B8%BA%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="华为设备配置"><a href="#华为设备配置" class="headerlink" title="华为设备配置"></a>华为设备配置</h2><p><strong>system-view</strong> &#x2F;&#x2F;进入系统模式<br><strong>sysname</strong> xxx &#x2F;&#x2F;设备重命名<br>telnet server enable **&#x2F;&#x2F;开启设备telnet功能<br>user-interface vty 0 4 &#x2F;&#x2F;开启登录端口0-4<br>protocol inbound telnet  &#x2F;&#x2F;通过telnet协议登录<br>authentication-mode <strong>aaa</strong>  &#x2F;&#x2F;认证方式aaa</p><p>aaa  &#x2F;&#x2F;启动aaa</p><p>local-user admin123 password admin123  &#x2F;&#x2F;配置用户名密码</p><p>local-user admin123 service-type <strong>telnet</strong> &#x2F;&#x2F;用户用于telnet</p><p>local-user admin123 privilege level 15 &#x2F;&#x2F;用户等级为15</p><p><strong>quit</strong>  </p><h2 id="VLAN与VLANIF地址配置"><a href="#VLAN与VLANIF地址配置" class="headerlink" title="VLAN与VLANIF地址配置"></a>VLAN与VLANIF地址配置</h2><p>VLAN 和 VLANIF 有什么区别？</p><p>VLAN 是在二层交换机配置的，在交换机中的端口划分为逻辑上的多个虚拟网络</p><p>VLANIF 是在三层交换机或路由器配置的，VLANIF是用于不同VLAN之间的通信，一般在VLANIF配置IP，作为VLAN的网关地址</p><p><img src="/../../../../images/image-20240427104856251.png" alt="image-20240427104856251"></p><pre><code>完整命令：LSW1system-viewvlan batch 10 20int g0/0/2port link-type access //把交换机接口模式设置为accessport default vlan 10 //把接口划入vlan10int g0/0/3port link-type accessport default vlan 20int g0/0/1port link-type trunkport trunk allow-pass vlan 10 20LSW2vlan batch 10 20int vlanif 10    //进入三层vlanif接口ip address 172.25.250.1 24  //要与PC机的网关一致int vlanif 20ip address 172.26.250.1 24int g0/0/1port link-type trunkport turnk allow-pass vlan 10 20</code></pre><h2 id="DHCP配置命令"><a href="#DHCP配置命令" class="headerlink" title="DHCP配置命令"></a>DHCP配置命令</h2><p>DHCP工作原理</p><p><img src="/../../../../images/image-20240427142145631.png" alt="image-20240427142145631"></p><p>DHCP租期更新</p><p><img src="/../../../../images/image-20240427142225375.png" alt="image-20240427142225375"></p><p><strong>基于接口地址池的DHCP配置</strong></p><p><img src="/../../../../images/image-20240427140743295.png" alt="image-20240427140743295"></p><p>dhcp enable  &#x2F;&#x2F;开启DHCP功能</p><p>int g0&#x2F;0&#x2F;0  </p><p>dhcp select interface  &#x2F;&#x2F;采用接口地址池的DHCP服务器端功能</p><p>dhcp server dns-list 10.1.1.2  &#x2F;&#x2F;指定接口地址池下的DNS服务器地址</p><p>dhcp server excluded-ip-address 10.1.1.2 &#x2F;&#x2F;配置接口池中不参与自动分配的IP地址范围</p><p>dhcp server lease day 3 &#x2F;&#x2F;接口地址池中IP地址的租用有效期</p><p>#注意每个接口的地址池可以网段，但一般是不同网段，容易IP冲突</p><p><strong>基于全局地址池的DHCP配置</strong></p><p><img src="/../../../../images/image-20240427141207127.png" alt="image-20240427141207127"></p><p>dhcp enable  </p><p>ip pool pool2 &#x2F;&#x2F;创建全局地址池名字为pool2</p><p>network 1.1.1.0 mask 24 &#x2F;&#x2F;设置IP地址范围</p><p>gateway-list 1.1.1.1 &#x2F;&#x2F;配置DHCP客户端的网关地址</p><p>dns-list 1.1.1.1 &#x2F;&#x2F;配置DHCP客户端的DNS服务器的IP地址</p><p>lease day 10  &#x2F;&#x2F; IP地址租期</p><p>int g0&#x2F;0&#x2F;0</p><p>dhcp select global  &#x2F;&#x2F;使能让接口DHCP服务器的功能</p><p>#最后在具体的接口中配置选择全局地址池。当GE0&#x2F;0&#x2F;0收到DHCP请求就会从全局地址池中进行IP地址分配。</p><hr><p><strong>DHCP-VLAN配置</strong></p><p><img src="/../../../../images/image-20240427151144856.png" alt="image-20240427151144856"></p><p>interface GigabitEthernet0&#x2F;0&#x2F;1<br> port link-type access<br> port default vlan 10</p><p>interface GigabitEthernet0&#x2F;0&#x2F;2<br> port link-type access<br> port default vlan 20</p><p>dhcp enable</p><p>interface Vlanif10<br> ip address 172.25.250.254 255.255.255.0<br> dhcp select interface<br> dhcp server excluded-ip-address 172.25.250.120 172.25.250.253<br> dhcp server lease day 3 hour 0 minute 0<br> dhcp server dns-list 8.8.8.8</p><p>interface Vlanif20<br> ip address 172.26.250.254 255.255.255.0<br> dhcp select global</p><p>[Huawei]ip pool pool2<br>[Huawei-ip-pool-pool2]network 172.26.250.0 mask 24<br>[Huawei-ip-pool-pool2]gateway-list 172.26.250.254<br>[Huawei-ip-pool-pool2]dns-list 8.8.8.8<br>[Huawei-ip-pool-pool2]lease day 10</p><h2 id="dhcp-relay-dhcp中继"><a href="#dhcp-relay-dhcp中继" class="headerlink" title="dhcp-relay(dhcp中继)"></a>dhcp-relay(dhcp中继)</h2><p>dhcp-relay(dhcp中继)的作用场景：dhcp客户端和dhcp服务器之间有很多设备，想要发送dhcp广播，中间有路由器，路由器能够隔离广播，所以发不了到dhcp服务器，所以需要dhcp-relay能够把dhcp广播转换会单播发给dhcp服务器</p><p>通俗地说，就是把dhcp广播转换为单播，从而发给dhcp服务器</p><p><img src="/../../../../images/image-20240427174409154.png" alt="image-20240427174409154"></p><p>R1</p><p><img src="/../../../../images/image-20240427174631228.png" alt="image-20240427174631228"></p><p>注意：只有一个DHCP服务器，选择DHCP relay server-ip</p><p>多个DHCP服务器，选择DHCP relay server-select </p><p>R2</p><p><img src="/../../../../images/image-20240427174700578.png" alt="image-20240427174700578"></p><h2 id="DHCP-Snooping"><a href="#DHCP-Snooping" class="headerlink" title="DHCP Snooping"></a>DHCP Snooping</h2><p>为什么需要DHCP snooping？</p><p>现实当中，除了有安全的DHCP服务器，可能还有”流氓”的DHCP服务器，当PC发送dhcp广播时，有可能”流氓”的DHCP服务器先收到，然后她给你先响应，对你的电脑造成影响。</p><p>如果配置了DHCP snooping，尽管”流氓”服务器她先响应，但是她不是trusted区域，响应包发给她，就被丢弃，根本到不了PC。</p><p>防止网络中非法DHCP服务器分配IP地址，从而有效防范DHCP攻击</p><p><img src="/../../../../images/image-20240427164919233.png" alt="image-20240427164919233"></p><p>R1</p><p><img src="/../../../../images/image-20240427175053356.png" alt="image-20240427175053356"></p><h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><h3 id="ACL原理"><a href="#ACL原理" class="headerlink" title="ACL原理"></a>ACL原理</h3><p><strong>作用：实现流量过滤</strong></p><p>ACL是由一系列permit或deny语句组成的，有序规则的列表。</p><p><img src="/../../../../images/image-20240427232056629.png" alt="image-20240427232056629"></p><p>每一条语句就说该ACL的一条规则。ACL则是规则的集合</p><hr><p>子网掩码：用来区分主机位和网络位</p><p>通配符掩码：ACL中使用。用来标识或检查IP地址的位，里面的0或1可以不是连续的</p><p>例如： source 1.1.1.0  0.0.0.255</p><p>0表示要检查，255表示任意</p><p>反掩码：OSPF中使用。里面的0和1必须是连续的</p><hr><p><strong>通配符</strong></p><p>通配符是一个32比特长度的数值，用于指示IP地址中哪些比特位需要严格匹配，哪些比特位无需匹配。</p><p>通配符通常采用类似网络掩码的点分十进制形式表示，但是含义却与网络掩码完全不同。</p><p>通配符中的1或者0可以不连续</p><p><img src="/../../../../images/image-20240427181827873.png" alt="image-20240427181827873"></p><p>匹配规则：   <strong>“0” 表示 “严格匹配”    “1” 表示 “任意”</strong></p><p>上图中：</p><p>rule 5中 匹配对象是：10.1.1.1</p><p>rule10中 匹配对象是：10.1.1.2</p><p>rule 15中 匹配对象是：10.1.1.0网段</p><p>如何匹配192.168.1.1&#x2F;24对应网段的地址?</p><p><img src="/../../../../images/image-20240427182324210.png" alt="image-20240427182324210"></p><p>如果匹配192.168.1.0网段的奇数地址或者偶数地址呢，该怎么写？</p><p>奇数：192.168.1.10.0.0.254</p><p>偶数：192.168.1.00.0.0.254</p><p><strong>分析：</strong></p><p>“0” 表示 “严格匹配”    “1” 表示 “任意”</p><p>那么通配符：</p><p>通配符：0.0.0.2540.0.0.11111110</p><p>IP地址：192.168.1.1  192.168.1.00000001</p><p>00000001，1~7位对应的通配符是1， “1” 表示 “任意”。</p><p>而最后一位”1”，对应的通配符是0，”0” 表示 “严格匹配”  </p><p>那好，为啥是奇数呢？</p><p>因为二进制转换成十进制，都是2^0+2^1+…</p><p>所以，只要最后一位是奇数，那么整个就是奇数</p><p>偶数同理。</p><h3 id="ACL分类"><a href="#ACL分类" class="headerlink" title="ACL分类"></a>ACL分类</h3><p>基于ACL规则定义方式的分类</p><p><img src="/../../../../images/image-20240427232410688.png" alt="image-20240427232410688"></p><p>基于ACL标识方法的分类</p><p><img src="/../../../../images/image-20240427232427994.png" alt="image-20240427232427994"></p><p><strong>基本ACL和高级ACL</strong></p><p><img src="/../../../../images/image-20240427232508478.png" alt="image-20240427232508478"></p><p><img src="/../../../../images/image-20240427232522098.png" alt="image-20240427232522098"></p><p>ACL的匹配顺序及匹配结果</p><p><strong>配置顺序(config模式)</strong></p><p>​系统按照ACL规则编号从小到大的顺序进行报文匹配，规则编号越小越容易被匹配</p><p><img src="/../../../../images/image-20240427232714333.png" alt="image-20240427232714333"></p><p>auto模式</p><p>它会根据颗粒度，自动调整规则顺序</p><p>例如：</p><p>acl 2000 match-order auto</p><p>rule permit source any</p><p>rule permit source 192.168.1.1 0.0.0.255</p><p>#她会自动调整顺序，不然这个没有啥意义</p><h3 id="ACL配置"><a href="#ACL配置" class="headerlink" title="ACL配置"></a>ACL配置</h3><p>基础ACL</p><p><img src="/../../../../images/image-20240427234341048.png" alt="image-20240427234341048"></p><p><img src="/../../../../images/image-20240427234359050.png" alt="image-20240427234359050"></p><p>高级ACL</p><p><img src="/../../../../images/image-20240427234445236.png" alt="image-20240427234445236"></p><p><img src="/../../../../images/image-20240427234452380.png" alt="image-20240427234452380"></p><p><img src="/../../../../images/image-20240427234511735.png" alt="image-20240427234511735"></p><h2 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a>NAT网络地址转换</h2><p>产生原因：IP地址不够用。</p><p>意义：能够有效节约IPv4地址</p><p>NAT：是对IP数据报文中的IP地址在进行转换，一般部署在网络出口设备，例如路由器或防火墙上。</p><h3 id="静态NAT"><a href="#静态NAT" class="headerlink" title="静态NAT"></a>静态NAT</h3><p>私有地址和公有地址进行一对一的映射。</p><p>支持双向互访: 私有地址访问Internet经过出口设备NAT转换时，会被转换成对应的公有地址。</p><p>同时，外部网络访问内部网络时，其报文中携带的公有地址(目的地址)也会被NAT设备转换成对应的私有地址。</p><p><img src="/../../../../images/image-20240429155947027.png" alt="image-20240429155947027"></p><p><strong>配置</strong></p><p>1.方式一:接口视图下配置静态NAT<br>[Huawei-GigabitEthernet0&#x2F;0&#x2F;0] </p><p><strong>nat static global</strong> {global-address} <strong>inside</strong> {host-address )</p><p>global参数用于配置外部公有地址，inside参数用于配置内部私有地址。</p><p>2:方式二:系统视图下配置静态NAT<br>[Huawei] </p><p>**nat static global **{global-address}<strong>inside</strong> {host-address }</p><p>配置命令相同，视图为系统视图，之后在具体的接口下开启静态NAT。</p><p>[Huawei-GigabitEthernet0&#x2F;0&#x2F;0] <strong>nat static enable</strong></p><p>在接口下使能nat static功能。</p><p><strong>示例</strong></p><p><img src="/../../../../images/image-20240429160342215.png" alt="image-20240429160342215"></p><pre><code>[R1]interface GigabitEthernet0/0/1[R1-GigabitEthernet0/0/1]ip address 122.1.2.1 24[R1-GigabitEthernet0/0/1]nat static global 122.1.2.1 inside 192.168.1.1[R1-GigabitEthernet0/0/1]nat static global 122.1.2.2 inside 192.168.1.2[R1-GigabitEthernet0/0/1]nat static global 122.1.2.3 inside 192.168.1.3</code></pre><h3 id="动态NAT"><a href="#动态NAT" class="headerlink" title="动态NAT"></a>动态NAT</h3><p>出现的原因：因为静态NAT也是一对一的映射，但内网主机长时间离线或不发数据时，也占用公有地址。</p><p>意义：避免了地址浪费，把公有地址组成地址池</p><p>特点：</p><p>当内部主机访问外部网络时临时分配一个地址池中未使用的地址，并将该地址标记为“In Use”。当该主机不再访问外部网络时回收分配的地址，重新标记为“Not Use”</p><p><strong>示例(出去流量)</strong></p><p><img src="/../../../../images/image-20240429160635691.png" alt="image-20240429160635691"></p><p><strong>示例(回程流量)</strong></p><p><img src="/../../../../images/image-20240429162629336.png" alt="image-20240429162629336"></p><p><strong>示例</strong></p><p><img src="/../../../../images/image-20240429171310748.png" alt="image-20240429171310748"></p><p>R1</p><p>nat address-group 1 122.1.2.1 122.1.2.3  #设置公网地址池</p><p>acl 2000  #配置acl规则</p><p>rule 5 permit source 192.168.1.0 0.0.0.255</p><p>quit</p><p>int g0&#x2F;0&#x2F;1</p><p><strong>nat outbound 2000 address-group 1 no-pat</strong>  </p><p>#no-pat是指非端口地址转换，No-Port Address Translation</p><h3 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h3><p>出现的原因：因为动态NAT的地址池中的地址进行地址转换时不会转换端口号，公有地址和私有地址还是1：1的映射关系，<strong>无法提高公有地址利用率</strong>。</p><p>NAPT(Network Address and Port Translation, 网络地址端口转换)</p><p>解决问题：能够实现公有地址与私有地址的1：n映射，可以有效提高公有地址利用率。</p><p>NAPT转换(出去流量)</p><p><img src="/../../../../images/image-20240429172734964.png" alt="image-20240429172734964"></p><p>NAPT转换(回城流量)</p><p><img src="/../../../../images/image-20240429172745756.png" alt="image-20240429172745756"></p><p><strong>注意icmp是属于二层，但是napt会给她icmp包给一个伪端口</strong></p><p>示例配置：</p><p><img src="/../../../../images/image-20240429172808863.png" alt="image-20240429172808863"></p><p>在R1上配置NAPT让内网所有私有地址通过122.1.2.1访问公网。</p><p>nat address-group 1 122.1.2.1 122.1.2.1 #起始地址和结束地址一样，则指一个地址</p><p>acl 2000</p><p>rule 5 permit source 192.168.1.0 0.0.0.255</p><p>quit</p><p>int g0&#x2F;0&#x2F;1</p><p><strong>nat outbound 2000 address-group 1</strong></p><h3 id="Easy-IP"><a href="#Easy-IP" class="headerlink" title="Easy IP"></a>Easy IP</h3><p>出现的原因：因为我们公有地址经常会变化，而且有可能我们不知道公网地址是多少，但只知道网络出口的接口，那么Easy IP则可以实现NAT转换。</p><p>Easy IP的实现原理跟NAPT相同，同时转换IP地址和传输层端口。</p><p>区别：Easy IP没有地址池的概念，<strong>是使用接口地址作为NAT转换的公有地址</strong></p><p>适用的场景：<strong>适用于不具备固定公网IP地址的场景。</strong>如通过DHCP、PPPOE拨号获取地址的私有网络出口。</p><p>示例：</p><p><img src="/../../../../images/image-20240429173632161.png" alt="image-20240429173632161"></p><p>在R1上配置Easy-IP让内网所有私有地址通过122.1.2.1访问公网</p><p>acl 2000</p><p>rule 5 permit source 192.168.1.0 0.0.0.255</p><p>quit </p><p>int g 0&#x2F;0&#x2F;1</p><p><strong>nat outbound 2000</strong></p><h3 id="NAT-Server"><a href="#NAT-Server" class="headerlink" title="NAT Server"></a>NAT Server</h3><p>作用：<strong>让内网服务器映射到公网</strong>，当私有网络中的服务需要对公网提供服务时使用。</p><p>外网主机主动访问[公有地址:端口]实现对内网服务器的访问。</p><p><img src="/../../../../images/image-20240429173954054.png" alt="image-20240429173954054"></p><p>示例：</p><p><img src="/../../../../images/image-20240429174018228.png" alt="image-20240429174018228"></p><p>在R1上配置NAT Server将内网服务器192.168.1,10的80端口映射到公有地址122.1.2.1的8080端口</p><p>int g0&#x2F;0&#x2F;1</p><p>ip address 122.1.2.1 24</p><p><strong>nat server protocol  tcp global 202.10.10.1 www inside 192.168.1.1 8080</strong></p><h3 id="NAT示例集合"><a href="#NAT示例集合" class="headerlink" title="NAT示例集合"></a>NAT示例集合</h3><p><img src="/../../../../images/image-20240429174318906.png" alt="image-20240429174318906"></p><pre><code>静态配置：AR1方法1：接口配置int g0/0/1nat static global 12.1.1.2 inside 192.168.1.1方法2：全局配置nat static global 12.1.1.2 inside 192.168.1.1int g0/0/1nat static enable--------------动态配置：AR1nat address-group 1 12.1.1.2 12.1.1.10acl 2000rule 5 permit source 192.168.1.0 0.0.0.255quit int g0/0/1nat outbound 2000 address-group 1 no-pat-------------NAPT配置：AR1nat address group 1 12.1.1.2 12.1.1.10acl 2000rule 5 permit source 192.168.1.0 0.0.0.255quitint g0/0/1nat outbound 2000 address-group 1----------------------Easy IP配置(端口上配置)：AR1nat outbound 2000---------------------NAT Server：AR1int g0/0/1nat server tcp global 12.1.1.2 80 inside 192.168.1.2 80</code></pre><h2 id="VRRP"><a href="#VRRP" class="headerlink" title="VRRP"></a>VRRP</h2><p><strong>解决问题：单点故障</strong></p><p>实现：把几台路由设备联合组成一台虚拟的”路由设备”，使用一定的机制保证当主机的下一跳舍友设备出现故障时，能够将业务进行切换到备份路由设备，从而保持通讯的连续性和可靠性。</p><p><strong>这里的切换设备的时间，可以提高，BFD+VRRP能够实现毫秒级别的切换</strong></p><p>为什么能够实现切换？</p><p>实现的实质是；降低设备的优先级，使得备份设备的优先级大于主设备，则实现切换。</p><p><img src="/../../../../images/image-20240429174914401.png" alt="image-20240429174914401"></p><p>这里的”Virtual IP”的作用是什么？</p><p>可以理解为：为这台虚拟的”路由设备”的IP地址，是PC对外提供服务的入口地址，此时PC的网关是VIrtual IP。</p><p>VRRP常用配置命令：</p><p>1.创建VRRP备份组并给备份组配置虚拟IP地址</p><pre><code>[interface-GigabitEthernet0/0/0] vrrp vrid virtual-router-id virtual-ip virtual-address</code></pre><p>注意:各备份组之间的虚拟IP地址不能重复;同属一个备份组的设备接口需使用相同的VRID。</p><p>2.配置路由器在备份组中的优先级</p><pre><code>[interface-GigabitEthernet0/0/0] vrrp vrid virtual-router-id priority priority-value</code></pre><p>注意:通常情况下，Master设备的优先级应高于Backup设备。</p><p>3.配置备份组中设备的抢占延迟时间</p><pre><code>[interface-GigabitEthernet0/0/0] vrrp vrid virtual-router-id preempt-mode timer delay delay-value</code></pre><p>4.配置VRRP备份组中设备采用非抢占模式</p><pre><code>[interface-GigabitEthernet0/0/0] vrrp vrid virtual-router-id preempt-mode disable</code></pre><p>缺省情况下，抢占模式已被激活。</p><p>5.配置VRRP备份组监视接口</p><pre><code>[interface-GieabitEthernet0/0/0] vrrp vrid virtual-router-id track interface interface-type interface-number [ increased value.increasedlreduced value-decreased]</code></pre><p>可配置设备当检测到上行接口或链路出现故障时，增加或者减少自身优先级，IP地址拥有者和Eth-trunk成员口不允许配置VRRP监视功能。</p><p>6.配置VRRP备份组联动普通BFD会话</p><pre><code>[interface-GigabitEthernet0/0/0] vrp vrid virtual-router-id track bfd-session &#123; bfd-session-id | session-name bfd-configurename &#125;[increased value-increasedl reduced value-reduced]</code></pre><p>如果选择参数session-name bfd-configure-name，可以绑定静态BFD会话或者标识符自协商的静态BFD会话如果选择参数bfd-session-id，只能绑定静态BFD会话。</p><p>基础配置：</p><p><img src="/../../../../images/image-20240429181849985.png" alt="image-20240429181849985"></p><p><img src="/../../../../images/image-20240429181859238.png" alt="image-20240429181859238"></p><p>验证：display vrrp</p><p><img src="/../../../../images/image-20240429181923560.png" alt="image-20240429181923560"></p><h2 id="综合实验"><a href="#综合实验" class="headerlink" title="综合实验"></a>综合实验</h2><h3 id="ospf-nat-默认路由"><a href="#ospf-nat-默认路由" class="headerlink" title="ospf-nat-默认路由"></a>ospf-nat-默认路由</h3><p><img src="/../../../../images/image-20240506173838552.png" alt="image-20240506173838552"></p><pre><code>1、接口配置Routerint g0/0/0ip add 192.168.10.254 24int g0/0/1ip add 192.168.20.254 24int g0/0/2ip add 12.1.1.1 30int g4/0/0ip add 13.1.1.1 30Router电信int Loopback 0  //环回接口ip add 1.1.1.1 32  int g0/0/0ip add 12.1.1.2 30int g0/0/1ip add 100.1.1.1 30Router联通int Loopback 0 //环回接口ip add 2.2.2.2 32int g0/0/0ip add 13.1.1.2 30int g0/0/1ip add 200.1.1.1 30Router互联网int Loopback 0 //环回接口ip add 22.22.22.22 32int g0/0/0ip add 100.1.1.2 30intg 0/0/1ip add 200.1.1.2 302、配置OSPFRouter电信ospf 1area 0network 0.0.0.0 0.0.0.0Router联通ospf 1area 0network 0.0.0.0 0.0.0.0Router互联网ospf 1area 0network 0.0.0.0 0.0.0.0//此时  互相能够获得邻居的路由//验证命令：display ospf peer briefdisplay ip routing-table3、配置NAT(easy-ip)Routeracl 2000rule 10 permit source 192.168.10.0 0.0.0.255rule 20 permit source 192.168.20.0 0.0.0.255int g0/0/2nat outbound 2000int g4/0/0nat outbound 20004、配置默认路由Routerip route-static 0.0.0.0 0 12.1.1.2ip route-static 0.0.0.0 0 13.1.1.2</code></pre><h2 id="IPSec-VPN"><a href="#IPSec-VPN" class="headerlink" title="IPSec VPN"></a>IPSec VPN</h2><p>打通隧道，实现，私有地址&#x2F;公有地址的通信</p><p>私有地址建议使用：隧道模式</p><p>公有地址建议使用：传输模式(速度快)</p><p>两种模式：手工模式、IKE模式(自动设置密钥、ISP值等)</p><p>注意：IKE模式还需要配置IKE提议、IKE对等体</p><p>工作一般流程：</p><p>1、设置acl</p><p>2、配置IPSec安全提议</p><p>3、创建IPSec安全策略(把acl和安全提议进行绑定)</p><p>4、在接口调用安全策略</p><p>什么是IPSec安全提议？</p><p>它描述了两个IPSec对等体之间进行安全通信所需的安全设置和协议选项。</p><ol><li><strong>安全通信</strong>：通过指定加密算法和认证算法，IPSec安全提议确保IP数据包在传输过程中得到加密保护，防止未经授权的访问者读取或修改数据。</li><li><strong>身份验证</strong>：通过认证算法，IPSec安全提议确保通信双方的身份得到验证，防止恶意主体冒充合法的通信节点。</li><li><strong>完整性保护</strong>：通过指定完整性保护机制，IPSec安全提议确保传输的数据包在传输过程中没有被篡改，从而保障数据的完整性。</li><li><strong>密钥协商</strong>：通过指定密钥交换协议，IPSec安全提议允许通信双方协商并建立共享的密钥，以用于加密和解密IP数据包。</li><li><strong>安全协议选择</strong>：通过指定安全协议，如ESP或AH，IPSec安全提议确定用于提供机密性和完整性的具体协议。</li></ol><p><img src="/../../../../images/image-20240508230953321.png" alt="image-20240508230953321"></p><p>拓扑实验：</p><p><img src="/../../../../images/image-20240508231422680.png" alt="image-20240508231422680"></p><p>实验需求<br>1、成都和北京两个站点用户均可以访问互联网2.2.2.22、配置手动IPSECVPN，实现成都和北京两个站点内网数据互通，且数据加密3、配置自动 IPSEC VPN，实现成都和北京两个站点内网数据互通，且数据加密<br>三、实验步骤及配置<br>整体步骤:<br>1、配置IP地址，ISP路由器用100模拟互联网<br>2、成都和北京两个出口路由器配置默认路由指向ISP路由器3、进行 IPSEC VPN配置，让两个站点内网互通，同时数据加密。静态IPSEC配置步骤如下，一共分为四步:</p><h3 id="手工模式"><a href="#手工模式" class="headerlink" title="手工模式"></a>手工模式</h3><p>基础配置：</p><p>R1</p><p>int g0&#x2F;0&#x2F;0</p><p>ip add 192.168.10.254 24</p><p>int g0&#x2F;0&#x2F;1</p><p>ip add 100.1.1.1 30</p><p>ISP</p><p>int g0&#x2F;0&#x2F;0</p><p>ip add 100.1.1.2 30</p><p>int g0&#x2F;0&#x2F;1</p><p>ip add 200.1.1.2 30</p><p>R2</p><p>int 0&#x2F;0&#x2F;0</p><p>ip add 192.168.20.254 24</p><p>int 0&#x2F;0&#x2F;1</p><p>ip add 200.1.1.1 30</p><p>先打通双方能够访问ISP</p><p>R1</p><p>ip route-static 0.0.0.0 0 100.1.1.2</p><p>acl 2000</p><p>rule 10  permit source 192.168.10.0 0.0.0.255</p><p>int g0&#x2F;0&#x2F;1</p><p>nat outbound 2000</p><p>R2</p><p>ip route-static 0.0.0.0 0 200.1.1.2</p><p>acl 2000</p><p>rule 10 permit source 192.168.20.0 0.0.0.255</p><p>int g0&#x2F;0&#x2F;1</p><p>nat outbound 2000</p><p>IPSec VPN配置(两个站点通信，同时数据加密)</p><pre><code>R1第一步:匹配感兴趣的流量[R1]ac13000 //配置ACL3000[R1-acl-adv-3000]rule 10 permit ip source 192.168.10.0 0.0.0.255 destination 192.168.20.00.0.0.255  //规则10，匹配源为192.168.10.0/24，目的192.168.20.0/24的流量第二步:配置ipsec 提议[R1]ipsec proposal cd //ipsec 提议名称 cd[R1-ipsec-proposal-cd]esp authentication-algorithm sha2-256 //认证算法采用sha2-256[R1-ipsec-proposal-cd]esp encryption-algorithm aes-128 //加密算法采用aes-128第三步:配置ipsec 手动方式安全策略[R1]ipsec policy chengdu 10 manual//配置IPSEC策略 chegndu，方式为手动[Rl-ipsec-policy-manual-chengdu-10]security acl 3000 //包含acl3000的流量[R1-ipsec-policy-manual-chengdu-10] proposal cd//采用ipsec 提议 cd[R1-ipsec-policy-manual-chengdu-10]tunnel local 100.1.1.1 //配置隧道本地地址 100.1. 1.1[R1-ipsec-policy-manual-chengdu-10]tunnel remote 200.1.1.1 //配置隧道远端地址 200.1.1.1[R1-ipsec-policy-manual-chengdu-10]sa spi inbound esp 12345 //配置入方向SA编号12345[Rl-ipsec-policy-manual-chengdu-10]sa string-key inbound esp cipher hahaha //配置入方向SA的认证密钥为hahaha[Rl-ipsec-policy-manual-chengdu-10]sa spi outbound esp 56789 //配置出方向SA编号56789[R1-ipsec-policy-manual-chengdu-10]sa string-key outbound esp cipher xixixi //配置出方向SA 的认证密钥为xixixi第四步:在接口上应用ipsec策略[R1] interface GigabitEthernet0/0/1[R1-GigabitEthernet0/0/1] ipsec policy chengdu//接口上应用ipsce 策略(只能用于出接口)</code></pre><pre><code>R2第一步:匹配感兴趣的流量[R2]ac13000 //配置ACL3000[R2-acl-adv-3000]rule 10 permit ip source 192.168.20.0 0.0.0.255 destination 192.168.10.00.0.0.255  //规则10，匹配源为192.168.20.0/24，目的192.168.10.0/24的流量第二步:配置ipsec 提议[R2]ipsec proposal bj //ipsec 提议名称 cd[R2-ipsec-proposal-bj]esp authentication-algorithm sha2-256 //认证算法采用sha2-256[R2-ipsec-proposal-bj]esp encryption-algorithm aes-128 //加密算法采用aes-128第三步:配置ipsec 手动方式安全策略[R2]ipsec policy beijing 10 manual//配置IPSEC策略 chegndu，方式为手动[R2-ipsec-policy-manual-beijing-10]security acl 3000 //包含acl3000的流量[R2-ipsec-policy-manual-beijing-10] proposal bj//采用ipsec 提议 bj[R2-ipsec-policy-manual-beijing-10]tunnel local 200.1.1.1 //配置隧道本地地址 200.1. 1.1[R2-ipsec-policy-manual-beijing-10]tunnel remote 100.1.1.1 //配置隧道远端地址 100.1.1.1[R2-ipsec-policy-manual-beijing-10]sa spi inbound esp 56789 //配置入方向SA编号56789[R2-ipsec-policy-manual-beijing-10]sa string-key inbound esp cipher xixixi //配置入方向SA的认证密钥为xixixi[R2-ipsec-policy-manual-beijing-10]sa spi outbound esp 12345 //配置出方向SA编号12345[R2-ipsec-policy-manual-beijing-10]sa string-key outbound esp cipher hahaha //配置出方向SA 的认证密钥为hahaha第四步:在接口上应用ipsec策略[R2] interface GigabitEthernet0/0/1[R2-GigabitEthernet0/0/1] ipsec policy beijing//接口上应用ipsce 策略(只能用于出接口)</code></pre><hr><p>此时是不通的</p><p>问题分析:R1上配置了ACL2000和ACL3000，其中ACL2000用于匹配内部需要NAT的地址，ACL3000用于匹配需要通过VPN隧道加密的流量，两条ACL重合，即ACL2000会把需要进行 VPN 传递的流量匹配出来，进行 NAT。</p><hr><p>[Rl] interface GigabitEthernet0&#x2F;0&#x2F;1</p><p>[R1-GigabitEthernet0&#x2F;0&#x2F;1]undo nat outbound 2000&#x2F;&#x2F;删除 NAT在接口上的应用</p><p>[R1-GigabitEthernet0&#x2F;0&#x2F;1] quit&#x2F;&#x2F;删除 ACL2000</p><p>[R1]undo acl 2000</p><p>[R1]ac13001&#x2F;&#x2F;配置ACL3001</p><p>[Rl-acl-adv-300l]rule 10 deny ip source 192.168.10.0 0.0.0.255 destination 192.168.20.00.0.0.255 &#x2F;&#x2F;设置规则10，拒绝源为192.168.10.0&#x2F;24，目的是192.168.20.0&#x2F;24的流量</p><p>[R1-acl-adv-3001]rule 20 permit ip &#x2F;&#x2F;设置规则20，其他流量全部允许</p><p>[R1-acl-adv-3001] quit</p><p>[R1] interface GigabitEthernet0&#x2F;0&#x2F;1</p><p>[R1-GigabitEthernet0&#x2F;0&#x2F;1] nat outbound 3001&#x2F;&#x2F;重新配置NAT转换</p><p>R2进行如下调整，在NAT地址池中排除需要进行VPN传送的流量(同R1类似)<br>[R2]interface GigabitEthernet0&#x2F;0&#x2F;1<br>[R2-GigabitEthernet0&#x2F;0&#x2F;1]undo nat outbound 2000<br>[R2-GigabitEthernet0&#x2F;0&#x2F;1] quit<br>[R2]undo acl 2000<br>[R2]acl 3001<br>[R2-acl-adv-3001]rule 10 deny ip source 192.168.20.0 0.0.0.255 destination 192.168. 10.0 0.0.0.255<br>[R2-acl-adv-3001]rule 20 permit ip<br>[R2-acl-adv-3001]quit<br>[R2]interface GigabitEthernet0&#x2F;0&#x2F;1<br>[R2-GigabitEthernet0&#x2F;0&#x2F;1] nat outbound 3001</p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为配置与安全技术</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E5%8D%8E%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E5%8D%8E%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="华为配置与安全技术"><a href="#华为配置与安全技术" class="headerlink" title="华为配置与安全技术"></a>华为配置与安全技术</h1><h2 id="网络探测BFD和NQA"><a href="#网络探测BFD和NQA" class="headerlink" title="网络探测BFD和NQA"></a>网络探测BFD和NQA</h2><h3 id="BFD"><a href="#BFD" class="headerlink" title="BFD"></a>BFD</h3><p>BFD(Bidirectional Forwarding Detection)双向转发检测</p><p><strong>BFD是一种用于快速检测网络链路或设备故障的协议。</strong></p><p>提供了一个<strong>通用的、标准化的、介质无关的、协议无关</strong>的快速故障检测机制，有两大优点：</p><p>​对链路连通状态提供轻负荷、<strong>快速故障检测(毫秒级)。 检测速度快</strong></p><p>​<strong>对任何介质、任何协议层进行实时检测</strong></p><p>   <strong>例如：[静态路由、RIP、OSPF、VRRP等] 兼容性强</strong></p><p>说直白一点，能够快速检测设备的状态，例如路由发生故障，可能线路需要几秒或几十秒才能够检测，如果有这BFD就能够实现毫秒级别的检测到，最多3秒。</p><h3 id="联动功能"><a href="#联动功能" class="headerlink" title="联动功能"></a>联动功能</h3><p>什么叫联动？</p><p>就是一个技术和另一个技术联合起来，例如vrrpo和bfd联动，能够更快速检测链路状态，设备故障时，本来vrrp需要几十秒才能切换，现在bfd能够50毫秒就能切换了</p><p>联动功能由检测模块、Track和应用模块三部分组成</p><p><strong>监测模块</strong>:负责对链路状态、网络性能等进行监测，并将探测结果通知给Track模块。<br><strong>Track模块</strong>:收到监测模块的探测结果后，及时改变Track项的状态，并通知应用模块。<br><strong>应用模块</strong>:根据Track项的状态，进行相应的处理，从而实现联动。</p><p><img src="/../../../../images/image-20240424131032548.png" alt="image-20240424131032548"></p><h4 id="BFD可以联动的协议"><a href="#BFD可以联动的协议" class="headerlink" title="BFD可以联动的协议"></a>BFD可以联动的协议</h4><p>检测IP链路、BFD单臂回声功能、与MPLS联动<br>与接口状态联动、与VRRP联动、与PIM联动</p><p><strong>与RIP联动、与OSPF联动、与IS-IS联动</strong></p><p><strong>与BGP联动、与静态路由联动、与静态路由联动</strong></p><p>BFD默认参数</p><p><img src="/../../../../images/image-20240424131338390.png" alt="image-20240424131338390"></p><p>常用命令：</p><p><img src="/../../../../images/image-20240424131540243.png" alt="image-20240424131540243"></p><p><img src="/../../../../images/image-20240424131546668.png" alt="image-20240424131546668"></p><h4 id="BFD和VRRP联动"><a href="#BFD和VRRP联动" class="headerlink" title="BFD和VRRP联动"></a>BFD和VRRP联动</h4><p>将BFD应用于Backup对Master的检测，VRRP通过监视BFD会话状态实现主备快速切换，切换时间控制在<strong>50毫秒以内。</strong></p><p><img src="/../../../../images/image-20240424131641740.png" alt="image-20240424131641740"></p><h4 id="静态路由与BFD联动配置"><a href="#静态路由与BFD联动配置" class="headerlink" title="静态路由与BFD联动配置"></a>静态路由与BFD联动配置</h4><p><img src="/../../../../images/image-20240424131708401.png" alt="image-20240424131708401"></p><p><img src="/../../../../images/image-20240424131716577.png" alt="image-20240424131716577"></p><p>BFD会话配置验证</p><p><img src="/../../../../images/image-20240424131757057.png" alt="image-20240424131757057"></p><h4 id="OSPF与BFD联动配置"><a href="#OSPF与BFD联动配置" class="headerlink" title="OSPF与BFD联动配置"></a>OSPF与BFD联动配置</h4><p><img src="/../../../../images/image-20240424131820841.png" alt="image-20240424131820841"></p><p><img src="/../../../../images/image-20240424131826989.png" alt="image-20240424131826989"></p><p>BFD会话配置验证</p><p><img src="/../../../../images/image-20240424131846412.png" alt="image-20240424131846412"></p><h3 id="NQA"><a href="#NQA" class="headerlink" title="NQA"></a>NQA</h3><p>NQA(Network Quality Analysis)，即网络质量分析，是用于帮助用户度量网络性能和检测网络故障的工具。NQA通过从一个网络端点向另一个网络端点发送报文，<strong>检测网络可达性，并统计两端之间网络的时延、丢包率、抖动等性能数据</strong>，从而帮助用户监视网络质量及检测网络故障。</p><p><img src="/../../../../images/image-20240424131946620.png" alt="image-20240424131946620"></p><p>NQA检测IP网络</p><p><img src="/../../../../images/image-20240424132011323.png" alt="image-20240424132011323"></p><h3 id="BFD和NQA相同点和不同点"><a href="#BFD和NQA相同点和不同点" class="headerlink" title="BFD和NQA相同点和不同点"></a>BFD和NQA相同点和不同点</h3><p>相同点:都可以检测网络连通性。</p><p>不同点:</p><p>(1)BFD检测速度快，能实现毫秒级检测，而NQA只能做到秒级。</p><p>(2)BFD功能简单，只能检测连通性，而NQA功能复杂，可以统计两端之间网络的时延、丢包率、抖动等性能数据。</p><h2 id="端口隔离Port-isolate"><a href="#端口隔离Port-isolate" class="headerlink" title="端口隔离Port-isolate"></a>端口隔离Port-isolate</h2><p>技术背景</p><p><img src="/../../../../images/image-20240424152536282.png" alt="image-20240424152536282"></p><p>ACL能够实现访问限制，为啥还需要端口隔离？</p><p>原因：主要acl配置太多，网络不只是三四台设备，限制需要六条命令，而端口隔离，只需要port-isolate就能够实现访问限制</p><h3 id="端口隔离技术"><a href="#端口隔离技术" class="headerlink" title="端口隔离技术"></a>端口隔离技术</h3><p>采用端口隔离功能，可以<strong>实现同一VLAN内端口之间的隔离</strong>。用户只需要将端口加入到隔离组中，就可以实现隔离组内端口之间二层数据的隔离。端口隔离功能为用户<strong>提供了更安全、更灵活的组网方案。</strong></p><p>配置</p><p><img src="/../../../../images/image-20240424154310537.png" alt="image-20240424154310537"></p><p><img src="/../../../../images/image-20240424153110950.png" alt="image-20240424153110950"></p><p>任务1：在同一网段、vlan。默认他们之间是可以互连。</p><p>实现：PC1和PC2不能访问，PC1和PC3能够访问</p><pre><code>int g0/0/1port-isolate enable group 1int g/0/02port-isolate enable group 1 #把她们放在同一个隔离组(group1)中</code></pre><p>任务2：默认已经设置三台PC机放在同一个隔离组中，默认是不能通信。</p><p>实现：PC1和PC2能互相访问，PC1和PC3不能访问。</p><pre><code>#需要设置代理ARP(中间人)int vlanif1ip address 192.168.1.254 24arp-proxy inner-sub-vlan-proxy enable#注意：如果port-isolate 隔离模式是二层三层都隔离(port-isolate mode all)，那么就代理ARP就没啥用了。</code></pre><p>端口隔离技术原理</p><p><img src="/../../../../images/image-20240424154647351.png" alt="image-20240424154647351"></p><h4 id="端口隔离配置案例"><a href="#端口隔离配置案例" class="headerlink" title="端口隔离配置案例"></a>端口隔离配置案例</h4><p><img src="/../../../../images/image-20240424154859834.png" alt="image-20240424154859834"></p><p><img src="/../../../../images/image-20240424154955260.png" alt="image-20240424154955260"></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>同一项目组的员工都被划分到VLAN10中，其中属于企业内部的员工允许相互通信，属于企业外部的员工不允许相互通信，外部员工与内部员工之间允许通信，该如何实现?</p><p><img src="/../../../../images/image-20240424155102527.png" alt="image-20240424155102527"></p><p>解决方案：</p><p><img src="/../../../../images/image-20240424155128287.png" alt="image-20240424155128287"></p><p><img src="/../../../../images/image-20240424155135708.png" alt="image-20240424155135708"></p><h2 id="广播风暴问题与解决方案"><a href="#广播风暴问题与解决方案" class="headerlink" title="广播风暴问题与解决方案"></a>广播风暴问题与解决方案</h2><h3 id="广播风暴"><a href="#广播风暴" class="headerlink" title="广播风暴"></a>广播风暴</h3><h4 id="广播风暴是什么？"><a href="#广播风暴是什么？" class="headerlink" title="广播风暴是什么？"></a>广播风暴是什么？</h4><p>指在计算机网络中，大量的广播消息在网络中传播，导致网络拥塞和性能下降的情况。</p><p>就比如：某个设备的网卡出现了异常，导致该设备不断地发送大量的广播消息。其他设备在收到这些广播消息后，会将其转发到其他端口，进而使得网络中的所有设备都收到这些广播消息。</p><h4 id="广播风暴的原因？"><a href="#广播风暴的原因？" class="headerlink" title="广播风暴的原因？"></a><strong>广播风暴的原因？</strong></h4><p>(1)二层环路。(没有启用生成树，或者生成树故障,设备&#x2F;接口故障等 )</p><p>(2)网络中存在攻击行为，某些终端中毒，持续发送恶意广播，或者扫描。</p><p>(3)特殊应用场景，比如云桌面批量启动，网络教室PC一键开机。</p><h4 id="如何解决广播风暴？"><a href="#如何解决广播风暴？" class="headerlink" title="如何解决广播风暴？"></a><strong>如何解决广播风暴？</strong></h4><p>(1)划分虚拟局域网VLAN，隔离广播域，缩小广播传递范围。</p><p>(2)通过STP&#x2F;MSTP、堆叠、链路聚合等技术，破除二层环路</p><p>(3)查杀终端病毒，消除网络攻击,</p><p>(4)交换机配置广播抑制。</p><h4 id="广播风暴的现象"><a href="#广播风暴的现象" class="headerlink" title="广播风暴的现象"></a><strong>广播风暴的现象</strong></h4><p>(1)交换机接口指示灯疯狂闪烁。<br>(2)交换机CPU利用率高。<br>(3)交换机命令行卡顿。<br>(4)用户上网慢，或者不能上网。<br>(5)出现MAC地址漂移。<br>(6)抓包分析，很多ARP、DHCP Discovery广播</p><h4 id="为什么二层环路会早餐广播风暴，三层环路不会呢？"><a href="#为什么二层环路会早餐广播风暴，三层环路不会呢？" class="headerlink" title="为什么二层环路会早餐广播风暴，三层环路不会呢？"></a><strong>为什么二层环路会早餐广播风暴，三层环路不会呢？</strong></h4><p>因为，三层是网络层，IP地址中有TTL值，每经过一跳，TTL值就减1，直到为0，则该包还没发出去，则丢弃。</p><h4 id="破除二层环路的方法？"><a href="#破除二层环路的方法？" class="headerlink" title="破除二层环路的方法？"></a><strong>破除二层环路的方法？</strong></h4><p>1、拔网线</p><p>2、MAC地址黑洞(把MAC地址拉入黑名单，mac-address blackhole xxx)</p><p>3、设置ACL</p><h3 id="流量抑制"><a href="#流量抑制" class="headerlink" title="流量抑制"></a>流量抑制</h3><p><img src="/../../../../images/image-20240424173136108.png" alt="image-20240424173136108"></p><p><img src="/../../../../images/image-20240424173426158.png" alt="image-20240424173426158"></p><p><img src="/../../../../images/image-20240424173435456.png" alt="image-20240424173435456"></p><h3 id="风暴控制"><a href="#风暴控制" class="headerlink" title="风暴控制"></a>风暴控制</h3><p><img src="/../../../../images/image-20240424173834336.png" alt="image-20240424173834336"></p><p><img src="/../../../../images/image-20240424173840809.png" alt="image-20240424173840809"></p><p><img src="/../../../../images/image-20240424173918690.png" alt="image-20240424173918690"></p><h3 id="流量抑制和风暴控制的区别"><a href="#流量抑制和风暴控制的区别" class="headerlink" title="流量抑制和风暴控制的区别"></a>流量抑制和风暴控制的区别</h3><p>从原理来看，两者都是为了防止广播、组播以及未知单播报文所引起的<strong>广播风暴</strong>，但两者对流量控制的形式不一样。</p><p>​流量抑制给三种报文流量配置阈值，当流量超过阈值时，系统将<strong>丢弃多余的流量</strong></p><p>​风暴控制给三种报文流量配置阈值，当流量超过阈值时，系统<strong>直接将端口关闭</strong></p><p>​<strong>一个接口下流量抑制和风暴控制特性冲突，同时只能配置其中的一个</strong></p><h2 id="MAC-Flood与解决方案"><a href="#MAC-Flood与解决方案" class="headerlink" title="MAC Flood与解决方案"></a>MAC Flood与解决方案</h2><h3 id="交换机工作原理"><a href="#交换机工作原理" class="headerlink" title="交换机工作原理"></a>交换机工作原理</h3><p><img src="/../../../../images/image-20240424215945134.png" alt="image-20240424215945134"></p><p>1、初始情况下，交换MAC地址表是空的。</p><p>2、当PC机发送一个数据帧，然后交换机收到数据帧后，将数据帧的源MAC地址学习到MAC地址表中，并与接收该帧的接口进行关联。</p><p>3、当交换机MAC地址表中查询发现没有匹配的表项，则将数据帧从除了其入站接口之外的接口泛洪出去。</p><p>4、当有PC机收到该数据帧，则会回复给PC(发送)，其他的PC则丢弃</p><p>5、当交换收到PC(接收)的数据帧，将帧头中的源MAC地址学习到MAC表，并与接收的PC的接口进行关联</p><p>6、交换机找到MAC表中查找数据帧的目的MAC地址，然后进行转发</p><p><strong>MAC Flood的本质：耗尽交换MAC地址表的DoS攻击</strong></p><h3 id="端口安全"><a href="#端口安全" class="headerlink" title="端口安全"></a>端口安全</h3><p>举个例子</p><p>这个端口安全是为防止别人攻击你设备的一种手段。</p><p>例如：当别人假的MAC进行攻击，每一次都是不一样的MAC地址。</p><p>而你只需要设置一些端口，例如只允许一个MAC地址通过，其他不通过，或者当MAC达到某一个极限值就会自动触发机制(接口关机、警告等)</p><p>将学习到的动态MAC地址转换为<strong>安全MAC地址</strong>，阻止非法用户通过本接口和交换机通信，从而增强设备的安全性。</p><p>应用在接入层设备，可以<strong>防止仿冒</strong>用户从其他端口攻击。</p><p>应用在汇聚层设备，可以<strong>控制</strong>接入用户的<strong>数量。</strong></p><p>启用后，端口之前学习到的动态MAC将被删除。</p><p><img src="/../../../../images/image-20240424221049584.png" alt="image-20240424221049584"></p><p>保护动作:流量如果违规(非安全MAC流量)，将会采取保护措施。</p><p><img src="/../../../../images/image-20240424221502747.png" alt="image-20240424221502747"></p><p>配置命令</p><p><img src="/../../../../images/image-20240424221524418.png" alt="image-20240424221524418"></p><p><img src="/../../../../images/image-20240424222614697.png" alt="image-20240424222614697"></p><h2 id="DHCP-Snooping"><a href="#DHCP-Snooping" class="headerlink" title="DHCP Snooping"></a>DHCP Snooping</h2><p><strong>私接DHCP服务器</strong></p><p>场景分析<br>(1)办公室只有2个网口，但有4名同事都需要连接有线网络私接小交换机或小路由器。<br>(2)单位没有部署无线网络，用户想手机上网，私接无线路由器</p><p>问题:</p><p>1、网络中有多个DHCP服务器，用户通过非官方DHCP服务器获取地址从而导致不能正常上网。</p><p>2、可能IP冲突</p><p>3、网络不稳定，安全漏洞，数据可能会被窃取</p><p><strong>DHCP Snooping</strong>的出现就是解决私接DHCP服务器问题</p><p>DHCP Snooping的信任功能，能够保证DHCP客户端从合法的DHCP服务器获取IP地址。</p><p>DHCP Snooping信任功能将接口分为信任接口和非信任接口：<br>    信任接口<strong>正常接收</strong>DHCP服务器响应的DHCP ACK、DHCP NAK和DHCP Offer报文</p><p>​设备只将DHCP客户端的DHCP请求报文通过<strong>信任接口发送</strong>给合法的DHCP服务器，不会向非信任接口转发</p><p>​非信任接口收到的DHCP Server发送的DHCP OFFER、DHCP ACK、DHCP NAK报文会被直接丢弃</p><p>通俗地说，DHCP Snooping把DHCP服务器的接口设置为trusted和untrusted。</p><p><img src="/../../../../images/image-20240424224743851.png" alt="image-20240424224743851"></p><p><strong>DHCP Snooping配置举例</strong></p><p><img src="/../../../../images/image-20240424225507937.png" alt="image-20240424225507937"></p><p><img src="/../../../../images/image-20240424225522111.png" alt="image-20240424225522111"></p><p>例题：</p><p><img src="/../../../../images/image-20240424225610455.png" alt="image-20240424225610455"></p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VRRP</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/Blog/VRRP/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/Blog/VRRP/</url>
      
        <content type="html"><![CDATA[<h1 id="VRRP"><a href="#VRRP" class="headerlink" title="VRRP"></a>VRRP</h1><p>VRRP能够在不改变组网的情况下，将多台路由器虚拟成一个虚拟路由器，通过配置虚拟路由器的IP地址为默认网关，实现网关的备份。</p><p>协议版本：VRRPv2，VRRPv3</p><p>VRRP仅使用IPv4，VRRP适用于IPv4和IPv6</p><p>VRRP协议报文：</p><p>只有一种报文：Advertisement报文；其目的IP地址224.0.0.18，目的MAC地址：01-00-5e-00-00-12(48位)，协议号是112</p><h2 id="VRRP基本结构"><a href="#VRRP基本结构" class="headerlink" title="VRRP基本结构"></a>VRRP基本结构</h2><p><img src="/../../../../images/image-20240517104911462.png" alt="image-20240517104911462"></p><p>编号优先级(vrrp id)，1~255</p><p>Priority,0~255,越大越优先，默认优先级是100</p><p>什么时候优先级会255？</p><p>虚拟IP和真实IP相同的时候才会是255，并选择那个接口作为master</p><p><strong>Virtual IP 给下面的虚拟机充当网关</strong></p><p>MAC地址： 0000-5e00-0101</p><p>从左往右：第一个：00 表示单播  01表示 组播(111)</p><p>00-5e00固定</p><p>0101，第一个01表示v2版本，如果是02表示v3版本</p><p>第二个01表示vrid1的编号</p><h2 id="VRRP主备备份工作过程"><a href="#VRRP主备备份工作过程" class="headerlink" title="VRRP主备备份工作过程"></a>VRRP主备备份工作过程</h2><p><img src="/../../../../images/image-20240517105527981.png" alt="image-20240517105527981"></p><p>1、最开始两台都是backup状态，配置完信息后，他们会互相交互报文</p><p>2、互相收到报文后，RouterA发现RouterB比自己优先级低，然后RouterA变成master，Router变成Backup，然后终端数据就会从RouterA出去。</p><p>3、终端发出的数据，交换机会把数据转到RouterA那个接口出去。</p><p>为什么交换机会把数据转到RouterA那个接口出去？</p><p>首先，RouterA成为Master后，RouterA会发送一个免费ARP报文(免费ARP是指发送IP地址和接收的IP地址是相同的)，ARP会以RouterA虚拟MAC地址作为源MAC地址，交换机是基于源MAC地址学习的，所以交换机能够学到RouterA的虚拟MAC地址，然后交换机就会把数据往RouterA去发送。 </p><p>4、状态维持，Master设备周期性(默认1s)地发送VRRP通告报文给组内其他设备，以通知自己处于正常工作状态。</p><h2 id="VRRP负载分担工作过程"><a href="#VRRP负载分担工作过程" class="headerlink" title="VRRP负载分担工作过程"></a>VRRP负载分担工作过程</h2><p>背景：传统的主备方式流量都经由单个Master转发，Master负担过重，而备机处于空闲状态</p><p><img src="/../../../../images/image-20240517110850267.png" alt="image-20240517110850267"></p><p>解决方案：通过配置不同的备份组，使RouterB成为新备份组的Master，这样就可以分担网络中流量了。</p><p><img src="/../../../../images/image-20240517111224641.png" alt="image-20240517111224641"></p><h2 id="VRRP主备路由器切换过程"><a href="#VRRP主备路由器切换过程" class="headerlink" title="VRRP主备路由器切换过程"></a>VRRP主备路由器切换过程</h2><p><img src="/../../../../images/image-20240517111427635.png" alt="image-20240517111427635"></p><p>如果Master发送故障，Backup在Master_Down_Interval时间内未收到Master发送的状态通告报文，则立即成为Master。</p><p>如果原Master故障恢复，则主备回切的过程：</p><p>发现收到RouterB的VRRP报文中的优先级比自己低，RouterA立即抢占成为Master。</p><p>Master立即抢占会出现什么问题？</p><p>如果Master恢复，但又没有恢复完全，网络是好是坏，网络就会出现抖动，然后导致主备切换频繁；所有需要<strong>抢占延迟</strong>，使得网络更加稳定</p><h2 id="VRRP故障场景"><a href="#VRRP故障场景" class="headerlink" title="VRRP故障场景"></a>VRRP故障场景</h2><p><img src="/../../../../images/image-20240517111956223.png" alt="image-20240517111956223"></p><p>设备(故障点2)或链路(故障点3)出现故障，在三倍周期时间内，Backup设备没有收到Master的通告报文，Backup设备认为Master不存在，Backup就会切换成Master</p><p>在没有联动的前提下，<strong>故障点1是无法被检测的</strong>(上行链路无法被检测)</p><p>为什么故障点1无法被检测？</p><p>因为Master和Backup交互报文是走下面那个链路，到达不了故障点1的链路。</p><h2 id="VRRP联动功能"><a href="#VRRP联动功能" class="headerlink" title="VRRP联动功能"></a>VRRP联动功能</h2><p>解决方法： 利用VRRP的联动功能监视上行接口或链路故障，主动进行主备切换。</p><p><img src="/../../../../images/image-20240517112904668.png" alt="image-20240517112904668"></p><p>如果没有联动功能：<strong>上行链路Down掉，但主备间通告正常，未发送状态切换，导致主机访问异常。</strong></p><p>联动功能：能够检测上行链路，如果那个上行链路的端口down掉，会把Master的优先级做一个“惩罚”，把优先级降低，降低到比Backup还低，然后使得Backup成为Master</p><p>但是联动不能万能的，如果故障出现在RouterA上行链路的另一端，那还是检测不到，所以需要借助BFD&#x2F;NQA&#x2F;IP-link监视整个链路</p><h2 id="VRRP配置实现"><a href="#VRRP配置实现" class="headerlink" title="VRRP配置实现"></a>VRRP配置实现</h2><p>主备备份方式</p><p><img src="/../../../../images/image-20240517113918477.png" alt="image-20240517113918477"></p><p>负载分担方式</p><p><img src="/../../../../images/image-20240517113953049.png" alt="image-20240517113953049"></p><ul><li>配置了 VRID 2 的虚拟IP地址为 <code>10.0.0.11</code>。</li><li>设置 VRID 2 的优先级为 <code>120</code>。优先级越高，越可能成为主VRRP路由器。</li><li>启用了抢占模式，并设置了延迟时间为 <code>20</code> 秒。在主路由器失效恢复后，等待 <code>20</code> 秒再抢占回主路由器角色。</li><li>跟踪接口 <code>GigabitEthernet0/0/0</code>，如果该接口状态变为不可用，则将 VRID 2 的优先级减少 <code>30</code>。</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/../../../../images/image-20240517114755479.png" alt="image-20240517114755479"></p><p><img src="/../../../../images/image-20240517114804347.png" alt="image-20240517114804347"></p><p><img src="/../../../../images/image-20240517114855784.png" alt="image-20240517114855784"></p><p>[RA] interface GigabitEthernet 10&#x2F;1<br>[RA-GigabitEtheret1&#x2F;0&#x2F;1]standby interface GigabitEthernet 1&#x2F;0&#x2F;2 30  &#x2F;&#x2F;监视g1&#x2F;0&#x2F;2，成为备份端口<br>[RA-GigabitEthemet1&#x2F;0&#x2F;1]standby interface GigabitEthernet 1&#x2F;0&#x2F;3 20 &#x2F;&#x2F;监视g1&#x2F;0&#x2F;3成为备份端口<br>[RA-GigabitEthernet1&#x2F;0&#x2F;1]standby timerdelay  10 &#x2F;&#x2F;配置切换延迟10s<br>[RA-GigabitEtheret1&#x2F;0&#x2F;1] quit</p><p>某分支机构网络拓扑图如1-1所示，该网络通过 BGP 接收总部网络路由，设备1与设备2作为该网络的网关设备，且运行VRRP(虚拟网络冗余协议)，与出口设备运行OSPF该网络规划两个网段10.11.229,0&#x2F;24 和10.11.230.0&#x2F;24，其中10.11.229.0网段只能访问总部网络10.11.230.0网段只能访问互联网。</p><p><img src="/../../../../images/image-20240517114923968.png" alt="image-20240517114923968"></p><p>若设备1处于活动状态(Master)，设备2的状态在哪条链路出现故障时会发生改变?请说明状态改变的原因.</p><p>答案：设备2在link e故障时，无法检测设备1的状态自动转换为master</p>]]></content>
      
      
      <categories>
          
          <category> Network - Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> VRRP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络规划设计</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="网络规划设计"><a href="#网络规划设计" class="headerlink" title="网络规划设计"></a>网络规划设计</h1><h2 id="综合布线"><a href="#综合布线" class="headerlink" title="综合布线"></a>综合布线</h2><p>网络规划和设计是一个<strong>迭代和优化</strong>的过程。</p><p>为什么需要结构化综合布线呢？</p><p>我们日常生活中，需要打电话，需要传输文件，又需要看视频；她们需要的用的传输介质都是不一样的；而结构化综合布线系统就是<strong>消除了原有通信线路在传输介质上的差别</strong>。</p><p><strong>综合布线六大子系统</strong></p><p>结构化布线系统包含6个子系统：</p><p><img src="/../../../../images/image-20240420095633003.png" alt="image-20240420095633003"></p><p><img src="/../../../../images/image-20240420095643153.png" alt="image-20240420095643153"></p><p><strong>工作区子系统</strong>：PC到插座&#x2F;网口之间的的布线，一般不超过10米</p><p><strong>水平子系统</strong>：信息插座到楼层的配线间之间的布线，一般不超过90米</p><p><strong>干线&#x2F;垂直子系统</strong>：各个楼层配线间的布线，现不同楼层之间的数据传输和通信</p><p><strong>设备间子系统</strong>：”机房”，核心交换机等等</p><p><strong>管理子系统</strong>：用于监控、管理和维护整个布线系统的软件或硬件，包含配线架的管理，也就是整理线缆</p><p><strong>建筑群子系统</strong>：实现不同建筑物的传输和通信</p><p>注意：并不是每一个楼层都有管理子系统</p><p><img src="/../../../../images/image-20240420101017462.png" alt="image-20240420101017462"></p><h2 id="网络分析与设计"><a href="#网络分析与设计" class="headerlink" title="网络分析与设计"></a>网络分析与设计</h2><p><strong>网络规划设计模型</strong></p><p><img src="/../../../../images/image-20240420111008805.png" alt="image-20240420111008805"></p><p><img src="/../../../../images/image-20240420111015284.png" alt="image-20240420111015284"></p><p><strong>五阶段网络开发过程(瀑布)</strong></p><p><img src="/../../../../images/image-20240420112225635.png" alt="image-20240420112225635"></p><p><img src="/../../../../images/image-20240420112855374.png" alt="image-20240420112855374"></p><p>网络安全技术措施表</p><p><img src="/../../../../images/image-20240420112928006.png" alt="image-20240420112928006"></p><p>技术评价</p><p>在进行网络技术选择时，考虑：</p><p><strong>通信带宽、技术成熟性、连接服务类型、可扩展性、高投资产比</strong>出等因素</p><p>对于大型网络工程来说，<strong>项目本身不能成为新技术的试验田</strong>。尽量使用较成熟、拥有较多案例的技术。</p><h2 id="网络结构与功能"><a href="#网络结构与功能" class="headerlink" title="网络结构与功能"></a>网络结构与功能</h2><p>局域网结构类型</p><p><img src="/../../../../images/image-20240420114712131.png" alt="image-20240420114712131"></p><p>三层架构(各层次功能)</p><p><img src="/../../../../images/image-20240420114751828.png" alt="image-20240420114751828"></p><p><img src="/../../../../images/image-20240420114800235.png" alt="image-20240420114800235"></p><p>接入层不设置网关，因为一般都说同个网段&#x2F;vlan</p><p>例题：</p><p><img src="/../../../../images/image-20240420114854901.png" alt="image-20240420114854901"></p><p><img src="/../../../../images/image-20240420114906637.png" alt="image-20240420114906637"></p><p><img src="/../../../../images/image-20240420114924958.png" alt="image-20240420114924958"></p><h2 id="广域网接入技术"><a href="#广域网接入技术" class="headerlink" title="广域网接入技术"></a>广域网接入技术</h2><p>1.PSTN公用电话网络 56kb&#x2F;s。<br>2.ISDN:BRI&#x3D;2B+D&#x3D;144K PRI&#x3D;30B+D&#x3D;2.048M.<br>3.线缆调制解调器接入 HFC 主干光纤，<strong>光纤到小区，铜缆接入</strong>。<br>4.数字用户线路远程接入 xDSL。<br>5.PON无源光网络，<strong>上行是TDMA，下行是广播</strong>。</p><p><img src="/../../../../images/image-20240420143128638.png" alt="image-20240420143128638"></p><p><img src="/../../../../images/image-20240420143141223.png" alt="image-20240420143141223"></p><p>HFC光纤：前端：Cable Modem(线缆解调的猫)，后端：CMTS</p><p>PON网络：前端：ONU(光猫,客户)，后端：OLT(运营商)</p><p>xDSL：前端：ADSL Modem，后端：DSLAM</p><p>例题：</p><p><img src="/../../../../images/image-20240420143211092.png" alt="image-20240420143211092"></p><p><img src="/../../../../images/image-20240420143255660.png" alt="image-20240420143255660"></p><p><img src="/../../../../images/image-20240420143314375.png" alt="image-20240420143314375"></p><p>PON网络：前端：ONU(光猫,客户)，后端：OLT(运营商)</p><p>上行是TDMA，下行是广播</p><p>ONU —–上行(TDMA)—&gt; OLT</p><p>ONU&lt;——下行(广播)——OLT</p><h2 id="网络故障排查命令"><a href="#网络故障排查命令" class="headerlink" title="网络故障排查命令"></a>网络故障排查命令</h2><p>问题解决模型</p><p><img src="/../../../../images/image-20240420143755539.png" alt="image-20240420143755539"></p><p>网络故障排查命令</p><p><img src="/../../../../images/image-20240420143837457.png" alt="image-20240420143837457"></p><p>专用故障排查工具</p><p><img src="/../../../../images/image-20240420143918048.png" alt="image-20240420143918048"></p><p><img src="/../../../../images/image-20240420144330336.png" alt="image-20240420144330336"></p><p><img src="/../../../../images/image-20240420144415531.png" alt="image-20240420144415531"></p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络管理</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><h2 id="网络管理基础"><a href="#网络管理基础" class="headerlink" title="网络管理基础"></a>网络管理基础</h2><h3 id="网络管理体系结构"><a href="#网络管理体系结构" class="headerlink" title="网络管理体系结构"></a>网络管理体系结构</h3><p>网络管理五大功能域：</p><p><strong>故障管理、配置管理、计费管理、性能管理、安全管理</strong></p><p>助记：“安配能计障”</p><p>故障管理：<strong>尽快发现故障、找出故障原因、以便采取补救措施</strong></p><p><img src="/../../../../images/image-20240419143436269.png" alt="image-20240419143436269"></p><p><img src="/../../../../images/image-20240419143523745.png" alt="image-20240419143523745"></p><h2 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h2><h3 id="网络管理协议五大标准"><a href="#网络管理协议五大标准" class="headerlink" title="网络管理协议五大标准"></a>网络管理协议五大标准</h3><p><img src="/../../../../images/image-20240419165123554.png" alt="image-20240419165123554"></p><h3 id="SNMP-记"><a href="#SNMP-记" class="headerlink" title="SNMP(记)"></a>SNMP(记)</h3><p><strong>2个服务3个端口5个报文(235)</strong></p><p>SNMP为应用层协议，通过<strong>UDP承载</strong>，端口161和162.</p><p>不可靠，但效率高，网络管理<strong>不会太多增加网络负载.</strong></p><p><img src="/../../../../images/image-20240419165426889.png" alt="image-20240419165426889"></p><p><strong>5个报文</strong></p><p><img src="/../../../../images/image-20240419165503382.png" alt="image-20240419165503382"></p><p>为了简化书写，前三个可以简写为：<strong>get、get-next、set</strong>。</p><p>SNMP双端口:客户端用端口<strong>161</strong>来接收get&#x2F;set，服务器端用端口<strong>162</strong>来接收trap。</p><p>get：服务器查询客户机的信息，例如CPU利用率的数值等等</p><p>get-next：MIB数据库，就相当于给一个变量1.3.0.1是指CPU的利用率，通过调用这个1.3.0.1，就知道是CPU利用率的值</p><p>set：设置，修改命令配置等</p><p>get-response：每次服务器发来一次请求，客户机就需要响应给服务器</p><p>trap：客户机”主动上报“，例如客户机的CPU利用率高达90%，主动上报给服务器，说我这个机器有点异常。</p><hr><p>管理数据库 MIB - 2</p><p>被管理对象标识符OID</p><p><img src="/../../../../images/image-20240419180144779.png" alt="image-20240419180144779"></p><hr><p>例题：</p><p><img src="/../../../../images/image-20240419170722382.png" alt="image-20240419170722382"></p><p><img src="/../../../../images/image-20240419170744231.png" alt="image-20240419170744231"></p><h3 id="SNMP版本"><a href="#SNMP版本" class="headerlink" title="SNMP版本"></a>SNMP版本</h3><h4 id="SNMPv1"><a href="#SNMPv1" class="headerlink" title="SNMPv1"></a>SNMPv1</h4><p>管理站和代理站之间可以是<strong>一对多</strong>关系，也可以是<strong>多对一</strong>关系</p><p>RFC1157规定SNMP基本认证和控制机制，通过**团体名(community)**验证实现。</p><p>团体名<strong>Community明文传输，不安全</strong>。</p><p><img src="/../../../../images/image-20240419171032808.png" alt="image-20240419171032808"></p><h4 id="SNMPv2"><a href="#SNMPv2" class="headerlink" title="SNMPv2"></a>SNMPv2</h4><p>SNMPv2增加定义了GetBulk和inform两个新协议操作。<br><strong>GetBulk</strong>: 快速获取大块数据。<br><strong>Inform</strong>: 允许一个NMS向另一个NMS<strong>发送Trap信息&#x2F;接收响应</strong>消息。</p><p><img src="/../../../../images/image-20240419174942651.png" alt="image-20240419174942651"></p><h4 id="SNMPv3"><a href="#SNMPv3" class="headerlink" title="SNMPv3"></a>SNMPv3</h4><p>SNMPv3重新定义了网络管理框架和安全机制</p><p>重新定义网络管理框架:将前两版中的管理站和代理统一叫做SNMP实体(entity)。</p><p>安全机制: <strong>认证和加密传输</strong>。</p><p><strong>时间序列模块</strong>: 提供重放攻击防护。</p><p><strong>认证模块</strong>: 完整性和数据源认证，使用SHA或MD5。</p><p><strong>加密模块</strong>: 防止内容泄露，使用DES算法。</p><p>有两种威胁是SNMPV3没有防护的: <strong>拒绝服务和通信分析</strong>。</p><p>例题：</p><p><img src="/../../../../images/image-20240419175851469.png" alt="image-20240419175851469"></p><p><img src="/../../../../images/image-20240419175917338.png" alt="image-20240419175917338"></p><h2 id="RMON"><a href="#RMON" class="headerlink" title="RMON"></a>RMON</h2><p>RMON(Remote Network Monitoring)</p><p>用于<strong>监视网络通信情况</strong>的设备叫网络监视器(Monitor)或网络分析器(Analyzer)、探测器(Probe)等。【监测流量 vs 监测设备】</p><p>RMON定义了管理信息库<strong>RMON MIB-II(流量信息)与SNMP MIB(设备信息)</strong></p><p>RMON目标: <strong>监视子网范围内通信</strong>，从而减少管理站和被管理系统之间的通信负载。</p><p><img src="/../../../../images/image-20240419182721895.png" alt="image-20240419182721895"></p><h2 id="网络管理命令"><a href="#网络管理命令" class="headerlink" title="网络管理命令"></a>网络管理命令</h2><h3 id="ipconfig-网络诊断命令"><a href="#ipconfig-网络诊断命令" class="headerlink" title="ipconfig(网络诊断命令)"></a>ipconfig(网络诊断命令)</h3><p><img src="/../../../../images/image-20240419192700950.png" alt="image-20240419192700950"></p><h3 id="ping-traceroute-故障诊断"><a href="#ping-traceroute-故障诊断" class="headerlink" title="ping traceroute(故障诊断)"></a>ping traceroute(故障诊断)</h3><p><img src="/../../../../images/image-20240419192810208.png" alt="image-20240419192810208"></p><h3 id="ARP命令"><a href="#ARP命令" class="headerlink" title="ARP命令"></a>ARP命令</h3><p><img src="/../../../../images/image-20240419193027195.png" alt="image-20240419193027195"></p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p><img src="/../../../../images/image-20240419193042913.png" alt="image-20240419193042913"></p><h3 id="route和nslookup"><a href="#route和nslookup" class="headerlink" title="route和nslookup"></a>route和nslookup</h3><p><img src="/../../../../images/image-20240419193255552.png" alt="image-20240419193255552"></p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组网技术</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E7%BB%84%E7%BD%91%E6%8A%80%E6%9C%AF/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E7%BB%84%E7%BD%91%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="组网技术"><a href="#组网技术" class="headerlink" title="组网技术"></a>组网技术</h1><h2 id="交换机基础"><a href="#交换机基础" class="headerlink" title="交换机基础"></a>交换机基础</h2><h3 id="交换机分类"><a href="#交换机分类" class="headerlink" title="交换机分类"></a>交换机分类</h3><p>1、根据交换机方式分：</p><p><strong>存储转发式交换：</strong>完整接收数据帧，缓存、验证、碎片过滤，转发</p><p><strong>优点： 可以提供差错校验和非对称交换。</strong></p><p><strong>缺点：延迟大。</strong></p><p><strong>直通式交换：</strong>输入端口扫描到目标地址后立即开始转发</p><p><strong>优点：延迟小、交换速度快。</strong></p><p><strong>缺点： 没有检错能力，不能实现非对称交换。</strong></p><p><strong>碎片过滤式交换：</strong>开始转发前先检查数据包的长度是否够6<strong>4个字节</strong>，如果小于64个字节，说明是冲突碎片，则丢弃；如果大于等于64个字节，则转发该包。</p><p>其他分类方式：</p><p>2.根据交换的协议层划分:二层交换机、三层交换机、多层交换机。</p><p>3.根据交换机结构划分:固定端口交换机、模块化交换机。</p><p>4.根据配置方式划分:<strong>堆叠交换机、非堆叠交换机</strong>。</p><p>5.根据管理类型划分:网管交换机、非网管交换机、智能交换机。</p><p>6.层次结构划分:<strong>核心交换机、汇聚交换机、接入交换机</strong>。</p><p><img src="/../../../../images/image-20240419103409036.png" alt="image-20240419103409036"></p><h3 id="级联和堆叠"><a href="#级联和堆叠" class="headerlink" title="级联和堆叠"></a>级联和堆叠</h3><p><img src="/../../../../images/image-20240419104134010.png" alt="image-20240419104134010"></p><p>级联：一级一级的连接，核心层-汇聚层-接入层，一般不超过三层</p><p>堆叠：好比虚拟化，在接入层，有三台交换机(24接口)，合并成一台交换机(72接口)。</p><p><strong>堆叠优劣势：</strong>(背)</p><p>优势：</p><p>(1)逻辑上把多台设备虚拟成一台设备，简化运维，方便管理。<br>(2)一台物理设备故障，其他设备可以接管转发、控制平台，避免了单点故障。<br>(3)跨设备的链路聚合，物理上的无环网络，无需再部署STP.<br>(4)链路聚合中的链路全部有效使用，链路利用率100%。</p><p>劣势：</p><p>(1)堆叠都是私有协议，不支持跨厂商设备堆叠。<br>(2)需要单独购买堆叠线缆。(现在最新的用光纤也能实现堆叠)<br>(3)存在一定资源浪费，特别高端设备，如果2台核心都配置双引擎，堆叠后只有1个引擎工作。<br>(4)如果堆叠系统升级或重启，一般会有20~60s的业务中断。<br>(5)可靠性风险:控制层面统一后，相当于把鸡蛋放在一个篮子里，如果整个逻辑设备的控制平面出现问题(比如说路由表被人攻击破坏)，就有可能导致整机瘫痪，影响的范围大。</p><p><strong>答题版：<br>堆叠技术优点:<br>①逻辑上变为一台设备，简化网络管理;<br>②提升系统可靠性,避免单点故障;<br>③配合链路聚合等技术，防止接口被生成树阻塞，提升链路利用率。<br>堆叠技术缺点:<br>①堆叠是私有协议，不支持跨厂商设备堆叠;<br>②系统升级会造成业务中断;<br>③多台设备堆叠，只有一个主控处于工作状态，存在资源浪费。</strong></p><h3 id="交换机性能参数"><a href="#交换机性能参数" class="headerlink" title="交换机性能参数"></a>交换机性能参数</h3><p>端口类型:RJ45电口、光口(SC&#x2F;GBIC&#x2F;<strong>SFP&#x2F;SFP+</strong>&#x2F;SFP28)</p><p>STP：支持千兆。SFP+：支持万兆</p><p>传输模式:半双工、全双工。</p><p>交换容量:<strong>端口数<em>端口速率</em>2.</strong></p><p>包转发率:单位时间内发送64字节数据包的个数</p><p>1000Mbps&#x2F;8&#x2F;(64+8+12)&#x3D;1.488Mpps</p><p>MAC地址数:交换机MAC地址表中可以存储最大的MAC地址数量。</p><p>VLAN表项:交换机最大支持VLAN数量，现在都是<strong>4094</strong>个。</p><h2 id="路由器基础"><a href="#路由器基础" class="headerlink" title="路由器基础"></a>路由器基础</h2><h3 id="路由器接口"><a href="#路由器接口" class="headerlink" title="路由器接口"></a>路由器接口</h3><p>广域网WAN端口和局域网LAN端口</p><p>RJ45端口:常规以太网电口。</p><p>以太网光口:SC&#x2F;GBIC&#x2F;SFP&#x2F;SFP+&#x2F;SFP28.</p><p>AUI端口:用于令牌环或总线型以太网接口。</p><p>Serial串口:用于连接DDN、帧中继、X.25、PSTN等网络</p><p>ISDN BRI&#x2F;PRI端口:ISDN线路互联</p><p>SDH POS接口:155M&#x2F;622M&#x2F;2.5G&#x2F;10G.</p><p>RJ45端口就是就是双绞线的接口</p><p><img src="/../../../../images/image-20240419115044999.png" alt="image-20240419115044999"><img src="/../../../../images/image-20240419114945553.png" alt="image-20240419114945553"></p><p>Serial串口</p><p><img src="/../../../../images/image-20240419115250050.png" alt="image-20240419115250050"></p><p>以太网口</p><p><img src="/../../../../images/image-20240419115817696.png" alt="image-20240419115817696"></p><h3 id="交换机路由器管理方式"><a href="#交换机路由器管理方式" class="headerlink" title="交换机路由器管理方式"></a>交换机路由器管理方式</h3><p>Console接口(最基础最常用)<br>AUX端口连接Modem (现在几乎没什么人用)<br>Telnet&#x2F;SSH<br>浏览器<br>网管软件</p><p>例题：</p><p><img src="/../../../../images/image-20240419115547288.png" alt="image-20240419115547288"></p><p><img src="/../../../../images/image-20240419115751807.png" alt="image-20240419115751807"></p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统与服务器</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统与服务器"><a href="#操作系统与服务器" class="headerlink" title="操作系统与服务器"></a>操作系统与服务器</h1><h2 id="IIS服务器"><a href="#IIS服务器" class="headerlink" title="IIS服务器"></a>IIS服务器</h2><p>远程桌面：RDP 3389</p><p>Samba： Linux主机提供Windows风格的<strong>文件和打印机共享服务</strong></p><p>IIS(Internet Information Server)因特网信息服务器</p><p>IIS可以搭建<strong>Web服务器、FTP服务器、SMTP服务器</strong></p><p>IIS支持身份验证安全机制有4种验证方法：</p><p>集成Windows身份验证 &gt;  摘要式身份验证 &gt; 基本身份验证 &gt; 匿名身份验证</p><p>邮件三剑客：</p><p><strong>SMTP(发) - POP3(收) - IMAP(同步)</strong></p><p>Linux Apache服务器</p><p>提供Web和FTP等服务，Web配置文件是httpd.conf</p><p>默认Web根目录：&#x2F;var&#x2F;www&#x2F;html或&#x2F;home&#x2F;httpd</p><p>虚拟主机：<strong>基于IP地址、基于端口、基于名字</strong></p><p>FTP服务器</p><p>FTP端口：<strong>21(控制)、TCP 20(数据)</strong></p><p>FTP站点访问：</p><p><strong>get：从服务器端下载文件</strong></p><p><strong>put：向FTP服务器端上传文件</strong></p><p>lcd： 设置客户端当前的目录</p><p>dir：展示目录下的文件</p><h2 id="DNS域名服务器"><a href="#DNS域名服务器" class="headerlink" title="DNS域名服务器"></a>DNS域名服务器</h2><p>域名系统(Domain Name System ,DNS)</p><p>DNS作用： 把域名转换为IP地址</p><p>DNS&#x2F;DHCP服务器必须为<strong>静态IP地址</strong>，而Web&#x2F;FTP均可以为动态IP。</p><p>Linux系统中提供DNS服务的组件为<strong>bind</strong>，主配置文件为<strong>named.conf</strong></p><p>诊断域名系统基础结构的信息和查看DNS服务器的IP地址命令是:<strong>nslookup</strong>。</p><h3 id="DNS域名系统结构"><a href="#DNS域名系统结构" class="headerlink" title="DNS域名系统结构"></a>DNS域名系统结构</h3><p>DNS通过层次结构的<strong>分布式数据库</strong>建立一致性名字空间。</p><p>FQDN完全合格域名，比如<a href="http://www.whu.edu.cn/">www.whu.edu.cn</a>.</p><p>最顶层是根域，用“”表示根域下面是顶级域，分为国家顶级域和通用顶级域</p><p>顶级域下面是二级域，二级域下还可以划分子域</p><p><img src="/../../../../images/image-20240417162931388.png" alt="image-20240417162931388"></p><h3 id="DNS记录类型-记"><a href="#DNS记录类型-记" class="headerlink" title="DNS记录类型(记)"></a>DNS记录类型(记)</h3><p><img src="/../../../../images/image-20240417163015638.png" alt="image-20240417163015638"></p><p>NS：表示一个局域网内的一个DNS服务器</p><p>SOA：在一个区域内众多NS(DNS服务器)中的主服务器</p><p>MX：全称 Mail Exchange </p><p>例题：</p><p><img src="/../../../../images/image-20240417163303975.png" alt="image-20240417163303975"></p><h3 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h3><p><img src="/../../../../images/image-20240417163347612.png" alt="image-20240417163347612"></p><pre><code>过程：1、输入www.test.com2、PC先去找浏览器的DNS缓存，如果没有，则找系统缓存，如果也没有，则找本地DNS服务器3、本地DNS服务器先会去区域记录查找，如果没有再去DNS服务器缓存。如果没有，则找转发器注意：这里可能会有疑问，为啥不先去找DNS服务器缓存呢？因为DNS服务器缓存是由其他域名服务器发过来的，并且DNS服务器的缓存并不是永久保存的，过一段时间就会清空，所以优先级的话就区域记录较高。4、转发器又向其他域名服务器查询，最终返回结果。</code></pre><p>例题：</p><p><img src="/../../../../images/image-20240417164036569.png" alt="image-20240417164036569"></p><p><strong>递归查询和迭代查询</strong></p><p><strong>递归查询</strong>:域名服务器帮助用户进行名字解析，并返回最后的结果。<strong>【老好人】</strong></p><p>比如：A,B,C,D四个人，A想知道”上学期的成绩”,A去问B，然后B不知道，B就去问C，C不知道，然后又去问D，D告诉B后，B就告诉A</p><p><strong>迭代查询:<strong>域名服务器进行迭代访问，反复多次，直到最后找到结果。</strong>【踢皮球】</strong></p><p>比如，A,B,C,D四个人，A想知道”上学期的成绩”,A去问B，然后B不知道，B然后去问C，C叫你去问D，然后B又去问D，D知道，然后告诉B或直接告诉A</p><p><img src="/../../../../images/image-20240417164149179.png" alt="image-20240417164149179"></p><p>例题：</p><p><img src="/../../../../images/image-20240417164949139.png" alt="image-20240417164949139"></p><p><img src="/../../../../images/image-20240417164959825.png" alt="image-20240417164959825"></p><h3 id="辅助DNS服务器"><a href="#辅助DNS服务器" class="headerlink" title="辅助DNS服务器"></a>辅助DNS服务器</h3><p><strong>DNS主服务器出现故障或因负载太重无法及时响应客户机请求</strong>，辅助服务器就会为主服务器共同承担压力</p><p>辅助服务器的区域数据都是从主服务器复制而来，<strong>DNS通知消息</strong>让辅助服务器能及时更新区域信息只有被通知的辅助域名服务器才能从主域名服务器进行区域复制。</p><p><img src="/../../../../images/image-20240417165153457.png" alt="image-20240417165153457"></p><h3 id="DNS配置文件"><a href="#DNS配置文件" class="headerlink" title="DNS配置文件"></a>DNS配置文件</h3><p><img src="/../../../../images/image-20240417165235351.png" alt="image-20240417165235351"></p><pre><code>/etc/hostname是主机名文件，包含主机IP地址、主机名、别名，其中别名可能没有。/etc/hosts 存放主机DNS解析缓存，包含IP地址、主机名。/etc/resolv.conf 是DNS服务器的配置文件，它包含了主机的域名搜索顺序和DNS服务器的地址。/etc/named.conf是DNS主配置文件，存放各类DNS记录，比如A记录、PTR记录。</code></pre><h2 id="DHCP服务器"><a href="#DHCP服务器" class="headerlink" title="DHCP服务器"></a>DHCP服务器</h2><h3 id="DHCP工作原理"><a href="#DHCP工作原理" class="headerlink" title="DHCP工作原理"></a>DHCP工作原理</h3><p><img src="/../../../../images/image-20240417230404932.png" alt="image-20240417230404932"></p><h3 id="DHCP租期更新"><a href="#DHCP租期更新" class="headerlink" title="DHCP租期更新"></a>DHCP租期更新</h3><p><img src="/../../../../images/image-20240417230546425.png" alt="image-20240417230546425"></p><h3 id="DHCP配置"><a href="#DHCP配置" class="headerlink" title="DHCP配置"></a>DHCP配置</h3><p>Linux</p><p><img src="/../../../../images/image-20240417230817159.png" alt="image-20240417230817159"></p><p>华为路由器</p><p><img src="/../../../../images/image-20240417230903065.png" alt="image-20240417230903065"></p><h3 id="DHCP报文格式"><a href="#DHCP报文格式" class="headerlink" title="DHCP报文格式"></a>DHCP报文格式</h3><p><img src="/../../../../images/image-20240417231414345.png" alt="image-20240417231414345"></p><h4 id="Option-43"><a href="#Option-43" class="headerlink" title="Option 43"></a>Option 43</h4><p>AC 负责对无线网络的管理和控制，包括配置无线网络参数、安全策略、用户认证、流量控制等。而</p><p>AP 则专注于提供无线信号覆盖，并负责与终端设备建立连接，传输数据。</p><p>Option 43应用举例</p><p><img src="/../../../../images/image-20240417231622574.png" alt="image-20240417231622574"></p><h3 id="华为DHCP-option-43配置"><a href="#华为DHCP-option-43配置" class="headerlink" title="华为DHCP option 43配置"></a>华为DHCP option 43配置</h3><p><img src="/../../../../images/image-20240417232554347.png" alt="image-20240417232554347"></p><p>为什么命令有ascii？</p><p>因为它能够将文本字符转换为数字的标准编码方式，它可以将人类可读的字符（如字母、数字和符号）转换为数字形式。</p><h3 id="DHCP分配固定IP地址"><a href="#DHCP分配固定IP地址" class="headerlink" title="DHCP分配固定IP地址"></a>DHCP分配固定IP地址</h3><p><img src="/../../../../images/image-20240417233010285.png" alt="image-20240417233010285"></p><pre><code>实验要求:[R1采用基于全局地址池的方式为PC1分配IP地址。采用基于接口地址池的方式为PC2和PC3分配IP地址，且PC3获取固定的IP地址。[R1]interface GigabitEthernet 0/0/1[R1-GigabitEthernet0/0/1]ip address 192.168.2.1 24[R1-GigabitEthernet0/0/1]DHCP select interface #选择接口地址池[R1-GigabitEthernet0/0/1]DHCP server excluded-ip-address 192.168.2.254[R1-GigabitEthernet0/0/1]DHCP server static-bind ip-address 192.168.2.2 mac-address 00e0-fc00-00aa #为PC3分配固定的IP地址</code></pre><h3 id="DHCP中继-DHCP-Relay"><a href="#DHCP中继-DHCP-Relay" class="headerlink" title="DHCP中继(DHCP Relay)"></a>DHCP中继(DHCP Relay)</h3><p>DHCP Relay即DHCP中继，它是为解决DHCP服务器和DHCP客户端不在同一个广播域而提出的，提供了对DHCP广播报文的中继转发功能，能够把DHCP客户端的广播报文“透明地”传送到其它广播域的DHCP服务器上，同样也能够把DHCF服务器端的应答报文“透明地”传送到其它广播域的DHCP客户端。</p><p><img src="/../../../../images/image-20240417233407896.png" alt="image-20240417233407896"></p><h4 id="DHCPRelay工作原理"><a href="#DHCPRelay工作原理" class="headerlink" title="DHCPRelay工作原理"></a>DHCPRelay工作原理</h4><p><img src="/../../../../images/image-20240417233500988.png" alt="image-20240417233500988"></p><h4 id="DHCP-Relay配置"><a href="#DHCP-Relay配置" class="headerlink" title="DHCP Relay配置"></a>DHCP Relay配置</h4><p><img src="/../../../../images/image-20240417233543946.png" alt="image-20240417233543946"></p><pre><code>R1、R2配置如下:[R1]interface GigabitEthernet0/0/0[R1-GigabitEthernet0/0/0] ip address DHCP-alloc[R1-GigabitEthernet0/0/0] quit[R2] DHCP server group HW[R2-DHCP-server-group-HW]DHCP-server 10.1.1.2[R2-DHCP-server-group-HW] quit[R2]interface GigabitEthernet 0/0/1[R2-GigabitEthernet0/0/1]ip address 10.1.1.1 24[R2-GigabitEthernet0/0/1] quit[R2]interface GigabitEthernet 0/0/0[R2-GigabitEthernet0/0/0]ip address 192.168.1.1 24[R2-GigabitEthernet0/0/0] DHCP select relay #配置中继器[R2-GigabitEthernet0/0/0] DHCP relay server-select HW #选择单播的目标对象[R2-GigabitEthernet0/0/0] quit</code></pre><h3 id="DHCP-Snooping"><a href="#DHCP-Snooping" class="headerlink" title="DHCP Snooping"></a>DHCP Snooping</h3><p>目的：防止私接DHCP服务器</p><pre><code>           +-----------+           | DHCP      |           | Server    |           +-----+-----+                 |        +--------+---------+        |    Switch 1      |        |                  |   +----+----+         +---+----+   | Client 1 |         | Client 2 |   +----------+         +---------+   Switch 1：端口1：连接到 DHCP 服务器，标记为“信任”端口。端口2：连接到 Client 1，未标记为“信任”端口。端口3：连接到 Client 2，未标记为“信任”端口。DHCP Snooping 配置的存在，Switch 1 在端口 2 上发现了来自未知 DHCP 服务器的 DHCP Offer 消息，因此阻止了 Client 1 的 IP 地址分配。而对于端口 3，Switch 1 发现了来自已知 DHCP 服务器的 DHCP Offer 消息，因此允许 Client 2 成功获得 IP 地址。</code></pre><h4 id="DHCP-Snooping配置"><a href="#DHCP-Snooping配置" class="headerlink" title="DHCP Snooping配置"></a>DHCP Snooping配置</h4><p><img src="/../../../../images/image-20240417234047054.png" alt="image-20240417234047054"></p><p>实现的实质：则在接口打”标签”，trusted和untrusted</p><p>例题：</p><p><img src="/../../../../images/image-20240417234220616.png" alt="image-20240417234220616"></p><p><img src="/../../../../images/image-20240417234259706.png" alt="image-20240417234259706"></p><h2 id="Linux服务器"><a href="#Linux服务器" class="headerlink" title="Linux服务器"></a>Linux服务器</h2><h3 id="Linux网络配置"><a href="#Linux网络配置" class="headerlink" title="Linux网络配置"></a>Linux网络配置</h3><p>Linux系统，设备和配置都是<strong>文件</strong></p><p>网络相关配置文件大多数位于&#x2F;etc目录下，这些文件可以在<strong>系统运行时修改</strong>，不用重启或停止任何守护程序，更改<strong>立刻生效</strong>。<br>“#”开头的为注释内容。</p><h4 id="Linux网络配置文件"><a href="#Linux网络配置文件" class="headerlink" title="Linux网络配置文件"></a>Linux网络配置文件</h4><p><img src="/../../../../images/image-20240418000841766.png" alt="image-20240418000841766"></p><p><img src="/../../../../images/image-20240418000856969.png" alt="image-20240418000856969"></p><h4 id="Linux网络接口配置"><a href="#Linux网络接口配置" class="headerlink" title="Linux网络接口配置"></a>Linux网络接口配置</h4><p><img src="/../../../../images/image-20240418001153217.png" alt="image-20240418001153217"></p><h4 id="网络配置命令"><a href="#网络配置命令" class="headerlink" title="网络配置命令"></a>网络配置命令</h4><p>route 配置路由的命令</p><p><img src="/../../../../images/image-20240418001849072.png" alt="image-20240418001849072"></p><p><img src="/../../../../images/image-20240418001856307.png" alt="image-20240418001856307"></p><h3 id="iptables防火墙配置"><a href="#iptables防火墙配置" class="headerlink" title="iptables防火墙配置"></a>iptables防火墙配置</h3><p><strong>四表五链</strong></p><p><img src="/../../../../images/image-20240419000330127.png" alt="image-20240419000330127"></p><p><strong>iptables命令的语法格式</strong></p><p><strong>iptables【-t表名】管理选项【链名】条件匹配-j执行动作</strong>例:iptables -t filter -A INPUT -s 192.168.184.20-p tcp –dport 22 -j DROP</p><p><img src="/../../../../images/image-20240419000535162.png" alt="image-20240419000535162"></p><h3 id="Linux文件目录、用户与组"><a href="#Linux文件目录、用户与组" class="headerlink" title="Linux文件目录、用户与组"></a>Linux文件目录、用户与组</h3><p><img src="/../../../../images/image-20240419000706435.png" alt="image-20240419000706435"></p><p><img src="/../../../../images/image-20240419000727097.png" alt="image-20240419000727097"></p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="网络安全基础"><a href="#网络安全基础" class="headerlink" title="网络安全基础"></a>网络安全基础</h2><p>网络安全威胁类型：</p><p>(1)<strong>窃听</strong>:例如搭线窃听、安装通信监视器和读取网上的信息等。</p><p>(2)<strong>假冒</strong>:当一个实体假扮成另一个实体进行网络活动时就发生了假冒。</p><p>(3)<strong>重放</strong>:重复发送一份报文或报文的一部分，以便产生一个被授权效果。**(随机数、时间戳 )**</p><p>(4)<strong>流量分析</strong>:对网上信息流观察和分析推断出网上传输的有用信息。</p><p>(5)<strong>数据完整性破坏</strong>:有意或无意地修改或破坏信息系统，或者在非授权和不能监测的方式下对数据进行修改。</p><p>(6)<strong>拒绝服务DoS</strong>:当一个授权实体不能获得应有的对网络资源的访问。SYN-Flooding、MAC-Flooding等</p><p>(7)<strong>资源的非授权使用</strong>:即与所定义的安全策略不一致的使用。</p><p>(8)<strong>陷门和特洛伊木马</strong>:通过替换系统合法程序，或者在合法程序里插入恶意代码。</p><p>(9)<strong>病毒</strong>:随着人们对计算机系统和网络依赖程度的增加，计算机病毒已经构成了对计算机系统和网络的严重威胁。</p><p>(10)<strong>诽谤</strong>:利用计算机信息系统的广泛互连性和匿名性散布错误的消息，以达到毁某个对象的形象和知名度的目的。</p><p>什么是拒绝服务DoS和DDoS？</p><p>就是一直访问你的资源，使得其他人访问不了。</p><p>DoS,就比如你去餐厅占了一个座位。但什么都不点，一直不走，其他人也使用不了你的位置</p><p>DDoS,不但你占了一个位置，你叫其他人一起跟你一样，占着位置，让其他人使用不了，分布式。</p><p>网络攻击分类：</p><p><strong>被动攻击</strong>:典型代表<strong>嗅探、监听和流量分析和会话拦截</strong>，最难被检测，重点是预防，主要手段是<strong>加密</strong></p><p><strong>主动攻击假冒、重放、欺骗、消息篡改和拒绝服务</strong>等，重点是<strong>检测而不是预防</strong>，手段有防火墙、IDS等技术</p><p>物理临近攻击:防止外人乱进机房。</p><p>内部人员攻击:内鬼渗透，内部瓦解。</p><p>分发攻击:软件开发出来未安装之前，被篡改。疫苗运输恒温不合格</p><h2 id="现代加密技术"><a href="#现代加密技术" class="headerlink" title="现代加密技术"></a>现代加密技术</h2><p>密码分为：</p><p><strong>私钥、公钥</strong>，介于私钥和公钥之间的密码称为<strong>混合密码</strong></p><h3 id="私钥密码"><a href="#私钥密码" class="headerlink" title="私钥密码"></a>私钥密码</h3><p>又称：<strong>对称密码</strong></p><p>比如，你电脑文件加密，加密密码是123，对方接收到解密也是123，只不过通过短信、微信等方式告诉它。。</p><p>特点： </p><p><strong>加密和解密使用相同的密钥</strong></p><p>消息的收发双方必须事先通过<strong>安全渠道交换密钥</strong>。</p><p>优点：<strong>加解密速度快，密文紧凑，使用密钥时的难破解</strong></p><p>缺点：<strong>密钥分配问题，密钥管理问题，无法认证源。</strong></p><p>什么是密文紧凑？</p><p>比如你10T数据加密后，仍然是10T</p><p><img src="/../../../../images/image-20240409214326335.png" alt="image-20240409214326335"></p><p><strong>对称加密算法总结</strong>(背)</p><p><img src="/../../../../images/image-20240409214614741.png" alt="image-20240409214614741"></p><p>分组加密算法和流加密算法是什么？</p><p>分组加密算法，比如，数据过大，拆分数据来加密</p><p>流加密算法，数据即使很大，也不拆分，进行加密</p><h3 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h3><p>又称：非对称密码</p><p>就是对数据加密和解密的密钥是不同的</p><p>优点：</p><p><strong>密钥分发方便、密钥保管量少，支持数字签名</strong></p><p>缺点：</p><p><strong>加密速度慢(计算量大，不适合加密大数据)，数据膨胀率高</strong></p><p>每个实体有两个密钥:<strong>公钥公开，私钥自己保存</strong><br><strong>公钥加密，私钥解密，可实现保密通信<br>私钥加密，公钥解密，可实现数字签名</strong></p><p>公钥是公开的，自己还是对方都是知道的，公钥密码是指对方的公钥，然后对方用自己的私钥解密。</p><p><img src="/../../../../images/image-20240409215028851.png" alt="image-20240409215028851"></p><p>常见的非对称加密算法如下<br>·RSA:512位(或1024位)密钥，计算量极大，难破解。</p><p>·Elgamal、ECC(椭圆曲线算法)、背包算法、Rabin、DH等</p><h3 id="混合密码"><a href="#混合密码" class="headerlink" title="混合密码"></a>混合密码</h3><p>混合密码: 发送方<strong>用对称密钥加密需要发送的消息，再用接收方的公钥加密对称密钥</strong>，然后一起发送给接收方;接收方先用自己的私钥解密得到对称密钥，然后用对称密钥解密得到明文。</p><p>通俗地说，</p><p>加密</p><p>1、数据先对称加密，得到加密数据(A)</p><p>2、然后对加密数据(A)进行非对称加密，得到加(密数据(A))(B)</p><p>3、发送给对方</p><p>解密</p><p>4、收到后，进行非对称解密，用自己的私钥解密，得到加密数据(A)</p><p>5、然后，再用对称解密，得到明文数据</p><p><img src="/../../../../images/image-20240409215832908-17126711136731.png" alt="image-20240409215832908"></p><h3 id="国产加密算法-SM系列"><a href="#国产加密算法-SM系列" class="headerlink" title="国产加密算法 - SM系列"></a>国产加密算法 - SM系列</h3><p>《中华人民共和国密码法》密码分为<strong>核心密码、普通密码和商用密码</strong>，实行分类管理。<br><strong>核心密码、普通密码用于保护国家秘密信息</strong>，属于国家秘密，由密码管理部门依法实行严格统一管理。<br>商用密码用于保护不属于国家秘密的信息，公民、法人可用。</p><p><img src="/../../../../images/image-20240409220924839.png" alt="image-20240409220924839"></p><h2 id="哈希算法-Hash"><a href="#哈希算法-Hash" class="headerlink" title="哈希算法 Hash"></a>哈希算法 Hash</h2><p>HASH函数，又称：<strong>杂凑函数，散列函数</strong>。</p><p><strong>能够任意长度的信息转换成固定长度的哈希值(数字摘要)。</strong></p><p>比如，1T的数据，进行哈希(MD5),大小为128位</p><p>特点：</p><p>**不可逆性(单向)**：哈希后不能推测出原来数据，比如128位信息摘要，不可能推出1T的数据内容</p><p><strong>无碰撞性</strong>：不同的数据进行hash，hash后的值不会是一样的</p><p><strong>雪崩效应</strong>：数据变化，导致hash值的结果显著不一样</p><p>常见的Hash算法有:<br>(1)MD5算法:以512位数据块为单位来处理输入，产生<strong>128位</strong>的信息摘要。常用于文件校验</p><p>(2)SHA算法:以512位数据块为单位来处理输入，产生<strong>160位</strong>的哈希值，具有比MD5更强的安全性。</p><p>(3)SM3国产算法:消息分组长度为512比特，输出<strong>256位</strong>摘要。</p><h3 id="HASH应用"><a href="#HASH应用" class="headerlink" title="HASH应用"></a>HASH应用</h3><p><strong>文件完整性校验</strong></p><p><img src="/../../../../images/image-20240409232009743.png" alt="image-20240409232009743"></p><p>比如，我们在官网上下载文件，官网上的文件是有hash值</p><p>然后我们下载后的文件，不确定文件是否被修改，下载文件后去</p><p>hash计算，跟官网上的hash进行比较</p><p><strong>账号密码存储</strong></p><p><img src="/../../../../images/image-20240409232526656.png" alt="image-20240409232526656"></p><p><strong>用户身份认证</strong></p><p>增加一个随机数R做哈希MAC&#x3D;Hash(密码+R)</p><p>需要双方预先知道这个R</p><p>MAC:消除中间人攻击，源认证+完整性校验</p><p><img src="/../../../../images/image-20240409232628875.png" alt="image-20240409232628875"></p><p>例题：</p><p><img src="/../../../../images/image-20240409232753927.png" alt="image-20240409232753927"></p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p><strong>签名方用自己的私钥进行签名，对方收到后，用签名方自己的公钥进行验证</strong></p><p>数字签名算法(公钥加密算法):<strong>RSA</strong>、Rabin、ELGamal签名体制和DSS标准</p><p>数据签名是用于<strong>确认发送者身份和消息完整性</strong>的一个加密消息摘要，具有如下特点：<br>(1)数字签名是可信的。<br>(2)数字签名不可伪造<br>(3)数字签名不能重新使用。<br>(4)签名文件是不能改变的。<br>(5)数字签名不能抵赖。<br>(6)接收者能够核实发送者身份。</p><p><img src="/../../../../images/image-20240410001934033.png" alt="image-20240410001934033"></p><p><img src="/../../../../images/image-20240410002003593.png" alt="image-20240410002003593"></p><h2 id="数字证书与CA"><a href="#数字证书与CA" class="headerlink" title="数字证书与CA"></a>数字证书与CA</h2><p>数字证书的作用：是确定接收方的公钥是正确的，并不是黑客的公钥。</p><p>例如：Alice发数据给Bob，需要进行非对称加密，需要获取Bob的公钥，那问题来了，发过来的公钥，一定是Bob的公钥嘛，也有可能是黑客截取信息，黑客把自己的公钥发给他，然后黑客来解密。</p><p>数字证书就是来解决这个问题的。颁发机构是CA，现实相当于公安机关，是非常安全的</p><p><img src="/../../../../images/image-20240410002113697.png" alt="image-20240410002113697"></p><p>数字证书类比：</p><p><img src="/../../../../images/image-20240410002628047.png" alt="image-20240410002628047"></p><p>数字证书里面主要包括：接收方的公钥+CA的私钥</p><p>PKI体系结构</p><p><img src="/../../../../images/image-20240410002928059.png" alt="image-20240410002928059"></p><p>1、<strong>用户&#x2F;终端实体</strong>:指将要向认证中心申请数字证书的客户，可以是个人，也可以是集团或团体、某政府机构等。</p><p>2、<strong>注册机构RA</strong>:<strong>负责受理用户申请证书，对申请人的合法性进行认证</strong>，并决定是批准或拒绝证书申请。注册机构并不给用户签发证书而只是对用户进行资格审查。<strong>较小的机构，可以由CA兼任RA的工作</strong></p><p>3、证书颁发机构CA:<strong>负责给用户颁发、管理和撤销证书</strong>。</p><p>4、证书发布系统:负责证书发放，如可以通过用户自已或是通过目录服务。</p><p>CRL库:证书吊销列表，存放过期或者无效证书。</p><p>例题</p><p><img src="/../../../../images/image-20240410003105583.png" alt="image-20240410003105583"></p><p>证书链</p><p>如果用户数量很多，通常由多个CA，每个CA为一部分用户发行和签证书。如果有两个CA，X1和X2，假设用户A从CA机构X1获得了证书，用户B从X2获得证书，如果两个证书发放机构<strong>X1和X2彼此间安全交换了公钥</strong>，彼此信任，那么他们的证书可以形成证书链。</p><p>A通过一个证书链来获取B的公钥，证书链表示为:X1《X2》x2《B》</p><p>B也能通过相反的证书链来获取A的公开密钥:X2《X1》X1《A》</p><p>怎么理解记忆？</p><p>A通过一个证书链来获取B的公钥，证书链表示为:X1《X2》x2《B》</p><p>首先，想要获得B的公钥，必须获得B的证书，B的证书又是X2发布，所以表示X2《B》</p><p>然后，B的证书，肯定要经过”上级的沟通”,A的领导跟B的领导沟通，即X1《X2》</p><p>最后，领导同意，然后再跟B拿证书，X1《X2》x2《B》</p><h2 id="IPSec原理"><a href="#IPSec原理" class="headerlink" title="IPSec原理"></a>IPSec原理</h2><h3 id="虚拟专用网-Virtual-Private-Network"><a href="#虚拟专用网-Virtual-Private-Network" class="headerlink" title="虚拟专用网(Virtual Private Network)"></a>虚拟专用网(Virtual Private Network)</h3><p>一种建立在公网上的，由某一组织或某一群用户专用的通信网络</p><p>二层:L2TP和PPTP(基于PPP)<br>三层:<strong>IPSec</strong>和GRE<br>四层:<strong>SSL</strong>&#x2F;TLS</p><p>实现虚拟专用网关键技术</p><p>隧道技术(Tuneling )</p><p>加解密技术(Encryption&amp;Decryption )</p><p>密钥管理技术(Key Management)</p><p>身份认证技术(Authentication)</p><p>这个VPN是来干什么的？</p><p>比如你的公司在上海，而你在广州出差，你需要去公司内部服务器拉取文件。这时候你不可能去公司拉取文件吧，所以需要远程进入公司内部，给你拉一条虚拟的网线，能够使你的电脑通信公司内部网络。</p><p><img src="/../../../../images/image-20240410222056021.png" alt="image-20240410222056021"></p><h3 id="二层隧道协议"><a href="#二层隧道协议" class="headerlink" title="二层隧道协议"></a>二层隧道协议</h3><p>二层隧道协议有<strong>PPTP和L2TP</strong>，都基于PPP协议，但<strong>PPTP只支持TCP&#x2F;IP体系</strong>，网络层必须是IP协议而L2TP可以运行在IP协议上，也可以在X.25、帧中继或ATM网络上使用。</p><p>PPP协议包含<strong>链路控制协议LCP和网络控制协议NCP</strong>。</p><p>PPP协议可以在点对点链路上<strong>传输多种上层协议</strong>的数据包，有校验位。</p><p><img src="/../../../../images/image-20240410223104621.png" alt="image-20240410223104621"></p><h3 id="PPP认证方式：PAP和CHAP"><a href="#PPP认证方式：PAP和CHAP" class="headerlink" title="PPP认证方式：PAP和CHAP"></a>PPP认证方式：PAP和CHAP</h3><p>PAP:<strong>两次握手</strong>验证协议，口令以明文传送，被验证方首先发起请求。<br>CHAP:<strong>三次握手</strong>，认证过程不传送认证口令，传送HMAC散列值。</p><p><img src="/../../../../images/image-20240410223002991.png" alt="image-20240410223002991"></p><h3 id="IPSec原理-1"><a href="#IPSec原理-1" class="headerlink" title="IPSec原理"></a>IPSec原理</h3><p>全称：IP Security</p><p>作用：增强IP网络的安全性</p><p>提供的安全服务：</p><p>​数据完整性(Data Integrity)</p><p>​认证(Autentication )</p><p>​保密性(Confidentiality )</p><p>​应用透明安全性(Application-transparent Security)</p><p><strong>IPSec功能分类：</strong></p><p><img src="/../../../../images/image-20240410223753859.png" alt="image-20240410223753859"></p><p><strong>IPSec两种封装模式：</strong></p><p><img src="/../../../../images/image-20240410223819504.png" alt="image-20240410223819504"></p><h2 id="SSL与HTTPS"><a href="#SSL与HTTPS" class="headerlink" title="SSL与HTTPS"></a>SSL与HTTPS</h2><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>SSL全称：Secure Socket Layer 安全套接层</p><p>位于传输层和应用层之间，属于<strong>传输层安全协议</strong></p><p>SSL和TLS有什么区别嘛？</p><p>作用是一样的，但只是不同厂商而已</p><p><strong>HTTPS &#x3D; HTTP + SSL&#x2F;TLS</strong></p><p>SSL包含：<strong>记录协议、警告协议和握手协议</strong></p><p><img src="/../../../../images/image-20240410232156879.png" alt="image-20240410232156879"></p><h3 id="HTTPS和S-HTTP"><a href="#HTTPS和S-HTTP" class="headerlink" title="HTTPS和S-HTTP"></a>HTTPS和S-HTTP</h3><p>HTTPS &#x3D; HTTP + SSL&#x2F;&#x2F;TLS，端口<strong>TCP 443</strong></p><p>S-HTTP 安全的超文本传输协议(Security HTTP)，端口<strong>TCP 80</strong>。</p><p>S-HTTP语法与HTTP一样，而<strong>报文头有所区别，进行了加密</strong></p><p><img src="/../../../../images/image-20240410232354347.png" alt="image-20240410232354347"></p><h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3><p>PGP(Pretty Good Privacy)是一个完整的<strong>电子邮件安全软件包</strong>，PGP提供数据加密和数字签名两种服务。采用<strong>RSA公钥证书进行身份验证，使用IDEA进行数据加密，使用MD5进行数据完整性验证</strong></p><p><img src="/../../../../images/image-20240410232509187.png" alt="image-20240410232509187"></p><h3 id="Kerberos和PKI"><a href="#Kerberos和PKI" class="headerlink" title="Kerberos和PKI"></a>Kerberos和PKI</h3><p>Kerberos是用于进行<strong>身份认证的安全协议</strong>，支持AAA:<strong>认证、授权和审计</strong></p><p><img src="/../../../../images/image-20240410232619992.png" alt="image-20240410232619992"></p><p><img src="/../../../../images/image-20240410232651560.png" alt="image-20240410232651560"></p><h3 id="其他应用层安全协议"><a href="#其他应用层安全协议" class="headerlink" title="其他应用层安全协议"></a>其他应用层安全协议</h3><p>S&#x2F;MIME(Security&#x2F;Multipurpose Internet Mail Extensions)提供<strong>电子邮件安全服务</strong>。</p><p>SET(Secure Electronic Transation)安全的电子交易，用于保障<strong>电子商务安全</strong>。</p><h2 id="防火墙和入侵检测"><a href="#防火墙和入侵检测" class="headerlink" title="防火墙和入侵检测"></a>防火墙和入侵检测</h2><p>防火墙就像门口保安</p><p>入侵检测就像园区内部的巡逻人员</p><p>因为有些黑客会挠开防火墙进入网络，所以需要入侵检测</p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>防火墙可以实现<strong>内部网络信任网络</strong>与<strong>外部不可信任网络</strong>(Internet)之间或是内部网络不同区域隔离与访问控制。</p><p>防火墙技术与分类:<strong>包过滤、状态化防火墙、应用层网关、应用层检测DPI</strong>。</p><p><img src="/../../../../images/image-20240411001626285.png" alt="image-20240411001626285"></p><p>防火墙区域划分</p><p><img src="/../../../../images/image-20240411001715510.png" alt="image-20240411001715510"></p><p>例题</p><p><img src="/../../../../images/image-20240411001737519.png" alt="image-20240411001737519"></p><p><img src="/../../../../images/image-20240411001804196.png" alt="image-20240411001804196"></p><h3 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h3><p>入侵检测IDS是防火墙之后的第二道安全屏障。</p><p><img src="/../../../../images/image-20240411001842470.png" alt="image-20240411001842470"></p><p>入侵检测系统的数据源</p><p>操作系统审计记录&#x2F;操作系统日志。</p><p>网络数据:核心交换机端口镜像，服务器接入<strong>交换机端口镜像</strong></p><p><img src="/../../../../images/image-20240411001936638.png" alt="image-20240411001936638"></p><p>华为交换机端口镜像配置</p><p><img src="/../../../../images/image-20240411002000017.png" alt="image-20240411002000017"></p><p>入侵检测分类</p><p>按信息来源分:HIDS、NIDS、DIDS(主机&#x2F;网络&#x2F;分布式)</p><p>按响应方式分:实时检测和非实时检测。</p><p>按数据分析技术和处理方式分:<strong>异常检测、误用检测</strong>和混合检测。</p><p><strong>异常检测</strong>:</p><p>​建立并不断更新和维护系统正常行为的轮廓，定义报警阈值，超过阈值则报警</p><p>​能够检测从未出现的攻击，但误报率高。</p><p><strong>误用检测</strong>:</p><p>​对已知的入侵行为特征进行提取，形成入侵模式库，匹配则进行报警</p><p>​已知入侵检测准确率高，对于未知入侵检测准确率低，<strong>高度依赖特征库</strong>。</p><p>​检测技术:专家系统和模式匹配。</p><p>解释HIDS、NIDS、DIDS</p><p>HIDS，相当于杀毒软件</p><p>NIDS，在每个网段都能够检测</p><p>DIDS，多个网段的入侵检测收集的流量，再汇聚给上一层入侵检测系统</p><h3 id="入侵防御系统IPS"><a href="#入侵防御系统IPS" class="headerlink" title="入侵防御系统IPS"></a>入侵防御系统IPS</h3><p>定义:入侵防御系统是一种抢先的网络安全检测和防御系统，能<strong>检测出攻击并积极响应</strong></p><p>IPS不仅具有入侵检测系统检测攻击行为的能力，而且具有<strong>拦截攻击并阻断攻击</strong>的功能</p><p>IPS不是IDS和防火墙功能的简单组合，IPS在攻击响应上采取的是<strong>主动的全面深层次的防御</strong></p><p><strong>入侵防御系统IPS vS 入侵检测系统IDS</strong>（背，下午）</p><p>部署位置不同:IPS一般<strong>串行部署</strong>，IDS一般<strong>旁路部署</strong></p><p>入侵响应能力不同:IPS能<strong>检测入侵，并能主动防御，</strong>IDS只能检测记录日志，发出警报</p><p><img src="/../../../../images/image-20240411002746242.png" alt="image-20240411002746242"></p><p>例题：</p><p><img src="/../../../../images/image-20240411002807363.png" alt="image-20240411002807363"></p><p><img src="/../../../../images/image-20240411002814555.png" alt="image-20240411002814555"></p><p><img src="/../../../../images/image-20240411002845390.png" alt="image-20240411002845390"></p><h2 id="计算机病毒基础"><a href="#计算机病毒基础" class="headerlink" title="计算机病毒基础"></a>计算机病毒基础</h2><p>病毒四个阶段：</p><p>潜伏阶段</p><p>繁殖阶段</p><p>触发阶段</p><p>执行阶段</p><p>病毒命名规则</p><p>病毒名称一般格式<br><strong>&lt;病毒前缀&gt;.&lt;病毒名&gt;.&lt;病毒后缀&gt;</strong></p><p><img src="/../../../../images/image-20240411173249247.png" alt="image-20240411173249247"></p><p><img src="/../../../../images/image-20240411173318254.png" alt="image-20240411173318254"></p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无线通信网</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E7%BD%91/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="无线通信网"><a href="#无线通信网" class="headerlink" title="无线通信网"></a>无线通信网</h1><h2 id="移动通信与5G"><a href="#移动通信与5G" class="headerlink" title="移动通信与5G"></a>移动通信与5G</h2><p>移动通信制式</p><p><img src="/../../../../images/image-20240421141930909.png" alt="image-20240421141930909"></p><p>5G应用场景与关键技术</p><p>5G关键技术包括:<strong>超密集异构无线网络、大规模输入输出(MIMO)、毫米波通信、软件定义网络和网络功能虚拟化</strong>。</p><p>例题：</p><p><img src="/../../../../images/image-20240421142222911.png" alt="image-20240421142222911"></p><p><img src="/../../../../images/image-20240421142232154.png" alt="image-20240421142232154"></p><h2 id="WLAN通信技术"><a href="#WLAN通信技术" class="headerlink" title="WLAN通信技术"></a>WLAN通信技术</h2><p>无线网主要使用三种通信技术：<strong>红外线、扩展频谱(扩频)和窄带微波技术</strong>。</p><p>扩展频谱通信： 将信号散步到更宽的带宽上以<strong>减少发送阻塞和干扰</strong>的机会。</p><p>WLAN主要使用扩展频谱技术：**频率跳动扩频FHSS(蓝牙)和直接序列扩展频谱DSSS(Wi - Fi)**。</p><p><img src="/../../../../images/image-20240421143515592.png" alt="image-20240421143515592"></p><p>例题：</p><p><img src="/../../../../images/image-20240421143756917.png" alt="image-20240421143756917"></p><p><img src="/../../../../images/image-20240421143957660.png" alt="image-20240421143957660"></p><h2 id="WLAN频谱与信道"><a href="#WLAN频谱与信道" class="headerlink" title="WLAN频谱与信道"></a>WLAN频谱与信道</h2><p>WLAN网络可以分为三类:基础无线网络、Ad Hoc网络和分布式无线系统。</p><p>基础无线网络(Infrastructure Networking):用户通过无线接入点AP接入</p><p>特殊网络(Ad Hoc Networking):用于军用自组网或寝室局域网联机游戏。</p><p>分布式无线系统:通过AC控制大量AP组成的无线网络。</p><p><img src="/../../../../images/image-20240421144439952.png" alt="image-20240421144439952"></p><p>ISM频段：主要开放给<strong>工业、科学、医学</strong></p><p><img src="/../../../../images/image-20240421144551308.png" alt="image-20240421144551308"></p><p><strong>不重叠信道</strong></p><p>2.4G频段</p><p><strong>13个信道，3个不重叠信道(1、6和11)</strong></p><p>5G+5.8G频段</p><p><strong>开放的不重叠信道有5个</strong></p><p><img src="/../../../../images/image-20240421144812012.png" alt="image-20240421144812012"></p><p>信道重用与AP部署</p><p><img src="/../../../../images/image-20240421144948158.png" alt="image-20240421144948158"></p><p>例题：</p><p><img src="/../../../../images/image-20240421145024947.png" alt="image-20240421145024947"></p><h3 id="802-11技术标准对比（背）"><a href="#802-11技术标准对比（背）" class="headerlink" title="802.11技术标准对比（背）"></a>802.11技术标准对比（背）</h3><p><img src="/../../../../images/image-20240421145218018.png" alt="image-20240421145218018"></p><p>1.W-Fi标准的工作频段。</p><p><strong>2.4GHZ:802.11、802.116和802.11g5GHz:802.11a和802.11ac:2.4GHz+5GHz 802.11n和802.11ax.</strong></p><p>2.非重叠信道数量。2.4GHz频段包含13个信道，有3个不重合信道，常用信道为<strong>1、6和11</strong>，不重合信道间隔5个信道。</p><p>3.不同802.11标准的最大速率。比如，<strong>802.11n最大支持600Mbps</strong>，802.11ax速率可达9600Mbps。</p><p>例题：</p><p><img src="/../../../../images/image-20240421145555133.png" alt="image-20240421145555133"></p><p><img src="/../../../../images/image-20240421145626208.png" alt="image-20240421145626208"></p><h2 id="802-11MAC层"><a href="#802-11MAC层" class="headerlink" title="802.11MAC层"></a>802.11MAC层</h2><h3 id="802-11访问控制机制"><a href="#802-11访问控制机制" class="headerlink" title="802.11访问控制机制"></a>802.11访问控制机制</h3><p><img src="/../../../../images/image-20240421165850171.png" alt="image-20240421165850171"></p><p>为什么AP不选择CSMA&#x2F;CD？</p><p>因为隐藏节点和暴露节点</p><p><img src="/../../../../images/image-20240421165929388.png" alt="image-20240421165929388"></p><h3 id="802-11三种帧间间隔"><a href="#802-11三种帧间间隔" class="headerlink" title="802.11三种帧间间隔"></a>802.11三种帧间间隔</h3><p>IFS(分布式协调IFS):最长的IFS，<strong>优先级最低</strong>，用于<strong>异步竞争访问</strong>的时延<br>PIFS(点协调IFS):中等长度的IFS，<strong>优先级居中</strong>，在PCF操作中使用。<br>SIFS (短IFS):最短的IFS，<strong>优先级最高</strong>，用于需要立即响应的操作**(确认ACK)**。</p><p>帧间间隔：指两个连续数据帧之间的时间间隔。这个间隔由发送器在发送一个数据帧后等待一段时间，以确保接收器有足够的时间准备接收下一个帧。</p><p>例题：</p><p><img src="/../../../../images/image-20240421173907327.png" alt="image-20240421173907327"></p><h2 id="移动AD-Hoc网络"><a href="#移动AD-Hoc网络" class="headerlink" title="移动AD Hoc网络"></a>移动AD Hoc网络</h2><p>802.11定义AD Hoc网络是由无线移动节点组成的<strong>对等网</strong>，无需网络基础设施的支持，<strong>每个节点既是主机，又是路由器</strong>，是一种MANNET(Mobile Ad Hoc Network)网络。</p><h3 id="MANET网络特点"><a href="#MANET网络特点" class="headerlink" title="MANET网络特点"></a>MANET网络特点</h3><p>网络拓扑结构动态变化的，<strong>不能使用传统路由协议</strong>。</p><p>无线信道提供的带宽较小，<strong>信号衰落和噪声干扰的影响却很大</strong>。</p><p>无线终端携带的电源能量有限。</p><p>容易招致<strong>网络窃听、欺骗、拒绝服务</strong>等恶意攻击的威胁。</p><p><img src="/../../../../images/image-20240421182530682.png" alt="image-20240421182530682"></p><p>例题：</p><p><img src="/../../../../images/image-20240421182658901.png" alt="image-20240421182658901"></p><img src="../../../../images/image-20240421182712756.png" alt="image-20240421182712756" style="zoom:200%;"><h2 id="WLAN安全"><a href="#WLAN安全" class="headerlink" title="WLAN安全"></a>WLAN安全</h2><h3 id="WLAN安全机制"><a href="#WLAN安全机制" class="headerlink" title="WLAN安全机制"></a>WLAN安全机制</h3><p>(1)SSID访问控制:隐藏SSID，让不知道的人搜索不到。</p><p>(2)物理地址过滤:在无线路由器设置MAC地址黑白名单。</p><p>(3)WEP认证和加密:<strong>PSK预共享密钥</strong>认证,RC4加密(只需密码认证)</p><p>(4)<strong>WPA(802.11i草案)</strong><br>认证:802.1x。<br>加密:RC4(增强)+TKIP(临时密钥完整协议，动态改变密钥)支持<strong>完整性认证和防重放攻击</strong></p><p>(5)<strong>WPA2(802.11i)</strong></p><p>针对WPA优化，加密协议是由RC4变为<strong>基于AES的CCMP</strong></p><p>例题：</p><p><img src="/../../../../images/image-20240421205129939.png" alt="image-20240421205129939"></p><p><img src="/../../../../images/image-20240421205140905.png" alt="image-20240421205140905"></p><p><img src="/../../../../images/image-20240421205246347.png" alt="image-20240421205246347"></p><p><img src="/../../../../images/image-20240421205255736.png" alt="image-20240421205255736"></p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络互联设备_6-1</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94%E8%AE%BE%E5%A4%87/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="网络互联设备-6-1"><a href="#网络互联设备-6-1" class="headerlink" title="网络互联设备_6-1"></a>网络互联设备_6-1</h1><h2 id="中继器和集线器"><a href="#中继器和集线器" class="headerlink" title="中继器和集线器"></a>中继器和集线器</h2><h3 id="网络演进历史"><a href="#网络演进历史" class="headerlink" title="网络演进历史"></a>网络演进历史</h3><p>历史进程：</p><p>点对点(有距离限制)</p><p><img src="/../../../../images/image-20240329110229019.png" alt="image-20240329110229019"></p><p>出现距离限制，然后出现中继器，信号放大</p><p><img src="/../../../../images/image-20240329110304243.png" alt="image-20240329110304243"></p><p>但是中继器只有两个接口，但是设备越来越多。所以出现集线器</p><p><img src="/../../../../images/image-20240329110446776.png" alt="image-20240329110446776"></p><p>集线器和中继器的工作原理一样，只是集线器的接口比中继器多</p><p>然后形成HUB和中继器结合，形成局域网架构</p><p><img src="/../../../../images/image-20240329110600206.png" alt="image-20240329110600206"></p><p>有人会问，为什么不直接两个HUB相连？</p><p>因为产生环路，形成广播风暴。</p><h3 id="集线器工作原理"><a href="#集线器工作原理" class="headerlink" title="集线器工作原理"></a>集线器工作原理</h3><p>从一个接口进入的数据，进行信号放大后，从其他所有接口进行<strong>泛洪</strong>，工作原理其实就是泛洪机制</p><p><img src="/../../../../images/image-20240329111104540.png" alt="image-20240329111104540"></p><p>两台集线器连接起来，会出现什么问题？</p><p><img src="/../../../../images/image-20240329111133695.png" alt="image-20240329111133695"></p><p>会出现两大问题：</p><p>产生环路，形成广播风暴，影响通信效率。</p><p>数据扩散，严重安全威胁。</p><p>数据扩散是指，A机器发的数据给B，但是C也在这个集线器中，她也能够收到；例如A机器登录QQ，她的数据会从集线器出去，机器B可以利用抓包工具能够抓捕到A机器的账号和密码</p><p><img src="/../../../../images/image-20240329111230122.png" alt="image-20240329111230122"></p><h2 id="交换机工作原理"><a href="#交换机工作原理" class="headerlink" title="交换机工作原理"></a>交换机工作原理</h2><p><strong>交换机寻址</strong></p><p>初始情况下，交换机MAC地址表是空的。</p><p><img src="/../../../../images/image-20240329113943506.png" alt="image-20240329113943506"></p><p>交换机在收到数据帧后，将数据帧的<strong>源MAC地址学习到MAC地址表</strong>中，并与接收该帧的接口GE0&#x2F;0&#x2F;1口关联。</p><p><img src="/../../../../images/image-20240329114028229.png" alt="image-20240329114028229"></p><p>交换机在MAC地址表中查询数据帧的目的MAC地址，发现没有匹配的表项，因此将数据帧从除了其入站接口之外的所有接口<strong>泛洪</strong>出去。</p><p><img src="/../../../../images/image-20240329114111318.png" alt="image-20240329114111318"></p><p>PC2及PC3收到数据帧后将其丢弃，因为这些数据帧并非发送给自已;PC4则收下数据帧，现在PC4要回复数据给PC1。</p><p><img src="/../../../../images/image-20240329114134057.png" alt="image-20240329114134057"></p><p>PC4封装回复包，发给PC1</p><p><img src="/../../../../images/image-20240329114214764.png" alt="image-20240329114214764"></p><p>交换机收到了PC4的数据帧，将帧头中的<strong>源MAC地址</strong>学习到MAC表中，并与接口GE0&#x2F;0&#x2F;4关联。</p><p><img src="/../../../../images/image-20240329114236622.png" alt="image-20240329114236622"></p><p>交换机在MAC表中查找数据帧的<strong>目的MAC地址</strong>，发现有一个匹配的表项，出接口是GE0&#x2F;0&#x2F;1，于是将数据帧转发到GE0&#x2F;0&#x2F;1口。</p><p><img src="/../../../../images/image-20240329114255101.png" alt="image-20240329114255101"></p><p>例题：</p><p><img src="/../../../../images/image-20240329114314096.png" alt="image-20240329114314096"></p><h2 id="路由器和三层交换机"><a href="#路由器和三层交换机" class="headerlink" title="路由器和三层交换机"></a>路由器和三层交换机</h2><h3 id="路由器通信"><a href="#路由器通信" class="headerlink" title="路由器通信"></a>路由器通信</h3><p><img src="/../../../../images/image-20240330213604230.png" alt="image-20240330213604230"></p><h3 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h3><p><img src="/../../../../images/image-20240330213627530.png" alt="image-20240330213627530"></p><h3 id="路由器和三层交换机的区别？"><a href="#路由器和三层交换机的区别？" class="headerlink" title="路由器和三层交换机的区别？"></a>路由器和三层交换机的区别？</h3><p>典型园区拓扑结构</p><p><img src="/../../../../images/image-20240330213842523.png" alt="image-20240330213842523"></p><p><img src="/../../../../images/image-20240330213907812.png" alt="image-20240330213907812"></p><p>对比图</p><p><img src="/../../../../images/image-20240330213924205.png" alt="image-20240330213924205"></p><p>三层交换机使用的asic硬件芯片完成转发</p><p>路由器利用的是CPU完成转发</p><p>路由器和三层交换机区别，就好像一个博士和十万个小学生</p><p>路由器能够完成高端复杂的功能，但交换机只能完成一些简单的计算，但能够处理数量够大的，而路由器却完成不了太多数据。</p><h2 id="多层交换机-网关设备"><a href="#多层交换机-网关设备" class="headerlink" title="多层交换机&#x2F;网关设备"></a>多层交换机&#x2F;网关设备</h2><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关是互连网络中操作在OSI传输层之上的设施。网关的主要功能:<br>·     (1)连接网络层之上执行<strong>不同协议的子网</strong>，组成异构型的互联网。<br>·     (2)网关能对互不兼容的<strong>高层协议进行转换</strong>。<br>·     (3)为了实现异构型设备之间的通信，网关要对不同传输层、会      话层、表示层、应用层协议进行<strong>翻译和转换</strong>。</p><p><img src="/../../../../images/image-20240330214635813.png" alt="image-20240330214635813"></p><p>什么叫不同协议的子网？</p><p>例如：路由器上有很多接口，可以接不同类型的接口，比如以太网、ATM、SDH等，组成异构型的互联网</p><p>什么叫做能够兼容高层协议进行转换？</p><p>例如：例如一个部门使用TCP&#x2F;IP协议，另一个IPX&#x2F;SPX协议。它们使用的协议是互不兼容的，<strong>这时候就需要一个网关来进行协议转换成互相能够兼容的协议</strong></p><p>IPV6和IPV4为什么能够互相通信，因为有网关转换</p><h3 id="多层交换-多业务交换机"><a href="#多层交换-多业务交换机" class="headerlink" title="多层交换&#x2F;多业务交换机"></a>多层交换&#x2F;多业务交换机</h3><p>什么叫多业务交换机？</p><p>插入一个板卡就能够增加多一个功能或接口</p><p>什么是线卡？</p><p>线卡插入交换机就能够增加48个接口，插入更多的交换机等</p><p><img src="/../../../../images/image-20240330215806885.png" alt="image-20240330215806885"></p><p>华三硬件板卡最丰富，控标项;华为和锐捷板卡数量少,华为具有随板功能，如随板AC,软件授权。<br>实际项目配置多业务卡并不多(功能和性能原因，术业有专攻)。<br>了解一下迪普，也是多业务交换机的主推厂商。</p><h3 id="SDN可编程交换机"><a href="#SDN可编程交换机" class="headerlink" title="SDN可编程交换机"></a>SDN可编程交换机</h3><p><img src="/../../../../images/image-20240330220236687.png" alt="image-20240330220236687"></p><h3 id="网络演变"><a href="#网络演变" class="headerlink" title="网络演变"></a>网络演变</h3><p><img src="/../../../../images/image-20240330220302183.png" alt="image-20240330220302183"></p><p>1、交换机前身：中继器、集线器</p><p>2、二层交换机： 基于MAC转发</p><p>3、三层交换机： 集成路由功能</p><p>4、多业务交换机：FW&#x2F;AC&#x2F;LB&#x2F;WS等功能</p><p>5、可编程交换机： SDN 部分设备支持(H3C 125&#x2F;锐捷N18K等)</p><p>每个网络的演变都是有其缺点问题</p><p>中继器因为距离限制</p><p>集线器因为泛洪，广播风暴</p><p>二层交换机，有隔离，产生vlan，但跨vlan通信出现问题</p><p>三层交换机，能够解决跨vlan通信问题，nat提供等功能</p><p>多业务交换机：设备数量越多，网络越复杂</p><p>可编程交换机：优化设备 </p><hr><h1 id="网络层协议IP和ICMP"><a href="#网络层协议IP和ICMP" class="headerlink" title="网络层协议IP和ICMP"></a>网络层协议IP和ICMP</h1><h2 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h2><h3 id="IP报文格式"><a href="#IP报文格式" class="headerlink" title="IP报文格式"></a>IP报文格式</h3><p><img src="/../../../../images/image-20240331000304087.png" alt="image-20240331000304087"></p><p><strong>版本</strong>： 确定是IPV4还是IPV6</p><p>**头部长度(IHL)**：告诉接收方IPv4头部的实际长度是多少个32位字（4字节），从而帮助接收方正确地解析IPv4报文，定位到IP数据的开始位置，并且可以灵活地适应IPv4头部的可变长度情况。</p><p><strong>为什么最小值为5，最大值为15？</strong></p><p>因为IP头部最小是20字节，而IHL单位是4字节，所以20&#x2F;4&#x3D;5</p><p>同理，IP头部最大是60字节，而IHL单位是4字节，60&#x2F;4&#x3D;15</p><p><strong>TOS</strong>：为区分服务字段，用区分服务类型，即QoS字段。</p><p><strong>总长度字段</strong>：IPv4数据报的总长度(首部+数据)</p><p><strong>标识(MF)、标志、分片偏移</strong>：是用于数据分片和重组的重要字段</p><p>**生存期(TTL)**：于设置一个数据包可经过的路由器数量的上限，每经过一台路由器减1。</p><p><strong>协议字段</strong>：包含一个数字，标识数据报有效载荷部分的数据类型。最常用的值为1(ICMP)17(UDP)和6(TCP)</p><p><strong>头部校验和</strong>：仅计算IPV4头部，不检查数据有效载荷部分的正确性。当TTL减一时，头部校验和必须重新计算。</p><h3 id="IP分片定义"><a href="#IP分片定义" class="headerlink" title="IP分片定义"></a>IP分片定义</h3><p>IP报文最大65535字节，而以太网MTU为1500字节。</p><p>相当于货轮能载重65535，而火车载重1500，那么必须把货轮上的货物分装给多个火车运输。</p><p><img src="/../../../../images/image-20240331110555030.png" alt="image-20240331110555030"></p><p>例题：</p><p>以太网主机发送一个IP分组，长度3000字节，头长度为标准长度，发送该IP分组时应分为几个分片? 写出各分片的信息(长度、偏移、MF)。</p><p><img src="/../../../../images/image-20240331110838920.png" alt="image-20240331110838920"></p><p>特殊例题：</p><p><img src="/../../../../images/image-20240331110905788.png" alt="image-20240331110905788"></p><h3 id="IPv4地址分类"><a href="#IPv4地址分类" class="headerlink" title="IPv4地址分类"></a>IPv4地址分类</h3><pre><code>  二进制    十进制                         11      102     1004    10008   1000016  10000032 100000064100000001281000000012811000000192111000002241111000024011111000248111111002521111111025411111111255</code></pre><p><img src="/../../../../images/image-20240331130435577.png" alt="image-20240331130435577"></p><p><img src="/../../../../images/image-20240331132819339.png" alt="image-20240331132819339"></p><p>常用IP地址</p><p><img src="/../../../../images/image-20240331130625505.png" alt="image-20240331130625505"></p><h3 id="特殊IPv4地址"><a href="#特殊IPv4地址" class="headerlink" title="特殊IPv4地址"></a>特殊IPv4地址</h3><p>**0.0.0.0 **</p><p>主机端： DHCP分配过程中，用0.0.0.0表示本机</p><p>路由：0.0.0.0表示默认路由</p><p><strong>255.255.255.255</strong></p><p>三层广播的目标地址，在同一个广播范围内所有主机都会接收这个包。</p><p><strong>169.254.0.0&#x2F;16</strong></p><p>使用DHCP自动获取IP地址，当DHCP服务器发送故障，或响应时间超时，系统会为你分配这样的一个地址，不能正常上网。</p><p><strong>127.0.0.0&#x2F;8</strong></p><p>本地环回地址，用于测试或网络管理</p><p><strong>RFC1918私有IP地址</strong></p><p>IPv4地址空间中有一部分特殊的地址，成为私有IP地址，私有IP地址不能直接访问公网(Internet)的IP，只能在本地使用。</p><p>A类:10.0.0.0&#x2F;8(10.0.0.1-10.255.255.255)1个A类网络</p><p>B类:172.16.0.0&#x2F;12(172.16.0.1-172.31.255.255)16个B类网络</p><p>C类:192.168.0.0&#x2F;16(192.168.0.1-192.168.255.255)256个C</p><p><strong>常见组播</strong></p><p>224.0.0.1 所有主机<br>224.0.0.2 所有路由器<br><strong>224.0.0.5 所有运行OSPF的路由器</strong><br><strong>224.0.0.6 DR和BDR的组播接收地址</strong><br><strong>224.0.0.9 RIPv2组播更新地址</strong><br>224.0.0.18 VRRP组播地址</p><h3 id="ARP与RARP协议"><a href="#ARP与RARP协议" class="headerlink" title="ARP与RARP协议"></a>ARP与RARP协议</h3><p>为什么需要ARP？</p><p>因为他能够使得设备可以动态地获取目标设备的MAC地址，从而正确地发送和接收数据包。</p><p>ARP也简化了网络的配置和管理，提高网络的灵活性和自动化程度。</p><hr><p>ARP工作过程</p><p><img src="/../../../../images/image-20240331202545699.png" alt="image-20240331202545699"></p><p>主机A发送数据包给主机C之前，首先通过<strong>ARP协议根据IP地址获取主机MAC地址</strong></p><p>ARP请求：</p><p><img src="/../../../../images/image-20240331202648242.png" alt="image-20240331202648242"></p><hr><p><strong>为什么ARP字段中的目的主机MAC地址字段为:00:00:00:00:00:00而不是 FF:FF:FF:FF:FF:FF？</strong></p><p>目的主机 MAC 地址字段为 00:00:00:00:00:00 在 ARP 请求中起到了一种“填充”或“占位”的作用。它表示了一个请求，希望有网络中的设备能够回应，告诉发送设备自己的 MAC 地址。</p><p>一旦网络中的设备收到这个 ARP 请求并且发现自己的 IP 地址匹配到了请求中的目标 IP 地址，它们会响应这个 ARP 请求，并在 ARP 响应包中将自己的 MAC 地址放入目标主机 MAC 地址字段中。这样发送 ARP 请求的设备就能获得目标主机的 MAC 地址，以便进行通信</p><p>因此，在 ARP 请求中，目的主机 MAC 地址字段为 00:00:00:00:00:00 是一种用于发出“请求”信号的方式。它是一个暗示，告诉网络中的其他设备：这是一个 ARP 请求，目标主机的 MAC 地址尚未知晓，希望有设备能够回应并提供它的 MAC 地址。</p><hr><p>更新ARP缓存</p><p><img src="/../../../../images/image-20240331202712329.png" alt="image-20240331202712329"></p><p>ARP响应</p><p><img src="/../../../../images/image-20240331202741160.png" alt="image-20240331202741160"></p><p>更新ARP缓存</p><p><img src="/../../../../images/image-20240331202803384.png" alt="image-20240331202803384"></p><h4 id="ARP协议工作过程"><a href="#ARP协议工作过程" class="headerlink" title="ARP协议工作过程:"></a><strong>ARP协议工作过程</strong>:</h4><ol><li><p><strong>主机A查询自己的ARP缓存，发现没有主机B对应的MAC地址</strong>;</p></li><li><p><strong>主机A发送ARP Request报文(广播);</strong></p></li><li><p><strong>主机B把主机A的IP、MAC对应信息填入自己的ARP缓存中</strong>;</p></li><li><p><strong>主机B向主机A回送包含主机B的MAC地址的ARPReply报文(单播);</strong></p></li><li><p><strong>主机A收到主机B的ARP Replay报文，将主机B的IP和MAC对应关系填入自己的ARP缓存中</strong>。</p></li></ol><p><img src="/../../../../images/image-20240331203638960.png" alt="image-20240331203638960"></p><pre><code>ARP欺骗应用：p2p终结者(需要ARP欺骗一起使用，不然直接arp到路由进行转发)、网络执法官</code></pre><h4 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h4><p>免费ARP是用来探测IP地址是否冲突</p><p><img src="/../../../../images/image-20240331211956041.png" alt="image-20240331211956041"></p><h4 id="代理ARP"><a href="#代理ARP" class="headerlink" title="代理ARP"></a>代理ARP</h4><p><img src="/../../../../images/image-20240331213315767.png" alt="image-20240331213315767"></p><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>ICMP(Internet Control Message Protocol,Internet控制报文协议)，<strong>协议号为1</strong>,封装在IP报文中，用来<strong>传递差错、控制、查询****等信息，典型应用</strong>ping&#x2F;tracert**依赖ICMP报文。</p><p>ICMP报文类型和代码</p><p><img src="/../../../../images/image-20240331232139466.png" alt="image-20240331232139466"></p><p><strong>ping</strong></p><p><img src="/../../../../images/image-20240331232242089.png" alt="image-20240331232242089"></p><p><strong>tracert</strong></p><p>用于快速地跟踪数据包在网络上的路径，提供逐跳的延迟信息</p><p><img src="/../../../../images/image-20240331232345009.png" alt="image-20240331232345009"></p><p><strong>pathping</strong></p><p>提供更全面的路径信息，包括每个跃点的丢包率和平均往返时间</p><p><img src="/../../../../images/image-20240331232423241.png" alt="image-20240331232423241"></p><h1 id="传输层封装协议TCP和UDP"><a href="#传输层封装协议TCP和UDP" class="headerlink" title="传输层封装协议TCP和UDP"></a>传输层封装协议TCP和UDP</h1><h2 id="TCP和UDP报文格式"><a href="#TCP和UDP报文格式" class="headerlink" title="TCP和UDP报文格式"></a>TCP和UDP报文格式</h2><p>TCP和UDP特点：</p><p><strong>传输控制协议(TCP)</strong><br>面向连接</p><p>可靠传输流控及窗口</p><p>机制TCP应用: WEB浏览器，电子邮件</p><p>文件传输程序</p><p><strong>用户数据报协议(UDP)</strong><br>面向无连接</p><p>不可靠传输</p><p>尽力而为的传输</p><p>UDP应用:域名系统(DNS)，视频应用、IP语音(VoIP)</p><hr><p>IP就像快递送到小区，UDP就像送到家门口</p><p><img src="/../../../../images/image-20240401163635316.png" alt="image-20240401163635316"></p><p>复用：不同的应用进程使用同一个传输层协议来工作</p><p>分用：同一个运输层将应用报文交给不同的应用进程来使用</p><hr><p><strong>TCP报文格式</strong></p><p><img src="/../../../../images/image-20240401210709829.png" alt="image-20240401210709829"></p><p>偏移值：只是TCP头部的长度，用于确定数据的起始位置</p><p>保留：保留供未来使用</p><p>URG：紧急指针标志。当设置为1时，表示紧急指针字段有效，用于指示紧急数据的结束位置。这通常用于指示接收方应该优先处理这部分数据。</p><p>ACK：确认号标志。当设置为1时，表示确认号字段有效，指示这个TCP报文中的确认号是有效的。通常用来确认已经成功接收到数据。</p><p>PSH：推送标志。当设置为1时，表示接收方应该尽快将收到的数据交给应用程序，而不是等到接收缓冲区满了再交给应用程序。这个标志通常用于实时或交互式的应用程序，需要尽快处理数据。</p><p>PST：重置连接标志。当设置为1时，表示要求对方重新建立连接。通常在连接发生错误或者异常情况下使用，用来终止连接或者重置连接状态。</p><p>SYN：同步序号标志。当设置为1时，表示这是一个连接请求或者连接接受报文。用于在建立连接时，同步双方的序号和窗口大小。</p><p>FIN：结束连接标志。当设置为1时，表示发送方已经发送完毕数据，并要求关闭连接。通常用于结束通信会话，告知对方不再有数据发送。</p><p>窗口：用来指示在没有收到确认前还可以发送的数据量，用于流量控制</p><p><strong>TCP伪首部</strong></p><p>TCP伪首部本质是<strong>IP头的一部分，包含源目IP地址，协议号、TCP报头和用户数据</strong>，主要用于TCP<strong>校验和计算。</strong></p><p>TCP伪首部：确保校验和计算的准确性和可靠性</p><p><img src="/../../../../images/image-20240401211726766.png" alt="image-20240401211726766"></p><p><strong>UDP报文格式</strong></p><p><img src="/../../../../images/image-20240401211805826.png" alt="image-20240401211805826"></p><h2 id="TCP的握手和挥手"><a href="#TCP的握手和挥手" class="headerlink" title="TCP的握手和挥手"></a>TCP的握手和挥手</h2><h3 id="TCP三次握手建立连接"><a href="#TCP三次握手建立连接" class="headerlink" title="TCP三次握手建立连接"></a>TCP三次握手建立连接</h3><p><img src="/../../../../images/image-20240401215656133.png" alt="image-20240401215656133"></p><p><img src="/../../../../images/image-20240401215741562.png" alt="image-20240401215741562"></p><h3 id="TCP四次挥手断开连接"><a href="#TCP四次挥手断开连接" class="headerlink" title="TCP四次挥手断开连接"></a>TCP四次挥手断开连接</h3><p><img src="/../../../../images/image-20240401215810526.png" alt="image-20240401215810526"></p><h2 id="流量控制和拥塞控制"><a href="#流量控制和拥塞控制" class="headerlink" title="流量控制和拥塞控制"></a>流量控制和拥塞控制</h2><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>流量控制:为了<strong>防止发送方发送速度过快</strong>，导致接收方处理不过来，造成丢包重传，浪费网络资源。</p><p>TCP流量控制机制: <strong>可变大小的滑动窗口</strong>。</p><p>TCP滑动窗口机制</p><p><img src="/../../../../images/image-20240401232257048.png" alt="image-20240401232257048"></p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>有了流量控制，可以调节发送端和接收端的节奏，为什么还要有拥塞控制?<br>    <strong>流量控制</strong>:在AB两个端点进行。<br>    <strong>拥塞控制</strong>:在AB和所有网络节点中进行。</p><p>例如：A端最多能发1000M，B端最多能发800M，但中间链路带宽只能发500M，所以最多能发500M</p><p><img src="/../../../../images/image-20240401232536856.png" alt="image-20240401232536856"></p><p>TCP拥塞控制</p><p><img src="/../../../../images/image-20240401232856079.png" alt="image-20240401232856079"></p><p>例题：</p><p><img src="/../../../../images/image-20240401233048107.png" alt="image-20240401233048107"></p><p><img src="/../../../../images/image-20240401233419163.png" alt="image-20240401233419163"></p><h2 id="重要协议端口号总结"><a href="#重要协议端口号总结" class="headerlink" title="重要协议端口号总结"></a>重要协议端口号总结</h2><p>TCP&#x2F;UDP端口号</p><p><img src="/../../../../images/image-20240401233639543.png" alt="image-20240401233639543"></p><p><img src="/../../../../images/image-20240401233818309.png" alt="image-20240401233818309"></p><h1 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h1><h2 id="IP路由基础"><a href="#IP路由基础" class="headerlink" title="IP路由基础"></a>IP路由基础</h2><p>什么是路由？</p><p>根据路由表进行数据的转发，通俗讲，选择哪条比较近的路到达目的地</p><p><img src="/../../../../images/image-20240401235759297.png" alt="image-20240401235759297"></p><p>路由表工作原理</p><p>建立并维护路由表RIB。<br>直连路由:路由器<strong>本地接口</strong>所在网段。<br>静态路由:<strong>手工配置</strong>的路由条目。<br>动态路由:路由器之间通过<strong>动态路由协议</strong>学习到的路由。<br>根据路由表进行<strong>数据转发</strong>。</p><p>查看路由表</p><p><img src="/../../../../images/image-20240402000123337.png" alt="image-20240402000123337"></p><p>R是relay的首字母，说明是迭代路由，会根据路由下一跳的IP地址获取出接口。配置静态路由时如果你只指定下一跳IP地址，而不指定出接口，那么就是迭代路由，需要根据下一跳IP地址的路由获取出接口<br>D是download的首字母,表示该路由下发到FIB表。</p><h2 id="静态路由和默认路由"><a href="#静态路由和默认路由" class="headerlink" title="静态路由和默认路由"></a>静态路由和默认路由</h2><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>什么是静态路由？</p><p>R1想要访问R3，R2直连路由外，则需要添加路由条目，手工配置方式比较简单的方式，为路由器创建静态路由表项。</p><p><img src="/../../../../images/image-20240402114905225.png" alt="image-20240402114905225"></p><p>静态路由配置</p><p><img src="/../../../../images/image-20240402114823190.png" alt="image-20240402114823190"></p><h3 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h3><p>配置多条静态路由，但是发现下一跳都说同一个接口，这时候需要默认路由，来节省时间。</p><p><img src="/../../../../images/image-20240402122942814.png" alt="image-20240402122942814"></p><p>配置方式</p><p><img src="/../../../../images/image-20240402123000703.png" alt="image-20240402123000703"></p><p><strong>静态路由和默认路由特点</strong></p><p><strong>静态路由</strong><br>配置简单<br>手工配置，可控性高<br>节省网络带宽<br><strong>网络大，工作量大，比如配置1000条静态路由<br>网络故障，无法响应拓扑动态变化</strong></p><p><strong>默认路由</strong><br>默认路由是一种特殊的静态路由，走投无路的选择<br>配置简单，简化管理<br>降低路由 CPU、内存资源<br><strong>用处:网络出口路由器&#x2F;防火墙&#x2F;核心交换机</strong></p><p>PS: 静态路由和默认路由都不会响应拓扑动态变化</p><h2 id="动态路由协议"><a href="#动态路由协议" class="headerlink" title="动态路由协议"></a>动态路由协议</h2><p>什么是距离矢量路由协议，什么是链路状态路由协议？</p><p>距离矢量链路协议：</p><p>使用距离矢量路由协议的路由器并<strong>不了解网络的拓扑</strong>。该路由器只知道<br>自身与目的网络之间的距离。<br>应该往哪个方向或哪个接口转发数据包。</p><p>通俗地说：</p><p>距离矢量路由协议：就像，别人说往东走10步，再往西走6步，不知道拓扑结构。</p><p>链路状态路由协议：就像，高德地图，知道拓扑结构</p><p><strong>分类</strong>：</p><p><img src="/../../../../images/image-20240408100327992.png" alt="image-20240408100327992"></p><h3 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h3><p>RIP(Routing Information Protocol,路由信息协议 )</p><p><strong>内部网关协议，距离矢量路由协议</strong>。</p><p>华为设备上路由优先级为100。</p><p>计算跳数:<strong>最大15跳，16跳不可达</strong>，一般用于小型网络</p><p>几个时钟:<strong>30s周期性更新路由表、180s无更新表示不存在、300s删除路由表</strong></p><p>支持等价负载均衡和链路冗余，使用<strong>UDP 520</strong>端口。</p><p><img src="/../../../../images/image-20240408100705667-17125420350251.png" alt="image-20240408100705667"></p><p>RIP1 和 RIPv2 对比 </p><p><img src="/../../../../images/image-20240408100754654.png" alt="image-20240408100754654"></p><p>VLSM：可变长度子网掩码</p><p>CIDR：无类别域间路由，一种地址分配和路由选择的技术，使得IP地址的分配更加灵活，减少了地址空间的浪费，提高了路由表的效率</p><p>举例来说，考虑一个CIDR表示法的IPv4地址块：<code>192.168.1.0/24</code>。在这里，<code>192.168.1.0</code>是网络的基本地址，而<code>/24</code>表示前缀长度为24位。这意味着前24位用于网络标识，剩余的8位用于主机标识。通过这个CIDR表示法，我们可以轻松理解这个地址块包含了从<code>192.168.1.0</code>到<code>192.168.1.255</code>的所有主机。</p><p>RIP路由的度量值：</p><p>查看RIP路由的度量值： display ip routing-table</p><p>RIP以<strong>跳数</strong>作为度量值，但事实上不科学。</p><p><img src="/../../../../images/image-20240408102048668.png" alt="image-20240408102048668"></p><p>路由优先级(华为)，越小越优先</p><p><img src="/../../../../images/image-20240408194521090.png" alt="image-20240408194521090"></p><p>RIP防环机制</p><p>①最大跳数:当一个路由条目发送出去会自加1跳，跳数最大为16跳，意味着不可达。<br>②水平分割:一条路由信息不会发送给信息的来源。<br>③反向毒化的水平分割:把从邻居学习到的路由信息设为16跳，再发送给那个邻居<br>④抑制定时器和触发更新也可以防止环路。</p><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>Open Shortest Path First，开放式最短路径优先协议</p><p>内部网关协议，OSPF是一种<strong>链路状态路由协议</strong>。</p><p>Open意味着公有，任何厂商都能支撑OSPF，目前业内使用最广泛的IGP.</p><p>华为设备上，OSPF协议优先级Internal10，External150。</p><p>路由器之间<strong>交互的是链路状态信息</strong>，而不是直接交互路由。</p><p>路由器知晓网络拓扑结构，采用**SPF算法(迪杰斯特拉 Dijkstra)**计算达到目的地的最短路径。</p><p>支持VLSM，支持手工路由汇总。</p><p>OSPF基本特点：</p><p><strong>适应范围广</strong>:支持各种规模的网络。</p><p><strong>快速收敛</strong>:在网络的拓扑结构发生变化后立即发送更新报文，使这一变化在自治系统中同步。</p><p><strong>无自环</strong>:使用SPF最短路径树算法进行路由计算，<strong>不会产生环路</strong>。</p><p><strong>区域划分</strong>:允许网络被划分成区域来管理，链路状态数据库仅需和区域内其他路由器保持一致。 <strong>减小对路由器内存和CPU的消耗</strong>。同时区域间传送的路由信息减小，<strong>降低网络带宽占用</strong>。</p><p>OSPF Cost</p><p>OSPF使用Cost“开销”作为路由度量值。<br>OSPF接口cost&#x3D;100M&#x2F;接口带宽，其中100M为OSPF参考带宽(reference-bandwidth)，可修改.<br>每一个激活OSPF的接口都有一个cost值。<br>条OSPF路由的cost由该路由从起源一路到达本地的所有<strong>入接口cost值的总和</strong>。</p><p><img src="/../../../../images/image-20240408195339907.png" alt="image-20240408195339907"></p><p>OSPF区域</p><p>所有非骨干区域必须与骨干区域直连。</p><p><img src="/../../../../images/image-20240408195506537.png" alt="image-20240408195506537"></p><p>OSPF路由器角色</p><p><img src="/../../../../images/image-20240408195812787.png" alt="image-20240408195812787"></p><p>OSPF总结</p><p><img src="/../../../../images/image-20240408195853665.png" alt="image-20240408195853665"></p><h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>BGP(Border Gateway Protocol,边界网关协议)<strong>外部网关协议</strong>，用于不同自治系统AS之间，寻找最佳路由。<br>通过<strong>TCP 179</strong>端口建立连接。支持VLSM和CIDR，是一种路径矢量协议。目前最新版本是BGP4，而BGP4+支持IPV6。</p><p>BGP四个报文</p><p><img src="/../../../../images/image-20240408200034700.png" alt="image-20240408200034700"></p><p>BGP选路规则</p><p><img src="/../../../../images/image-20240408200058986.png" alt="image-20240408200058986"></p><h3 id="ISIS"><a href="#ISIS" class="headerlink" title="ISIS"></a>ISIS</h3><p>IS-IS(Intermediate system to intermediate system，中间系统到中间系统)是<strong>内部网关协议</strong>，是电信运营商普遍采用的内部网关协议之一，也是一个<strong>分级的链路状态路由协议</strong>。</p><p>与OSPF相似，它也使用Hello协议寻找毗邻节点。</p><p>与大多数路由协议不同，IS-IS 直接运行于链路层之上。</p><p>IS-IS具有层次性，分为两层Level-1和Level-2。</p><p>​Level-1(L1)是普通区域(Area)，Level-2(L2)是骨干区(Backbone)。</p><p>​<strong>骨干区Backbone是连续的Leve1-2路由器的集合，由所有的L2(含L1&#x2F;L2)路由器组成</strong>，L1和L2运行相同的SPF算法，一个路由器可能同时参与L1和L2。</p><p>IS-IS区域结构图</p><p><img src="/../../../../images/image-20240408200510050.png" alt="image-20240408200510050"></p><p>ISIS和OSPF区域架构</p><p><img src="/../../../../images/image-20240408200530848.png" alt="image-20240408200530848"></p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eth-Trunk和堆叠</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/Blog/Eth-Trunk%E5%92%8C%E5%A0%86%E5%8F%A0/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/Blog/Eth-Trunk%E5%92%8C%E5%A0%86%E5%8F%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Eth-Trunk和堆叠"><a href="#Eth-Trunk和堆叠" class="headerlink" title="Eth-Trunk和堆叠"></a>Eth-Trunk和堆叠</h1><h2 id="Eth-Trunk"><a href="#Eth-Trunk" class="headerlink" title="Eth-Trunk"></a>Eth-Trunk</h2><p><img src="/../../../../images/image-20240517134239857.png" alt="image-20240517134239857"></p><p>Eth-Trunk是一种将多个以太网接口捆绑成一个逻辑接口的捆绑技术。</p><p>Eth-Trunk链路聚合模式：<br>1、手工负载分担模式<br>2、LACP模式(802.3ad)</p><h3 id="手工负载分担模式"><a href="#手工负载分担模式" class="headerlink" title="手工负载分担模式"></a>手工负载分担模式</h3><p><img src="/../../../../images/image-20240517134452989.png" alt="image-20240517134452989"></p><p>当两台设备中至少有一台不支持LACP协议时，可使用手工负载分担模式的Eth-Trunk来增加设备间的带宽及可靠性。<br>在手工负载分担模式下，加入Eth-Trunk的链路都进行数据的转发</p><p>缺点：</p><p>1、端口差错，是不能够检测出来</p><p>A的端口1，2，3，连接对面的1，2，3，然后把捆绑到一个逻辑端口，然后端口1人为失误接到对方的4口，那么端口1的数据发送不过去。</p><h3 id="LACP模式"><a href="#LACP模式" class="headerlink" title="LACP模式"></a>LACP模式</h3><p>能够实现：主备模式</p><p>通俗地说，能够自由分配哪些链路工作，哪些链路做备链路</p><p><img src="/../../../../images/image-20240517134840860.png" alt="image-20240517134840860"></p><p>LACP模式也称为M:N模式，其中M条链路处于活动状态转发数据，N条链路处于非活动状态作为备份链路。</p><p>图中设置的活跃链路数为2，即2条链路处于转发状态，1条链路处于备份状态，不转发数据，只有当活跃的链路出现故障时，备份链路才进行转发。</p><p>特点：</p><p>1、端口插错，能够快速检测；</p><p>那一条端口插错，那条链路就协商不起来，管理人员能够快速知道哪条链路出现问题，并且那条链路出现故障，数据不会发往那一条链路</p><h4 id="LACP模式获得链路的选取"><a href="#LACP模式获得链路的选取" class="headerlink" title="LACP模式获得链路的选取"></a>LACP模式获得链路的选取</h4><p><img src="/../../../../images/image-20240517135351964.png" alt="image-20240517135351964"></p><p>先确定主动端</p><p>​1、比较设备优先级</p><p>​2、如果优先级相同，比MAC地址，越小越优先</p><p>确定主动端哪些端口主用，哪些是备用？</p><p>​1、比较主动端的端口优先级</p><p>​2、如果没有设置端口优先级，都是默认值，那么比较端口编  号，越小越优先。</p><h4 id="LACP模式的抢占机制"><a href="#LACP模式的抢占机制" class="headerlink" title="LACP模式的抢占机制"></a>LACP模式的抢占机制</h4><p><img src="/../../../../images/image-20240517135814875.png" alt="image-20240517135814875"></p><p>默认抢占延迟是30s</p><h3 id="Eth-Trunk接口负载分担"><a href="#Eth-Trunk接口负载分担" class="headerlink" title="Eth-Trunk接口负载分担"></a>Eth-Trunk接口负载分担</h3><p>Eth-Trunk接口进行负载分担时，可以选择IP地址或者包作为负载分担的散列依据;同时还可以设置成员接口的负载分担权重。</p><p>Eth-Trunk接口中，某成员接口的权重值占所有成员接口负载分担权重之和的比例越大，该成员接口承担的负载就越大。</p><p><img src="/../../../../images/image-20240517140002272.png" alt="image-20240517140002272"></p><h3 id="Eth-Trunk接口配置流程"><a href="#Eth-Trunk接口配置流程" class="headerlink" title="Eth-Trunk接口配置流程"></a>Eth-Trunk接口配置流程</h3><p><img src="/../../../../images/image-20240517140123897.png" alt="image-20240517140123897"></p><h4 id="配置命令-三层接口"><a href="#配置命令-三层接口" class="headerlink" title="配置命令(三层接口)"></a>配置命令(三层接口)</h4><p>方式1</p><p><img src="/../../../../images/image-20240517140159793.png" alt="image-20240517140159793"></p><p>undo portswitch &#x2F;&#x2F;关闭二层特性</p><p>方式2</p><p><img src="/../../../../images/image-20240517140213165.png" alt="image-20240517140213165"></p><p>查看命令</p><p>display eth-trunk 0</p><p><img src="/../../../../images/image-20240517140350466.png" alt="image-20240517140350466"></p><p>Preempt delay：抢占延迟</p><p>system priority：优先级</p><p>Hash： hash算法,算出一个值，决定这个数据包或者数据流走哪条链路。</p><p>system ID：MAC地址</p><p>Least Active-linknumber：默认是1</p><p>比如数值为2，就说明，这个链路最小也要两条链路工作，如果只剩下一条，整个链路断掉。</p><p>Max Active-linknumber：最大活动链路，一般为8</p><p>图中status的selected就是被选中，就是活动链路，unselected就是备用链路</p><h2 id="堆叠、集群"><a href="#堆叠、集群" class="headerlink" title="堆叠、集群"></a>堆叠、集群</h2><p><img src="/../../../../images/image-20240419104134010-171723051759220.png" alt="image-20240419104134010"></p><p>级联：一级一级的连接，核心层-汇聚层-接入层，一般不超过三层</p><p>堆叠：好比虚拟化，在接入层，有三台交换机(24接口)，合并成一台交换机(72接口)。</p><h3 id="堆叠基本认识"><a href="#堆叠基本认识" class="headerlink" title="堆叠基本认识"></a>堆叠基本认识</h3><p>主交换机(Master)、备交换机(Standby)、从交换机(Slave)</p><p>三者之间关系：</p><p>主交换机故障，则备交换机变成主交换机，然后从交换机会选择其中一条变成从交换机。</p><p><strong>堆叠逻辑接口</strong></p><p>堆叠口可以是：物理堆叠口&#x2F;逻辑堆叠口</p><p><strong>交叉连线</strong></p><p><img src="/../../../../images/image-20240517164616475.png" alt="image-20240517164616475"></p><p>G2&#x2F;0&#x2F;1，G堆叠ID&#x2F;端口号</p><p>**堆叠方式  **</p><p>堆叠卡堆叠</p><p><img src="/../../../../images/image-20240517165207559.png" alt="image-20240517165207559"></p><p>业务口堆叠</p><p><img src="/../../../../images/image-20240517165225223.png" alt="image-20240517165225223"></p><p><strong>堆叠连接拓扑</strong></p><p>链形连接</p><p><img src="/../../../../images/image-20240517165412595.png" alt="image-20240517165412595"></p><p>环形连接</p><p><img src="/../../../../images/image-20240517165451622.png" alt="image-20240517165451622"></p><p><strong>主交换机选举</strong></p><p>1、运行状态比较，已经运行的交换机比处于启动状态的交换机优先竞争为主交换机</p><p>堆叠主交换机选举超时时间为20s，堆叠成员交换机上电或重启时，由于不同成员交换机所需的启动时间可能差异比较大，因此不是所有成员交换机都有机会参与主交换机的第一次选举。</p><p>2、堆叠优先级高的交换机优先竞争为主交换机</p><p>3、堆叠优先级相同时，MAC地址小的交换机优先竞争为主交换机</p><p>简单地说，设置堆叠启动后，先启动的交换机A，</p><p>在20s内没有人跟交换机A竞选，那么交换机A就成为主交换机。</p><p>在20s内有人跟交换机A竞选，有交换机B加进来，那么交换机A和B进行PK。</p><p>4、堆叠优先级高的交换机优先竞争为主交换机，默认是100优先级。</p><p>5、如果堆叠优先级相同，MAC地址小的交换机竞争为主交换机。</p><p><strong>备交换机选举</strong></p><p>1、堆叠优先级最高的交换机成为交换机</p><p>2、堆叠优先级相同时，MAC地址最小的成为备交换机</p><p><strong>软件、配置同步</strong></p><p>角色选举、拓扑收集完成之后，所有成员交换机会自动同步<br>主交换机的系统软件和配置文件:</p><p>1、堆叠具有自动加载系统软件的功能，待组成堆叠的成员交换机不需要具有相同软件版本，只需要版本间兼容即可。<br>当备交换机或从交换机与主交换机的软件版本不一致时，备交换机或从交换机会自动从主交换机下载系统件，然后使用新系统软件重启，并重新加入堆叠。</p><p>2、堆叠具有配置文件同步机制，备交换机或从交换机会将主交换机的配置文件同步到本设备并执行，以保证堆叠中的多台设备能够像一台设备一样在网络中工作，并且在主交换机出现故障之后，其余交换机仍能够正常执行各项功能。</p><p>简单地说，备交换的版本或配置不相同，需要从主交换机下载，其中从主交换机下载软件后，需要使用新系统软件重启。</p><p><strong>堆叠管理与配置文件</strong></p><p><img src="/../../../../images/image-20240517175003360.png" alt="image-20240517175003360"></p><p><img src="/../../../../images/image-20240517175018799.png" alt="image-20240517175018799"></p><p><strong>跨设备链路聚合</strong></p><p>堆叠支持跨设备链路聚合技术，堆叠后成为逻辑上的一台交换机，支持将Eth-Trunk的成员接口分布在不同的成员交换机上。</p><p>当其中一条聚合链路故障或堆叠中某台成员交换机故障时，Eth-Trunk接口通过堆叠线缆将流量重新分布到其他聚合链路上，实现了链路间和设备间的备份，保证了数据流量的可靠传输。</p><p><img src="/../../../../images/image-20240517175204249.png" alt="image-20240517175204249"></p><p>当设备进行堆叠后，就相当于一台设备，就能够跨设备的逻辑聚合&#x2F;链路聚合(Eth-Trunk)。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>(1)逻辑上把多台设备虚拟成一台设备，简化运维，方便管理。</p><p>(2)一台物理设备故障，其他设备可以接管转发、控制平台，避免了单点故障</p><p>(3)跨设备的链路聚合，物理上的无环网络，无需再部署STP</p><p>(4)链路聚合中的链路全部有效使用，链路利用率100%。</p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>(1)堆叠都是私有协议，不支持跨厂商设备堆叠。</p><p>(2)需要单独购买堆叠线缆。(现在最新的用光纤也能实现堆叠)(3)存在一定资源浪费，特别高端设备，如果2台核心都配置双引擎，堆叠后只有1个引擎工作。</p><p>(4)如果堆叠系统升级或重启，一般会有20~60s的业务中断。</p><p>(5)可靠性风险:控制层面统一后，相当于把鸡蛋放在一个篮子里，如果整个逻辑设备的控制平面出现问题(比如说路由表被人攻击破坏)，就有可能导致整机瘫痪，影响的范围大。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>某企业办公楼网络拓扑如图1-1所示。该网络中交换机Switch1-Switch4均是二层设备，分布在办公楼的各层，上联采用千兆光纤。核心交换机、防火墙、服务器部署在数据机房，其中核心交换机实现冗余配置。</p><p><img src="/../../../../images/image-20240517183455327.png" alt="image-20240517183455327"></p><p>(1)简要说明该网络中核心交换机有哪几种冗余配置方式。</p><p>堆叠、VRRP</p><p>(2)在该网络中增加终端接入认证设备，可以选择在接入层、核心层或者DMZ区部署请选择最合理的部署区域并说明理由。</p><p>旁挂到核心层，速度快，可靠性高；</p><p>如果部署在接入层，万一出现问题，其他交换机下的PC就找不到认证设备了</p><p>如果部署在dmz区域，dmz区域是暴露给互联网用户访问的，而认证设备是给内网用户使用的，所以放在dmz也不合理</p><p>放在核心层比较合适，因为核心层的交换机比接入层的交换机更可靠，接入层故障，也不会影响其他接入层下的pc使用。</p><p>(1)校园网采用大二层组网结构，信息中心计划对核心交换机采用堆叠技术，请简述堆叠技术的优点和缺点。</p><p><strong>堆叠技术优点:<br>①逻辑上变为一台设备，简化网络管理;<br>②提升系统可靠性,避免单点故障;<br>③配合链路聚合等技术，防止接口被生成树阻塞，提升链路利用率。</strong></p><p><strong>堆叠技术缺点:<br>①堆叠是私有协议，不支持跨厂商设备堆叠;<br>②系统升级会造成业务中断:<br>③多台设备堆叠，只有一个主控处于工作状态，存在资源浪费。</strong></p><p>若车间1增加一台接入交换机C，该交换机需要与车间1接入层交换机进行互连，其连接方式有(10)和(11);其中(12)方式可以共享使用交换机背板带宽，(13)方式可以使用双绞线将交换机连接在一起。<br>10.堆叠<br>11.级联<br>12.堆香                                               13.级联</p><h2 id="堆叠和VRRP-STP"><a href="#堆叠和VRRP-STP" class="headerlink" title="堆叠和VRRP+STP"></a>堆叠和VRRP+STP</h2><p>为什么堆叠能够避免环路，而VRRP还需要添加STP才能避免环路？</p><p>首先，VRRP的主要目的是路由器冗余，而不是交换层面的环路防护。它在逻辑层面创建了一个虚拟的网关IP，但它不能控制交换机之间的物理连接。环路是交换机层（第二层）的问题，而VRRP是第三层的解决方案。</p><p>生成树协议（STP）通过检测和关闭冗余路径来防止环路的产生。STP工作在数据链路层，确保网络中的交换机形成一个无环的树形结构。</p><p>vrrp+stp协同工作：</p><ol><li><strong>交换机层面的环路防护</strong>：通过STP防止交换机之间的物理环路，确保网络的第二层拓扑无环。</li><li><strong>路由器层面的冗余</strong>：通过VRRP提供路由器的冗余，确保默认网关的高可用性。</li></ol><p>其次，堆叠技术将多台物理交换机连接在一起，使它们在逻辑上表现为一个单一的交换机。这种技术通过专用的堆叠接口和协议，将多台交换机的控制平面和数据平面合并，简化网络管理和配置。</p><p>堆叠如何避免环路</p><ol><li><strong>单一逻辑设备</strong>：堆叠后的交换机在逻辑上被视为一个设备。虽然物理上存在多个交换机和多条连接，但在网络拓扑上，它们表现为一个交换机。这种逻辑上的单一性消除了第二层的环路风险。</li><li><strong>专用的堆叠接口和协议</strong>：堆叠交换机之间使用专用的堆叠接口和协议进行通信，这些接口和协议设计用于高带宽和低延迟的互连，并且本身不会产生环路。堆叠协议负责管理堆叠成员之间的数据流动和路径选择，确保没有环路。</li><li><strong>集中管理和控制</strong>：在堆叠系统中，有一个主交换机（Master）和多个从交换机（Slave）。主交换机负责整个堆叠系统的控制和管理，包括路径选择和数据转发决策。通过集中管理，堆叠系统能有效地防止环路的形成。</li><li><strong>内置冗余和故障恢复</strong>：堆叠技术内置了冗余和故障恢复机制。当堆叠成员之间的连接出现故障时，堆叠系统能够自动调整数据路径，确保网络连通性，而不会产生环路。</li></ol><p>简单地说：</p><p>堆叠技术通过将多台交换机逻辑上合并为一个单一设备，并使用专用的堆叠接口和协议进行管理，能够有效避免二层环路问题。这种架构提供了简化管理、高扩展性和高可用性的优点，使其成为大规模网络环境中的理想选择。相比之下，VRRP需要与生成树协议（STP）配合使用，以确保复杂网络拓扑中的无环和高可用性。</p><p>堆叠技术需要使用，堆叠接口和协议才能实现；而VRRP不需要特殊的接口，VRRP能够在网络层把设备逻辑成一台设备，但是两层数据链路层没办法逻辑成一条线，这样成环路，所以需要STP来避免环路。</p>]]></content>
      
      
      <categories>
          
          <category> Network - Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Tth-Trunk </tag>
            
            <tag> 堆叠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WLAN</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/WLAN/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/WLAN/</url>
      
        <content type="html"><![CDATA[<h3 id="AP-AC组网方式"><a href="#AP-AC组网方式" class="headerlink" title="AP - AC组网方式"></a>AP - AC组网方式</h3><h4 id="AP和AC间的组网分为：二层组网和三层组网"><a href="#AP和AC间的组网分为：二层组网和三层组网" class="headerlink" title="AP和AC间的组网分为：二层组网和三层组网"></a>AP和AC间的组网分为：二层组网和三层组网</h4><p>二层组网</p><p><img src="/../../../../images/image-20240512092151203.png" alt="image-20240512092151203"></p><p>二层组网：“零配置”</p><p>AP和AC在二层网络，属于同一广播域，DHCP先给AP分配IP，然后AP发广播，寻找AC的地址，然后AC对他统一管理</p><p>三层组网</p><p><img src="/../../../../images/image-20240512092204831.png" alt="image-20240512092204831"></p><p>在三层网络，AC和AP之间不属于同一广播域，发广播是转发不到AP，需要AP单播给AC，而是DHCP的option 43功能起作用，在给AP分配IP同时并告知AC的IP</p><h3 id="AC连接方式"><a href="#AC连接方式" class="headerlink" title="AC连接方式"></a>AC连接方式</h3><p>AC连接方式：直连式组网和旁挂式组网</p><p>直连式</p><p><img src="/../../../../images/image-20240512102444055.png" alt="image-20240512102444055"></p><p>AC充当：AC和汇聚交换机</p><p>缺点：AC发生故障，整个网就瘫痪</p><p>旁挂式组网</p><p><img src="/../../../../images/image-20240512102508658.png" alt="image-20240512102508658"></p><p>这里架构，对以前的架构没影响，AC出故障，也不会对网络造成很大影响(对无线网造成影响，有线网没影响)</p><h3 id="数据转发方式"><a href="#数据转发方式" class="headerlink" title="数据转发方式"></a>数据转发方式</h3><p>隧道转发方式</p><p><img src="/../../../../images/image-20240512103005206.png" alt="image-20240512103005206"></p><p>将数据封装到隧道里再发送，送到AC，在AC再解封装，然后AC再把他发送出去；</p><p>注意：经过交换机，但不暴露</p><p>适用的场景：底层设备链路太过凌乱，这时候AC可能合适，因为选用AC，就不需要你在交换机梳理清楚，因为在交换机不会暴露出来，他会通过隧道的方式送到AC那，再暴露出来</p><p>缺点：</p><p>1、AC压力很大，业务流量和管理流量都需要AC处理</p><p>2、数据有迂回的流量，AP-交换机-路由器-AC-路由器-防火墙</p><p>优点：</p><p>1、安全性高一定，可以在隧道做DTS加密</p><p>2、可以屏蔽底层的vlan</p><p>直接转发方式</p><p><img src="/../../../../images/image-20240512103023669.png" alt="image-20240512103023669"></p><p>把数据送到最近的交换机，然后再转发出去。</p><p>配置方面：</p><p>直接转发方式</p><p>业务数据流量：STA-Switch-Router-Firewall</p><p>STA发送数据，AP会打上业务标签，送到最近的交换机。然后这时候需要在AP~Switch之间放行业务vlan</p><p>隧道转发方式</p><p>业务数据流量：STA-Switch-AC-Switch-Router-Firewall</p><p>STA发送数据，AP会打上业务标签，AP继续做隧道封装，然后把业务封装遮盖，暂时不会暴露，AP会把数据一路送到AC，AC解开隧道头部，业务数据才暴露。所以需要再AC和router放心业务vlan则可以了</p><h3 id="无线侧组网"><a href="#无线侧组网" class="headerlink" title="无线侧组网"></a>无线侧组网</h3><h4 id="BSS-SSID-BSSID"><a href="#BSS-SSID-BSSID" class="headerlink" title="BSS&#x2F;SSID&#x2F;BSSID"></a>BSS&#x2F;SSID&#x2F;BSSID</h4><p><img src="/../../../../images/image-20240512103126412.png" alt="image-20240512103126412"></p><p>ssid就相当于，wifi的名字</p><p>bssid就相当于，wifi的mac地址，身份标识</p><p>bss，就说ap所覆盖的范围</p><h4 id="VAP"><a href="#VAP" class="headerlink" title="VAP"></a>VAP</h4><p><img src="/../../../../images/image-20240512103304177.png" alt="image-20240512103304177"></p><p>VAP，就是相当于一个wifi分成多个wifi，例如办公室专用，教室专用</p><h4 id="ESS-ESSID"><a href="#ESS-ESSID" class="headerlink" title="ESS&#x2F;ESSID"></a>ESS&#x2F;ESSID</h4><p><img src="/../../../../images/image-20240512103442195.png" alt="image-20240512103442195"></p><p>举个例子</p><p>其中一家肯德基(SSID)，开在万达广场的一楼A3店铺(BSSID)</p><p>然后肯德基(ESSID)也是一个品牌，全国都有，万达广场只是其中一个分店。</p><h3 id="WLAN工作流程"><a href="#WLAN工作流程" class="headerlink" title="WLAN工作流程"></a>WLAN工作流程</h3><p><img src="/../../../../images/image-20240512153044724.png" alt="image-20240512153044724"></p><p>步骤：</p><p><strong>1、AP上线</strong></p><p>​AP获取IP地址并发现AC，与AC建立连接</p><p><strong>2、WLAN业务配置下发</strong></p><p>​AC将WLAN业务配置下发到AP生效</p><p><strong>3、STA接入</strong></p><p>​STA搜索到AP发射的SSID并连接、上线、接入网络</p><p><strong>4、WLAN业务数据转发</strong></p><p>​WLAN网络开始转发业务数据</p><hr><h4 id="AP上线"><a href="#AP上线" class="headerlink" title="AP上线"></a>AP上线</h4><p><strong>AP获取IP地址(为了能够与AC通信，WLAN网络才能够正常通信)</strong></p><p>AP获取IP地址的方式包括以下：</p><p>​静态方式：登录到AP设备上手工配置IP地址。</p><p>​DHCP方式：通过配置DHCP服务器，使AP作为DHCP客户端向DHCP服务器请求IP地址。</p><p>典型方案：</p><p>​部署专门的DHCP Server为AP分配IP地址</p><p>​使用AC的DHCP服务为AP分配IP地址</p><p>​使用网络中的设备，例如核心交换机为AP分配IP地址</p><p><img src="/../../../../images/image-20240512153831983.png" alt="image-20240512153831983"></p><p><strong>CAPWAP隧道建立</strong></p><p>AC通过CAPWAP隧道来实现对AP的集中管理和控制</p><p>Step 1：Discovery阶段(AP发现AC阶段)</p><p>AP通过发送Discovery Request报文，找到可用的AC。</p><p>AP发现AC有两个方式：</p><p>​静态方式：AP上预先配置AC的静态IP地址列表</p><p>​动态方式：DHCP方式，DNS方式和广播方式</p><p>Step 2：建立CAPWAP隧道阶段</p><p>AP与AC关联，完成CAPWAP隧道建立。包括数据隧道和控制隧道:<br>    数据隧道: AP接收的业务数据报文经过CAPWAP数据隧道集中到AC上转发。</p><p>​控制隧道: 通过CAPWAP控制隧道实现AP与AC之间的管理报文的交互。</p><p><img src="/../../../../images/image-20240512154651238.png" alt="image-20240512154651238"></p><p><strong>AP接入控制</strong></p><p><img src="/../../../../images/image-20240512154740205.png" alt="image-20240512154740205"></p><p><strong>AP的版本升级(可选)</strong></p><p><img src="/../../../../images/image-20240512154834266.png" alt="image-20240512154834266"></p><p><strong>CAPWAP隧道维持</strong></p><p><img src="/../../../../images/image-20240512155020581.png" alt="image-20240512155020581"></p><h4 id="WLAN业务配置下发"><a href="#WLAN业务配置下发" class="headerlink" title="WLAN业务配置下发"></a>WLAN业务配置下发</h4><p>AC向AP发送Configuration Update Request请求消息，AP回应Configuration Update Response消息，AC再将AP的业务配置信息下发给AP.</p><p><img src="/../../../../images/image-20240512155809797.png" alt="image-20240512155809797"></p><p><strong>配置模板</strong></p><p>针对WLAN的不同功能和特性设计了各种类型的模板(WLAN模板)</p><p><img src="/../../../../images/image-20240512155333007.png" alt="image-20240512155333007"></p><p><strong>VAP模板</strong></p><p><img src="/../../../../images/image-20240512155410767.png" alt="image-20240512155410767"></p><h4 id="STA接入"><a href="#STA接入" class="headerlink" title="STA接入"></a>STA接入</h4><p>CAPWAP隧道建立完成后，用户就可以接入无线网络。STA接入过程分为六个阶段:扫描阶段、链路认证阶段、关联阶段、接入认证阶段、DHCP、用户认证。</p><p><strong>802.11协议定义的帧类型</strong></p><p><img src="/../../../../images/image-20240512160334490.png" alt="image-20240512160334490"></p><p>管理帧</p><p>​管理帧负责监督，主要用来加入或退出无线网络以及处理基站之间连接的转移事宜。</p><p>控制帧</p><p>​控制帧通常与数据帧搭配使用，负责区域的清空信道的取得以及载波监听的维护，并在收到数据时予以正面的应答，借此促进工作站间数据传输的可靠性。</p><p>​简单地说，维护数据发送</p><p>数据帧</p><p>​数据帧好比802.11的运输工具，负责在工作站之间传输数据。</p><p>802.11关键报文 - 管理帧</p><p><img src="/../../../../images/image-20240512160611540.png" alt="image-20240512160611540"></p><p>Beacon信标帧，是AP主动放出来，是给STA被动扫描</p><p>检测请求帧、检测应答帧，是STA主动找AP探测，AP响应</p><p>举个例子：</p><p>周围wifi信号，不是自己的wifi，为啥能够看到，是AP主动放出来。理解为这就是信标帧。</p><p>某家的wifi设置了隐藏wifi，需要主动去检测，输入信息，发现该IP然后再接入。</p><p>802.11关键报文 - 控制帧</p><p><img src="/../../../../images/image-20240512161611802.png" alt="image-20240512161611802"></p><p>作用：维护终端发送数据</p><p>为什么需要维护？</p><p>因为，无线不像有线一样，监听(CSMA&#x2F;CA)到信道空闲就发送数据，无线还需要预约信道(RTS)；然后AP会给你一个响应(CTS),允许你发送，你才能发送；数据发完之后，需要发一个ACK确认包(无线空口传输是不可靠传输，所以想要保证可靠传输，用ACK确认机制)，</p><p>为什么需要RTS和CTS？</p><p><img src="/../../../../images/image-20240512171411416.png" alt="image-20240512171411416"></p><p>STA-1通过无线空口扫描到AP，然后STA-2扫AP也是空闲的，因为STA-2没有收到STA-1的信号，所以STA-2认为AP是空闲的；</p><p>然后两个人STA，接入AP，产生冲突。</p><p>如果有RTS,CTS就不会发送冲突。</p><p>STA-1使用无线空口之前，会先发送RTS，AP收到后，但STA-2没有收到，但没啥影响，AP发送响应一个CTS，AP覆盖的范围是整个区域(虚线)，1，2肯定能够收到，虽然STA-2没有收到RTS，但收到CTS，STA-2就知道该AP已经被人使用； 并且AP同意STA-1使用；</p><p>STA-2收到CTS后，CTS会携带MAV向量(网络大概使用多长时间)，就会保持”静默”若干时间，此期间不会使用该AP，等时间过后，再次监听无线空口有没有使用</p><hr><p><strong>扫描阶段</strong></p><p>分为：</p><p>携带有指定SSID的主动扫描方式<br>携带空SSID的主动扫描方式</p><p><img src="/../../../../images/image-20240512164502780.png" alt="image-20240512164502780"></p><p><strong>链路认证阶段</strong></p><p>常用安全策略</p><p><img src="/../../../../images/image-20240512164911900.png" alt="image-20240512164911900"></p><p>802.11链路定义两种认证机制：</p><p>开放系统认证(多数使用这个)、共享密钥认证</p><p>开放系统认证：即不认真，任意STA都可以认证成功。</p><p>链路一般不做认证。</p><p><strong>关联阶段</strong></p><p><img src="/../../../../images/image-20240512165244007.png" alt="image-20240512165244007"></p><p>AC来决策，是否允许STA接入</p><p><strong>接入认证阶段</strong></p><p>接入认证即<strong>对用户进行区分</strong>，并在用户访问网络之前限制其访问权限。相对于链路认证，接入认证安全性更高。</p><p>主要包含: PSK认证(密码)和802.1X认证(用户+密码)。</p><p><img src="/../../../../images/image-20240512165418816.png" alt="image-20240512165418816"></p><p><strong>STA地址分配</strong></p><p>AP给STA分配地址</p><p>如果STA是通过DHCP方式获取IP地址，可以用AC设备或汇聚交换机作为DHCP服务器为STA分配IP地址。一般情况下使用汇聚交换机作为DHCP服务器。</p><p><img src="/../../../../images/image-20240512165717088.png" alt="image-20240512165717088"></p><p><strong>用户认证阶段</strong></p><p>到达这一阶段前提是：底层全部打通</p><p>用户认证是一种“端到端”的安全结构，包括:802.1X认证、MAC认证和Portal认证。</p><p><img src="/../../../../images/image-20240512165851352.png" alt="image-20240512165851352"></p><p>举个例子：例如高铁&#x2F;麦当劳等上要使用wifi，连接wifi时，自动弹出一个网页，让你填写手机验证，然后才能使用。</p><h4 id="WLAN业务数据转发"><a href="#WLAN业务数据转发" class="headerlink" title="WLAN业务数据转发"></a>WLAN业务数据转发</h4><p>CAPWAP中的数据包括控制报文(管理报文)和数据报文。控制报文是通过CAPWAP的控制隧道转发的，</p><p>转发的方式：</p><p>隧道转发(集中转发)、直接转发(本地转发)</p><h3 id="案例：旁挂二层组网隧道转发"><a href="#案例：旁挂二层组网隧道转发" class="headerlink" title="案例：旁挂二层组网隧道转发"></a>案例：旁挂二层组网隧道转发</h3><p><img src="/../../../../images/image-20240512180631440.png" alt="image-20240512180631440"></p><p><img src="/../../../../images/image-20240512181125742.png" alt="image-20240512181125742"></p><p>access模式和trunk模式的选择</p><p>直接转发模式</p><p>S1~AP之间使用trunk，STA发送数据到AP，AP会打上业务标签(vlan101),但是隧道模式转发，则再此基础上打赏隧道标签，遮盖主vlan101，而AP的信息会再交换机S1才打上管理标签(vlan100),</p><p>所以S1的g0&#x2F;0&#x2F;1可能会到带标签的或不带标签的数据包，那么使用trunk</p><p>隧道转发模式</p><p>S1~AP之间使用access，因为到达S1的g0&#x2F;0&#x2F;1口，ap的信息才打上管理标签。</p><p>AP-S1-S2-AC，都要放行管理标签的数据帧(vlan100),而</p><p>而s2-ac之间需要放行，vlan100，vlan101</p><p>配置网络互通</p><p><img src="/../../../../images/image-20240512181157756.png" alt="image-20240512181157756"></p><p>配置AP上线</p><p><img src="/../../../../images/image-20240512182756306.png" alt="image-20240512182756306"></p><p><img src="/../../../../images/image-20240512182814645.png" alt="image-20240512182814645"></p><p>配置WLAN业务参数</p><p><img src="/../../../../images/image-20240512182845799.png" alt="image-20240512182845799"></p><p><img src="/../../../../images/image-20240512182910236.png" alt="image-20240512182910236"></p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><h4 id="信号覆盖设计原则"><a href="#信号覆盖设计原则" class="headerlink" title="信号覆盖设计原则"></a>信号覆盖设计原则</h4><p><img src="/../../../../images/image-20240512183043947.png" alt="image-20240512183043947"></p><h4 id="信道设计原则"><a href="#信道设计原则" class="headerlink" title="信道设计原则"></a>信道设计原则</h4><p>确定当地可用信道</p><p>以中国为例，网桥回传用的5G频段可选信道:149、153、157、161、165。</p><p>不同国家或地区，可用信道不同，有些地区会预留一些信道，所以规划前必须确认清楚。</p><p>避免同频干扰</p><p>多楼层同时考虑周边和上下楼AP信道错开。</p><p>如信道实在无法错开，通常降低功率来减少重叠区域范围。</p><h4 id="AP布防"><a href="#AP布防" class="headerlink" title="AP布防"></a>AP布防</h4><p>信道规划-室内放装AP</p><p>​减少跨层</p><p>​干扰避免信道冲突</p><p>​统一规划信道</p><p><img src="/../../../../images/image-20240512183541437.png" alt="image-20240512183541437"></p><h4 id="供电和走线设计"><a href="#供电和走线设计" class="headerlink" title="供电和走线设计"></a>供电和走线设计</h4><p>POE供电(推荐)<br>    由POE交换机负责AP的数据传输和供电:网线或光电混合缆;</p><p>本地供电<br>    非POE交换机负责AP的数据传输，独立电源负责AP的供电；</p><p>POE模块供电<br>    由POE适配器负责AP的数据传输和供电。</p><p><img src="/../../../../images/image-20240512183848686.png" alt="image-20240512183848686"></p><p>AP到POE交换机的网线长度不超过80米;</p><p>AP到交换机的光电混合缆长度不超过200米;</p><p>网线&#x2F;光电混合缆在AP点位处长度需要预留5米左右，以备后期调整</p><p>远离强电强磁；</p><p>提前与用户确认，避免因物业、美观等其他原因，用户不同意施工</p><p>馈线长度越长，天线覆盖范围内的信号强度越差。请使用尽量短的馈线，不建议使用15 m馈线</p><p><img src="/../../../../images/image-20240512184058508.png" alt="image-20240512184058508"></p><h4 id="室内放装AP安装方式及原则"><a href="#室内放装AP安装方式及原则" class="headerlink" title="室内放装AP安装方式及原则"></a>室内放装AP安装方式及原则</h4><p>吸顶安装(推荐):安装高度低于6米则使用全向天线AP，高于6米建议使用定向天线AP;</p><p>挂壁安装:不便吸顶安装时考虑;</p><p>支架安装:是不便吸顶或挂墙情况下的临时安装方式，通常用于临时展会场景。</p><h3 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h3><p>某企业生产网络拓扑如图2-1所示，该网络采用静态路由配置，交换机A和交换机B配置VRRP，车间1和车间2部署了多台AGV，通过无线Wi-Fi向AGV设备下发指令。</p><p>AGV是移动机器人(用来搬运货物)</p><p><img src="/../../../../images/1703689913207439.png" alt="image.png"></p><p>简要说明AGV可靠性受Wi-Fi信号影响，可能有哪些因素。<br>1.信道规划不合理，存在同频干扰</p><p>2.AP覆盖重叠区域过大，存在干扰</p><p>3.AP覆盖不足，信号差，存在盲区</p><p>4.周边存在其它无线信号源干扰</p><p>5.存在遮挡，导致信号衰减过大</p><p>6.AP间漫游中断</p><p>根据网络安全的需要，无线校园网要求全网认证接入，其中台式电脑、笔记本、手机等智能终端，从兼容性角度考虑应优先选用(<strong>Portal</strong>)认证方式;打印机、门禁等非智能终端应该选用(<strong>MAC</strong>)认证方式。<br>图2-1中，数据业务流量通过AC与AP建立的隧道进行转发时，该转发模式为(<strong>隧道转发</strong>);不经过AC转发由AP经接入交换机到核心交换机传输至上层网络时，该转发模式为(<strong>直接转发</strong>)。<br>学校的新一代无线网络采用Wifi6技术，要求兼容仍工作在2.4G的老旧终端，Wifi6 AP的部署密度较大，为减少无线AP在2.4G模式下信道之间的干扰，信道之间至少应间隔(<strong>5</strong>)个信道。<br>无线网络实施后，校园网络在线用户数大幅增长。原楼宇汇聚为千兆上联，高峰时期上行链路负载已经100%，经常有丢包现象，在不更换设备的前提下，可以通过(<strong>增加链路并作聚合</strong>)解决。</p><p>相较于以旁路方式部署，将AC直连部署存在的问题是(<strong>增加AC压力，并且出故障影响全网通信</strong>);相较于该网络规划中，于部署在核心层，将AC部署在接入层存在的问题是(<strong>可靠性下降，流量不清晰</strong>)。</p><p>2.在不增加网络设备的情况下，防止外网用户对本网络进行攻击，隐藏内部网NAT策略通常配置在(<strong>Router</strong>)。</p><p>3.某用户通过手机连接该网络的WIFI信号，使用WEB页面进行认证后上网，无线网络使用的认证方式是(<strong>Portal</strong>)认证。</p><p>2.若在大楼内相邻的办公室共用1台AP会造成信号衰减，造成信号衰减的是<strong>障碍物</strong></p><p>3.在网络规划中，对AP供电方式可以采取(<strong>POE</strong>)供电或DC电源适配器供电。</p><p>4.不考虑其他因素的情况下，若室内AP区域信号场强&gt;-60dBm，停车场AP区域的场强&gt;-70dBm，则用户在(<strong>室内</strong>)区域的上网体验好。</p><p>5、组播报文对无线网络空口的影响主要是<strong>会以低速报文形式发送，易造成无线空口拥堵</strong></p><p>6、网络AP部署再每一间宿舍的原因是：<strong>提升信号质量</strong></p><p>在①处部署(1)设备，实现各会议室的无线网络统一管理，无缝漫游:在②处部署(2)设备，实现内部用户使用用户名和密码认证登录，外来访客通过扫描二维码或者手机短信验证登录无线网络;在③处部署(3)设备，实现无线AP的接入和供电;大型会议室部署(4)设备，实现高密度人群的无线访问;在小型会议室借助86线盒部署(5)设备，实现无线访问。(1)~(5)备选答案:</p><p>A、面板式AP B、高密吸顶式AP C、无线控制器 D、无线认证系统A、E、无线路由器 F、普遍吸顶式AP G、普通交换机 H、POE交换机</p><p>答案 C D H B A</p><p>在核心交换机上配置(6)，可以实现无线网络和办公区网络、服务器区网络逻辑隔离;在④处部署(7)设备，可以对所有用户的互联网访问进行审计和控制，阻止并记录非法访问:在⑤处部署(8)设备，实现服务器区域的边界防护，防范来自无线区域和办公区域的安全威胁;在路由器上配置基于(9)地址的策略路由，实现无线区域用户通过运营商1访问互联网，办公区域和服务器区域通过运营商2访问互联网。</p><p>6.VLAN 7.上网行为管理 8.防火墙 9.源</p><p>外面对里面的入侵检测&#x2F;防御，就是IDS&#x2F;IPS</p><p>部分无线用户反映WLAN无法连接，网络管理员登录AC查看日志，日志显示AP-03掉线无法管理，造成该故障可能的原因包括:(1)(2)、(3)(1)~(3)备选答案(每空限选一项，不得重复)</p><p>A.AP与AC的连接断开<br>B.AP断电<br>C.AP未认证<br>D.由于自动升级造成AC、AP版本不匹配<br>E.AC与核心交换机连接断开<br>F.该AP无线接入用户数达到上限</p><p>答案：ABD</p><p>常见的无线网络安全隐患有IP地址欺骗、数据泄露、(9)、网络通信被窃(8)听等;为保护核心业务数据区域的安全网络管理员在设备①处部署(10)实现核心业务区域边界防护;在设备②处部署(11)实现无线用户的上网行为管控;在设备③处部署(12)分析检测网络中的入侵行为;为加强用户安全认证，配置基于(13)的RASIUS认证。<br>(8)~(9)备选答案(每空限选一项，选项不能重复)</p><p>A.端口扫描B.非授权用户接入C.非法入侵D. sql注入攻击</p><p>(13)备选答案:<br>A.IEEE 802.11<br>B.IEEE 802.1x</p><p>8.B 9.C 10.防火墙 11.上网行为管理!12.IDS 13.B</p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
            <tag> WLAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局域网和城域网</title>
      <link href="/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%92%8C%E5%9F%8E%E5%9F%9F%E7%BD%91/"/>
      <url>/2024/06/01/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%92%8C%E5%9F%8E%E5%9F%9F%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="局域网和城域网"><a href="#局域网和城域网" class="headerlink" title="局域网和城域网"></a>局域网和城域网</h1><h2 id="局域网基础"><a href="#局域网基础" class="headerlink" title="局域网基础"></a>局域网基础</h2><h3 id="局域网和城域网体系架构IEEE-标准"><a href="#局域网和城域网体系架构IEEE-标准" class="headerlink" title="局域网和城域网体系架构IEEE(标准)"></a>局域网和城域网体系架构IEEE(标准)</h3><p>比较重要的有两种：</p><p>802.3和802.11应用最为广泛。</p><p>802.3 其实是以太网标准(有线)</p><p>802.11 无线WIFI标准</p><h3 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h3><p>局域网的拓扑结构主要有:</p><p><img src="/../../../../images/image-20240601152621565.png" alt="image-20240601152621565"></p><h2 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h2><h3 id="CSMA-CD是什么？"><a href="#CSMA-CD是什么？" class="headerlink" title="CSMA&#x2F;CD是什么？"></a>CSMA&#x2F;CD是什么？</h3><p>是一种常用于局域网（LAN）中的冲突检测技术。</p><p>也是对总线型、星型和树型拓扑访问控制协议。</p><p>载波侦听多路访问&#x2F;冲突检测。</p><h3 id="CSMA基本原理"><a href="#CSMA基本原理" class="headerlink" title="CSMA基本原理"></a>CSMA基本原理</h3><p>在发送数据之前，先监听信道上是否有人在发送。</p><p>若有，说明信道正忙，否则说明信道是空闲的。</p><p>然后根据<strong>预定的策略</strong>决定：</p><p>(1) 若信道空闲，是否立即发送。</p><p>(2) 若信道忙，是否继续监听。</p><p>如果连续发送<strong>16次</strong>碰撞后，认为<strong>网络繁忙或故障</strong>，不再尝试发送。</p><h3 id="CSMA-CD三种监听算法"><a href="#CSMA-CD三种监听算法" class="headerlink" title="CSMA&#x2F;CD三种监听算法"></a>CSMA&#x2F;CD三种监听算法</h3><p>(1)非坚持型监听算法:后退随机时间</p><p>由于随机时延后退，从而<strong>减少了冲突的概率</strong>。问题是因为后退而使信道闲置一段时间，这使<strong>信道的利用率降低</strong>，而且<strong>增加了发送时延</strong></p><p>(2)1-坚持型监听算法:继续监听，不等待</p><p>有利于抢占信道，减少信道空闲时间。但是，多个站同时都在监听信道时必然会发生冲突。</p><p><strong>冲突概率和利用率都高(双高)</strong></p><p>(3)P-坚持型监听算法</p><p>若信道空闲，以概率P发送，以**概率(1-P)**延迟一个时间单位，P大小可调整</p><h3 id="冲突检测原理"><a href="#冲突检测原理" class="headerlink" title="冲突检测原理"></a>冲突检测原理</h3><p>载波监听<strong>只能减小冲突的概率，不能完全避免冲突</strong>。当两个帧发生冲突后，若继续发送，将会浪费网络带宽。为了改进带宽利用率，发送站应采取边发边听的冲突检测方法，即:</p><p>(1)发送期间同时接收，并把接收的数据与站中存储的数据进行比较。</p><p>(2)若比较结果一致，说明没有冲突，重复(1)。</p><p>(3)若比较结果不一致，说明<strong>发生了冲突,立即停止发送****，并发送一个简短的</strong>干扰信号(Jamming)****,使所有站都停止发送。</p><p>(4)发送Jamming信号后，<strong>等待一段随机长的时间</strong>，重新监听，再试着发送。</p><h2 id="二进制指数退避算法"><a href="#二进制指数退避算法" class="headerlink" title="二进制指数退避算法"></a>二进制指数退避算法</h2><p>工作原理：</p><p>(1)检测到冲突后，马上停止发送数据，并等待随机时间再发送数据。<br>(2)等待的随机时间&#x3D;τ<em>Random[0,1,..2k-1],其中Random表示随机函数。其中τ是基本退避时间，可以看作固定值。k&#x3D;min[重传次数，10]，如果重传16次后，还不能正常发送数据，认为网络拥塞或信道故障，不再尝试重传。根据公式，如果重传12次后，k&#x3D;min[12，10]&#x3D;10，那么可能等待的时间是τ</em>Random[0，1023],一共有1024种可能。每次站点等待的时间都是随机数，故<strong>后一次退避时间不一定比前一次长</strong>。重传次数越多，退避窗口(即Random取值)越大，从而<strong>降低冲突概率</strong>。<br>如果连续发生<strong>16次</strong>碰撞后，认为网络繁忙或故障，不再尝试发送。</p><p>例题1：</p><p>采用CSMA&#x2F;CD进行介质访问，两个站点连续冲突3次后再次冲突的概率(63)。<br>A.1&#x2F;2 B.1&#x2F;4 C.1&#x2F;8 D.1&#x2F;16<br>【参考答案】C<br>【summer解析】本题考查二进制指数退避算法，原理如下:<br>(1)检测到冲突后，马上停止发送数据，并等待随机时间再发送数据。<br>(2)等待的随机时间&#x3D;τ<em>Random[0,1,…2k-1],其中Random表示随机函数。</em></p><p>注:T是基本退避时间，可以看作固定值，k&#x3D;min[重传次数，10],如果重传16次后，还不能正常发送数据，认为网络拥塞，不再尝试。</p><p>冲突1次后，k&#x3D;min[1,10]&#x3D;1,那么等待时间τ<em>Random[0,1],有2个可选数字。<br>冲突2次后，k&#x3D;min[2,10]&#x3D;2,那么等待时间τ</em>Random[0,1,2,3],有4个可选数字。<br>冲突3次后，k&#x3D;min[3,10]&#x3D;3,那么等待时间τ*Random[0,1,2,3,4,5,6,7],有8个可选数字<br>即两个站点连续冲突3次后再次冲突的概率是1&#x2F;8。<br>也可以得出简化公式:冲突概率为1&#x2F;2n( n表示已经发生冲突的次数，n≤10)</p><p>例题2</p><p>以太网采用的CSMA&#x2F;CD协议，当冲突发生时要通过二进制指数后退算法计算后退时延，关于这个算法，以下论述中错误的是(62)。 A<br>A.冲突次数越多，后退的时间越短<br>C.后退时延的平均值与负载大小有关<br>B.平均后退次数的多少与负载大小有关<br>D.重发次数达到一定极限后放弃发送</p><p>原因：后退的时间是τ*Random[0，1023],随机时间</p><p>负载大小就是网络的繁忙程度。</p><p>例题3</p><p>以下关于二进制指数退避算法的描述中，正确的是(64)。C</p><p>A.每次站点等待的时间是固定的，即上次的2倍<br>B.后一次退避时间一定比前一次长<br>C.发生冲突不一定是站点发生了资源抢占<br>D.通过扩大退避窗口杜绝了再次冲突</p><p>退避窗口—-即Random取值</p><h2 id="最小帧长计算"><a href="#最小帧长计算" class="headerlink" title="最小帧长计算"></a>最小帧长计算</h2><p>最小帧长公式： Lmin &#x3D; 2R * d&#x2F;v</p><p>R：网络数据速率</p><p>d：最大距离</p><p>v：传播速度(光纤是30km&#x2F;s，电缆是20km&#x2F;s)</p><p>L：最小数据帧的长度</p><p>推导</p><p><img src="/../../../../images/image-20240327164422570-17116151954542.png" alt="image-20240327164422570"></p><p>不冲突条件：</p><p>发送时间 &gt;&#x3D; 传送时间 + 确认时间</p><p>L&#x2F;R  &gt;&#x3D;  2d&#x2F;v  + 0</p><p>2d&#x2F;v：因为两地发送过程时间是一样的。</p><p>0：因为确认帧是小帧(64),太小，忽略不计</p><p>例题：</p><p>采用CSMA&#x2F;CD协议的基带总线，段长为1000M，数据速率为10Mb&#x2F;s，信号传播速度为200m&#x2F;us则该网络上的最小帧长应为(57)比特。 B<br>A.50<br>B.100<br>C.150<br>D.200</p><p>解释：</p><p>L&#x2F;R &#x3D; 2 * d&#x2F;v</p><p>L&#x2F;10M&#x2F;b &#x3D; 2 * 1000M&#x2F;200m&#x2F;us</p><p>转换单位</p><p>L &#x3D;  2R * d&#x2F;v</p><p>L &#x3D; 2 * (10* 10^6bit&#x2F;s) * 1000M&#x2F;(200 * 10^6m&#x2F;s)</p><h2 id="以太网帧帧与物理层规范"><a href="#以太网帧帧与物理层规范" class="headerlink" title="以太网帧帧与物理层规范"></a>以太网帧帧与物理层规范</h2><h3 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h3><p><img src="/../../../../images/image-20240327173105749-17116152080235.png" alt="image-20240327173105749"></p><p>注意: 长度是指类型字段</p><p>前面7+1字节用于时钟同步，不算入帧长。<br>数据(mtu)46-1500字节，不够至少填充到46字节。<br>校验位4字节，CRC循环冗余校验 32位。<br>最小帧长<strong>64字节</strong>:  6+6+2+46+4&#x3D;64。<br>最大帧长<strong>1518字节</strong>:  6+6+2+1500+4&#x3D;1518.</p><p>以太网最小利用率： 48&#x2F;64</p><p>以太网最大利用率： 1500&#x2F;1518</p><h3 id="以太网报文封装"><a href="#以太网报文封装" class="headerlink" title="以太网报文封装"></a>以太网报文封装</h3><p><img src="/../../../../images/image-20240327174627166-17116152189748.png" alt="image-20240327174627166"></p><p>例题1：</p><p>以太网可以传送最大的TCP段为(21)字节。</p><p>A.1480</p><p>B.1500<br>C.1518<br>D.2000<br>【参考答案】A<br>以太网帧数据部分长度最大为1500B，上层IP头部至少为20B，因此传输层最大为1480B。</p><p><img src="/../../../../images/image-20240327175057743-171161523184911.png" alt="image-20240327175057743"></p><h3 id="802-3以太网-10M"><a href="#802-3以太网-10M" class="headerlink" title="802.3以太网(10M)"></a>802.3以太网(10M)</h3><p>物理介质命名规范</p><p>&lt;传输速率Mbps&gt;&lt;信号方式&gt;&lt;最大传输距离(百米)或介质类型&gt;</p><p>100BASET  </p><p>100Mbps   BASE表示基带传输(数字信号) </p><p>T表示双线，F表示光纤，如果有数字，例如5表示500米</p><h3 id="快速以太网802-3u-100M"><a href="#快速以太网802-3u-100M" class="headerlink" title="快速以太网802.3u(100M)"></a>快速以太网802.3u(100M)</h3><p>UTP ：非屏蔽双绞线  STP：屏蔽双绞线</p><p><img src="/../../../../images/image-20240328173651049.png" alt="image-20240328173651049"></p><h3 id="千兆以太网-1000M"><a href="#千兆以太网-1000M" class="headerlink" title="千兆以太网(1000M)"></a>千兆以太网(1000M)</h3><p>千兆以太网两个标准<strong>802.3z和802.3ab</strong>(100BASE-T)；</p><p><strong>千兆需要4对双绞线</strong>，达到100米传输</p><p>100BASE-LX标准可以使用<strong>单模和多模</strong>光纤传输</p><p>千兆以太网编码方法： 4B&#x2F;5B或8B&#x2F;9B</p><p><img src="/../../../../images/image-20240328174018423.png" alt="image-20240328174018423"></p><h3 id="万兆以太网802-3ae-10G"><a href="#万兆以太网802-3ae-10G" class="headerlink" title="万兆以太网802.3ae(10G)"></a>万兆以太网802.3ae(10G)</h3><p>万兆以太网标准：IEEE802.3ae，支持10G速率，可以用光纤或双绞线传输。</p><p>万兆以太网基本应用于点到点线路，<strong>不再共享带宽，没有冲突检测</strong></p><p><img src="/../../../../images/image-20240328174518700.png" alt="image-20240328174518700"></p><h2 id="虚拟局域网VLAN-上午-下午"><a href="#虚拟局域网VLAN-上午-下午" class="headerlink" title="虚拟局域网VLAN(上午+下午)"></a>虚拟局域网VLAN(上午+下午)</h2><h3 id="VLAN是什么？"><a href="#VLAN是什么？" class="headerlink" title="VLAN是什么？"></a>VLAN是什么？</h3><p>全称：Virtual Local Area Network，VLAN</p><p>根据管理功能，组织机构等对交换局域网进行分段而形成逻辑网络。</p><p>不同VLAN通信必须经过三层设备: 路由器,三层交换机,防火墙等。</p><p>虚拟局域网工作站可以不属于同一物理网段，任何交换端口都可以分配给某个VLAN，属于同一VLAN的所有端口构成一个广播域。</p><p>冲突域和广播域，<strong>一个中继器和集线器是一个冲突域,一个VLAN为一个广播域，交换机的一个接口为一个冲突域</strong>。</p><hr><p>为什么交换机的一个接口为一个冲突域，而一个中继器和集线器是一个冲突域？</p><p>中继器和集线器：</p><p>当一个设备向集线器发送数据时，集线器会将这个数据复制并发送到所有其他连接的设备上。</p><p>如果两个设备同时尝试发送数据，它们的数据帧就会在集线器上碰撞，这个碰撞会影响到所有连接到集线器的设备，因此集线器是一个冲突域</p><p>交换机：</p><p>每个交换机端口都是一个独立的冲突域。</p><p>如果一个设备通过交换机发送数据，只有目标设备所在的端口会受到影响。其他端口上的数据传输不会受到这个碰撞的影响</p><hr><h3 id="冲突域"><a href="#冲突域" class="headerlink" title="冲突域"></a>冲突域</h3><p>冲突域是指连接在同一共享介质上的所有节点的集合，<strong>冲突域内所有节点竞争同一带宽</strong>，一个节点发出的报文(无论是单播、组播、广播)，其余节点都可以收到。</p><p><img src="/../../../../images/image-20240328175932211.png" alt="image-20240328175932211"></p><h3 id="广播域"><a href="#广播域" class="headerlink" title="广播域"></a>广播域</h3><p>广播报文所能到达的整个访问范围称为二层广播域，简称广播域，<strong>同一广播域内的主机都能收到广播报文</strong></p><p><img src="/../../../../images/image-20240328180335886.png" alt="image-20240328180335886"></p><p><img src="/../../../../images/image-20240328180826716.png" alt="image-20240328180826716"></p><h3 id="交换机VLAN划分"><a href="#交换机VLAN划分" class="headerlink" title="交换机VLAN划分"></a>交换机VLAN划分</h3><p>静态划分VLAN：<strong>基于交换机端口</strong></p><p>动态划分VLAN：<strong>基于MAC地址、基于策略、基于网络层协议，基于网络层地址</strong></p><p><img src="/../../../../images/image-20240328181027509.png" alt="image-20240328181027509"></p><h3 id="VLAN划分配置"><a href="#VLAN划分配置" class="headerlink" title="VLAN划分配置"></a>VLAN划分配置</h3><h4 id="静态划分VLAN"><a href="#静态划分VLAN" class="headerlink" title="静态划分VLAN"></a>静态划分VLAN</h4><p><img src="/../../../../images/image-20240328181247451.png" alt="image-20240328181247451"></p><h4 id="动态划分VLAN"><a href="#动态划分VLAN" class="headerlink" title="动态划分VLAN"></a>动态划分VLAN</h4><p><img src="/../../../../images/image-20240328181300986.png" alt="image-20240328181300986"></p><h4 id="基于策略划分VLAN"><a href="#基于策略划分VLAN" class="headerlink" title="基于策略划分VLAN"></a>基于策略划分VLAN</h4><p><img src="/../../../../images/image-20240328181310895.png" alt="image-20240328181310895"></p><h3 id="VLAN作用"><a href="#VLAN作用" class="headerlink" title="VLAN作用"></a>VLAN作用</h3><p>(1)控制网络流量。一个VLAN 内部的通信(包括广播通信)不会转发到其他VLAN 中去，从而有助于控制广播风暴，<strong>减小冲突域，提高网络带宽的利用率</strong>。</p><p>(2)提高网络的安全性。可以通过配置VLAN 之间的路由来提供广播过滤、安全和流量控制等功能.不同VLAN 之间的通信受到限制，<strong>提高了企业网络的安全性</strong>。</p><p>(3)灵活的网络管理。VLAN 机制使得工作组可以<strong>突破地理位置的限制而根据管理功能来划分</strong>。如果根据MAC地址划分VLAN，用户可以在任何地方接入交换网络，实现移动办公。</p><h3 id="802-1Q标签"><a href="#802-1Q标签" class="headerlink" title="802.1Q标签"></a>802.1Q标签</h3><p>是什么？</p><p>是一种网络标准，802.1Q是IEEE802.1标准系统中的一个子标准，定义了在以太网帧中添加VLAN标识符的方法。</p><p><img src="/../../../../images/image-20240328230523487.png" alt="image-20240328230523487"></p><p>以太网帧+802.1Q标签 &#x3D;&#x3D; 802.1Q帧</p><p>PRI(3位)：Priority表示优先级，提供0~7共8个优先级，当有多个帧等待发送时，按优先级顺序发送数据包。</p><p>VID(12 位):即VLAN 标识符，最多可以表示212&#x3D;4096个VLAN,其中VID0用于识别优先级，VID 4095 保留未用，所以<strong>最多可配置4094 个VLAN。默认管理VLAN是1，不能删除</strong>。</p><p>什么叫做识别优先级？</p><p>其实是对网络中的数据流或数据包进行分类，标记或标识，以便网络设备可以根据其重要性或服务质量需求进行适当的处理和传输。这种分类通常涉及到给数据流或数据包分配一个优先级等级，使得网络设备能够根据这些等级进行流量控制、调度和传输。</p><p>就比如，打电话，看你就会标记其数据包为高优先级，确保低延迟和最小的丢包率。</p><p>文件下载，网络可以将其数据包标记为低优先级，以便在网络拥挤时让出带宽给更重要的流量。</p><p><strong>交换机添加和删除VLAN标签的过程由专用硬件自动实现，处理速度很快，不会引入太大的延迟</strong>。</p><p>从用户角度看，数据源产生标准的以太帧，目标接收的也是标准的以太帧，<strong>VLAN标记对用户是透明的</strong>。</p><h3 id="交换机端口类型"><a href="#交换机端口类型" class="headerlink" title="交换机端口类型"></a>交换机端口类型</h3><p>Access接口:只能传送单个VLAN数据，一般用于连接PC&#x2F;摄像头等终端。<br>Trunk接口:能传送多个VLAN数据，一般用于交换机之间互联。<br>Hybrid接口:混合接口，包含access和trunk属性。<br>QinQ:双层标签，一般用于运营商城域网。</p><p>Trunk接口和Hybrid接口区别:</p><p>Trunk 接口通常用于连接交换机之间，可用于发送和接收多个 VLAN 的数据，所有数据帧都会被标记。</p><p>Hybrid接口能够发送和接收多个VLAN的数据，可用于交换机链路和终端设备</p><p>与trunk接口的区别是，发送数据时trunk接口只会摘掉PVID标签，而Hybrid接口能够不携带VLAN标签发送多个VLAN数据。</p><h2 id="STP生成树-上午-下午"><a href="#STP生成树-上午-下午" class="headerlink" title="STP生成树(上午+下午)"></a>STP生成树(上午+下午)</h2><h3 id="STP技术背景"><a href="#STP技术背景" class="headerlink" title="STP技术背景"></a>STP技术背景</h3><p>1、交换机单链路上，存在<strong>单点故障</strong>，线路和设备不具备冗余性。</p><p>任何一条链路或设备故障，网络将面临断网。</p><p><img src="/../../../../images/image-20240329091908658.png" alt="image-20240329091908658"></p><p>2、冗余拓扑能够解决单点故障问题</p><p>但是冗余拓扑带来了二层环路问题</p><p>实际网络环境中，经常产生二层环路从而引发网络故障。</p><p><img src="/../../../../images/image-20240329091944048.png" alt="image-20240329091944048"></p><h3 id="二层环路带来的问题"><a href="#二层环路带来的问题" class="headerlink" title="二层环路带来的问题"></a>二层环路带来的问题</h3><p><strong>广播风暴</strong></p><p>网络中若存在二层环路，一旦出现广播数据帧，这些数据帧将被交换机不断泛洪，造成广播风暴。<br>广播风暴对网络危害非常大，将严重消耗设备CPU资源及网络带宽，需要格外注意。<br>广播风暴现象:<strong>网络慢、所有指示灯高速闪烁、CPU使用率高、CLI卡顿</strong>。</p><p><img src="/../../../../images/image-20240329092121499.png" alt="image-20240329092121499"></p><p>MAC表震荡</p><p>PC发送数据帧给Server</p><p>SW3没有目的MAC表项，于是将数据帧进行<strong>泛洪</strong></p><p>SW1和SW2都收到这个帧并学习源MAC，同时将数据帧进一步泛洪</p><p><strong>SW3将从GE0&#x2F;0&#x2F;1 和GE0&#x2F;0&#x2F;2都收到这个帧并学习源MAC</strong>，更新MAC地址表</p><p><img src="/../../../../images/image-20240329092313059.png" alt="image-20240329092313059"></p><h3 id="STP基本概念"><a href="#STP基本概念" class="headerlink" title="STP基本概念"></a>STP基本概念</h3><p>采用生成树(Spanning-tree)技术，能够在网络中存在二层环路时，通过<strong>逻辑阻塞</strong>(Block)特定端口，从而<strong>打破环路</strong>，并且在网络出现拓扑变更时及时收敛，<strong>保障网络冗余性</strong>。</p><p><img src="/../../../../images/image-20240329092606785.png" alt="image-20240329092606785"></p><p>当网络出现拓扑变更时及时收敛，<strong>保障网络冗余性</strong></p><p>例如下图的SW1故障，STP会重新计算，打开原来的阻塞的端口</p><p><img src="/../../../../images/image-20240329092723349.png" alt="image-20240329092723349"></p><h3 id="网桥ID-Bridge-ID"><a href="#网桥ID-Bridge-ID" class="headerlink" title="网桥ID(Bridge ID)"></a>网桥ID(Bridge ID)</h3><ul><li><p>桥ID一共8个字节，由2个字节优先级和6个字节的MAC地址构成</p></li><li><p>桥优先级默认为 <strong>32768</strong>，可以手工修改。</p></li><li><p>AC地址为交换机背板MAC。</p></li></ul><p><img src="/../../../../images/image-20240329093108655.png" alt="image-20240329093108655"></p><h3 id="路径开销-Path-Cost"><a href="#路径开销-Path-Cost" class="headerlink" title="路径开销(Path Cost)"></a>路径开销(Path Cost)</h3><p>路径开销是一个端口量，是STP&#x2F;RSTP协议用于选择链路的参考值。<br>端口路径开销的默认值及取值范围由选定的路径开销算法决定，<strong>路径开销与端口带宽成反比</strong>。<br>华为设备路径开销标准有:802.1d-1998、802.1t及私有的legacy，默认为802.1t标准。</p><p><img src="/../../../../images/image-20240329093246807.png" alt="image-20240329093246807"></p><h3 id="STP选举操作"><a href="#STP选举操作" class="headerlink" title="STP选举操作"></a>STP选举操作</h3><p>1.确定一个根桥(Root Bridge)【选优先级和MAC地址最小的网桥)</p><p>2.确定其他网桥的根端口(Root Port)【非根桥的端口到根桥最近的端口】</p><p>3.每个段选择一个指定端口(Designated Port)【先选指定桥，指定桥上为指定端口】</p><p>4.选出非指定端口(NonDesignated Port)</p><p><img src="/../../../../images/image-20240329093426272.png" alt="image-20240329093426272"></p><p>所有选举都是选择离根桥距离最近的。</p><p>根桥上的所有接口都是指定端口</p><p>指定桥上的接口就是指定端口</p><h3 id="常见几种生成树协议"><a href="#常见几种生成树协议" class="headerlink" title="常见几种生成树协议"></a>常见几种生成树协议</h3><ul><li>生成树协议:802.1d STP(<strong>慢，拓扑收敛需要30-50s</strong>)</li><li>快速生成树协议 802.1W RSTP(<strong>快，6s内完成收敛</strong>)</li><li>多生成树协议 802.1SMSTP(<strong>实现多个VLAN负载均衡</strong>)</li></ul><p><img src="/../../../../images/image-20240329094230603.png" alt="image-20240329094230603"></p><p>解题：</p><p>1、确定SWA为根桥，所以只能阻断SWB的其中一个接口</p><p>2、根据接口的数字大小决定谁先优先，SWA的g0&#x2F;0&#x2F;1优先，会先发数据给0&#x2F;0&#x2F;2.所以SWB的g0&#x2F;0&#x2F;1阻塞</p><h3 id="城域网"><a href="#城域网" class="headerlink" title="城域网"></a>城域网</h3><p>(1)E-LAN技术是802.1Q的VLAN帧标记，双层标记，打了<strong>两层VLAN标签</strong>，这种技术被定义为<strong>IEEE802.1ad</strong>，也称为<strong>QinQ技术</strong>。</p><ul><li>QinQ实际是把<strong>用户VLAN</strong>嵌套在<strong>运营商城域以太网VLAN</strong>中传送。</li></ul><p>(2)IEEE802.1ah，也称为PBB，也叫<strong>MAC-IN-MAC技术</strong></p><p><img src="/../../../../images/image-20240329100407328.png" alt="image-20240329100407328"></p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据通信基础</title>
      <link href="/2024/05/29/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/29/%E7%AC%94%E8%AE%B0/Network/%E7%BD%91%E5%B7%A5%E4%B8%AD%E7%BA%A7/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据通信基础"><a href="#1-数据通信基础" class="headerlink" title="1.数据通信基础"></a>1.数据通信基础</h1><h2 id="信道特性"><a href="#信道特性" class="headerlink" title="信道特性"></a>信道特性</h2><p>通信目的：<strong>传递信息</strong></p><p>通信中产生和发送信息的一端叫信源，接收信息的一端叫信宿，信源和信宿之间的<strong>通信线路称为信道</strong>。</p><p><img src="/../../../../images/image-20240422144616602.png" alt="image-20240422144616602"></p><p><img src="/../../../../images/image-20240422144702544.png" alt="image-20240422144702544"></p><p>什么是模拟信号，什么是数据信号？</p><p>假设你要传输一段音乐。在模拟信号中，这段音乐将以连续的波形形式存在。当你录制音乐时，声音信号被转换成模拟电压信号，其数值随着时间的变化而连续变化，就像波形一样。这个模拟电压信号随着时间变化，可以通过一个模拟电路传输到扬声器，扬声器就会根据信号的变化而产生相应的声音，从而还原出原始的音乐。</p><p>而在数字信号中，这段音乐将被转换成离散的二进制数字。当音乐被数字化时，声音信号会被离散采样，即在固定的时间间隔内（比如每秒采样一定次数），将声音信号的振幅转换为一个数字。这些数字可以用来表示音乐的声音强度。然后，这些数字信号可以通过数字通信系统传输，比如通过互联网或者蓝牙。在接收端，这些数字信号再被解码，转换回模拟信号，然后扬声器再根据这些信号产生声音。</p><hr><h3 id="信道带宽W"><a href="#信道带宽W" class="headerlink" title="信道带宽W"></a>信道带宽W</h3><p>直接理解为，我们所说的带宽</p><p>模拟信道：**W &#x3D; f1 - f2 **(f2和f1表示：信道能通过的最高&#x2F;最低频率，单位赫兹HZ)</p><p>数字信道：数字信道是离散信道，带宽为信道能够达到的<strong>最大数据传输速率</strong>，单位是bit&#x2F;s。</p><h3 id="码元和码元速率"><a href="#码元和码元速率" class="headerlink" title="码元和码元速率"></a>码元和码元速率</h3><p>码元是什么？</p><p>码元是数字通信中的一个基本单位，它代表着一种离散的状态或符号。</p><p>通俗地说：</p><p>想象一下你在玩电话游戏，你要把一句话传给旁边的人，但你只能通过传递单个字给他。这些单词就像通信中的码元，它们是信息传递的基本单位。而传递单词时，有可能会有误解或错误，就像在通信中可能会有误差一样。</p><p>码元的作用就像是在电话游戏中传递单个字一样，它们帮助我们传递信息，并且有助于我们发现和纠正错误。</p><p>码元速率：单位时间内信道传送的码元个数。</p><p>如果码元宽度(冲脉周期)为T，则码元速率(波特率0)为</p><p><strong>B &#x3D; 1&#x2F;T，单位是波特Baud</strong></p><p>一个码元携带信息量n(位)与码元种类数(N)的关系 <strong>n&#x3D;log2^N</strong></p><p>好比这样记：</p><p>N&#x3D;4,n&#x3D;2, 00 01 10 11  </p><p>N&#x3D;8,n&#x3D;3, 000 001 010 011 ….. 111 </p><p>什么是码元宽度？</p><p>码元宽度是指在数字通信中，每个码元所持续的时间长度。</p><p>通俗地说：</p><p>码元宽度就像是你用闪光灯发送信息一样。如果你每秒闪一次，那么每个码元（每个闪光）的宽度就是一秒钟。但如果你闪得更快，比如每半秒一次，那么每个码元的宽度就是半秒钟。这个宽度决定了你发送信息的速度，就像闪光灯频率决定了你发送信息的快慢一样。</p>]]></content>
      
      
      <categories>
          
          <category> Network - 网工中级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> 网工中级 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
